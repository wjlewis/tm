{"version":3,"sources":["ErrorReport/fix-start-0.png","ErrorReport/fix-start-1.png","ErrorReport/nondet-0.png","ErrorReport/nondet-1.png","state-mgmt/actions.ts","state-mgmt/auxiliary.ts","tools/Vector.ts","tools/auxiliary.ts","state-mgmt/Mode.ts","state-mgmt/UI.ts","state-mgmt/Node.ts","state-mgmt/Arrow.ts","state-mgmt/ControlPoint.ts","state-mgmt/Sim.ts","state-mgmt/Tape.ts","state-mgmt/TransitionDetail.ts","state-mgmt/UndoRedo.ts","state-mgmt/Message.ts","state-mgmt/MetaData.ts","state-mgmt/state.ts","state-mgmt/reducer.ts","state-mgmt/middleware/keyboardShortcuts.ts","ErrorReport/ErrorReport.tsx","ErrorReport/MissingStartState.tsx","ErrorReport/NondeterministicTransition.tsx","HaltReport/HaltReport.tsx","HaltReport/Accept.tsx","HaltReport/Reject.tsx","state-mgmt/sagas/autoSave.ts","state-mgmt/sagas/sim.ts","state-mgmt/sagas/index.ts","state-mgmt/store.ts","state-mgmt/middleware/addTransition.ts","state-mgmt/middleware/deleteTransitionDetail.ts","state-mgmt/middleware/deleteNode.ts","state-mgmt/middleware/validateTransitionDetails.ts","state-mgmt/middleware/validatePreSim.ts","state-mgmt/middleware/halt.ts","state-mgmt/middleware/loadSave.ts","state-mgmt/middleware/downloadUpload.ts","Arrow/Arrow.tsx","Node/Node.tsx","ControlPoint/ControlPoint.tsx","TransitionDetail/TransitionDetail.tsx","TransitionDetails/TransitionDetails.tsx","ShadowNode/ShadowNode.tsx","Canvas/Canvas.tsx","state-mgmt/EditControls.ts","EditControls/EditControls.tsx","AppControls/examples/snapshots.ts","AppControls/AppControls.tsx","Tape/Tape.tsx","SimControls/SimControls.tsx","NameInput/NameInput.tsx","Message/Message.tsx","App/App.tsx","index.tsx"],"names":["module","exports","addTransitionDetail","arrow","type","payload","moveTape","direction","writeTapeSymbol","symbol","deleteEntities","nodes","arrows","controlPoints","transitionDetails","displayMessage","title","content","STEP_SIM","PLAY_SIM","PAUSE_SIM","RESET_RUNNING_SIM","resetSim","setCurrentNode","node","setTapeWritingStatus","isWriting","setGlowingNode","setFadeInNode","setFadeOutNode","setGlowingArrow","setGlowingControlPoint","controlPoint","setGlowingTransitionDetail","transitionDetail","HALT_ACCEPT","haltAccept","HALT_REJECT","haltReject","switchMode","mode","saveSnapshot","installSnapshot","snapshot","undoable","currentLatest","state","wip","committed","getSnapshot","_","get","revertToSnapshot","entities","mapValues","value","key","Vector","x","y","Math","sqrt","this","len","magnitude","Error","v","plus","scale","factor","atan2","dot","repeat","what","times","res","Array","i","Modes","EDIT","SIM","initModeState","isInEditMode","modeReducer","action","initUIState","mousePos","keysDown","isMouseDownNode","isMouseDownControlPoint","isAddingNode","wasMouseReleasedOverNode","wasMouseDragged","ui","isMultiselect","includes","uiReducer","keyDown","keyUp","mouseDownNode","mouseUpNode","mouseDownControlPoint","mouseUpControlPoint","mouseDownCanvas","mouseUpCanvas","startAddingNode","addNode","mouseMoveCanvas","pos","uniq","filter","k","allNodes","Object","values","byId","nodeById","id","find","n","isNodeSelected","selected","isNodeFinal","isFinal","selectedNodes","isStartNode","startNode","nodesReducer","addArrow","start","end","makeStartNode","toggleFinalNodes","selectAllNodes","uuid","mnemonic","mergeWith","_1","_2","undefined","ids","omit","merge","map","atLeastOneFinal","some","updated","reduce","acc","keys","xs","offsets","nodeId","from","minus","moved","updatedPos","allArrows","arrowById","arrowsReducer","allControlPoints","controlPointForArrow","arrowId","cp","controlPointsReducer","mouseUpNodeOrCanvas","startPos","endPos","controlPos","diff","perp","normalize","constructStandardPos","selectedOffset","prepForDirectMove","prepForIndirectMove","fullOffsets","halfOffsets","p","includesStart","includesEnd","fixedPos","movingPos","movingOffset","toCP","cpShadow","project","fractionAlong","perpLength","moveDirect","moveIndirect","fullMoved","halfMoved","newPos","alongDiff","initSimState","hasStarted","initialTapeEntries","currentNode","activeTapeCell","isTapeWriting","glowingNode","fadeInNode","fadeOutNode","glowingArrow","glowingControlPoint","glowingTransitionDetail","intervalDivisor","sim","isNodeCurrent","isNodeGlowing","isNodeFadingIn","isNodeFadingOut","isArrowGlowing","isControlPointGlowing","simInterval","floor","simIntervalDivisor","simReducer","A","stepSim","playSim","setSimIntervalDivisor","divisor","tapeEntries","TapeDirections","R","max","initTapeState","entries","scrollLeft","focused","L","tape","focusedTapeCell","currentReadSymbol","activeCell","tapeReducer","changeTapeCell","updateScrollLeft","focusTapeCell","clearTape","update","clone","length","updateBlocks","leftPos","cellDiff","slice","every","val","active","set","initialEntries","allTransitionDetails","allGroupedTransitionDetails","groupBy","detail","transitionDetailsForArrow","duplicateTransitionDetails","duplicates","transitionDetailsByStart","ds","read","group","flattenDeep","focusedDetail","transitionDetailsReducer","changeTransitionDetail","deleteTransitionDetail","focusTransitionDetail","blurTransitionDetail","markDuplicateTransitions","write","move","isFocused","isDuplicate","undoRedoReducer","undoRedo","addRecord","undo","actions","record","rest","redoRecord","redoable","redo","undoRecord","description","showMessage","message","show","messageTitle","messageContent","messageReducer","dismissMessage","machineName","metaData","name","metaDataReducer","changeMachineName","initState","newMachine","freshSnapshot","reducer","keyBindings","st","e","ctrlKey","preventDefault","metaKey","ErrorReport","className","props","whatsWrong","howToFix","React","Component","fix","src","step0","alt","step1","nondet0","nondet1","HaltReport","wasSuccess","accepted","formatTapeEntries","initTapeEntries","finalTapeEntries","reversed","reverse","withExplicitNulls","dropWhile","withPadding","s","autoSave","FIVE_SECONDS","delay","put","play","makeStep","nodeStep","tapeStep","arrowStep","transitionDetailStep","controlPointStep","singleStep","call","channel","completedChan","fork","playTask","take","stopAction","cancel","select","current","readSym","availableTransitionInfo","transitionInfo","controlPointId","transitionDetailId","writeSymbol","tapeDirection","interval","outgoingArrows","arrowsForStart","flatten","next","hasUpdatedCurrent","cancelled","hasWrittenSymbol","hasMovedTape","takeEvery","main","all","sagaMiddleware","createSagaMiddleware","store","createStore","composeWithDevTools","applyMiddleware","api","getState","event","keyHandler","altAction","existingArrow","startId","endId","a","arrowForEndpoints","nodeIds","arrowsForNode","arrowIds","controlPointIds","transitionDetailIds","hasStartNode","NondeterministicTransition","MissingStartState","contentProducer","accept","reject","saved","localStorage","getItem","JSON","parse","clearItem","setItem","stringify","machineString","dataURI","encodeURIComponent","filenameCandidate","toLowerCase","split","join","filename","linkElt","document","createElement","setAttribute","click","installMachine","uploadElt","removeEventListener","files","text","machine","addEventListener","run","mainSaga","Arrow","arrowRef","createRef","classNames","isEditable","pathString","isSelfLoop","computeCubicPathString","computeQuadraticPathString","d","ref","renderGlow","control","mid","bezierControl","v1","v2","ctrl1","ctrl2","isGlowing","getTotalLength","style","strokeDasharray","strokeDashoffset","animationDuration","connect","ownProps","details","Node","handleMouseDown","mouseDown","handleMouseUp","mouseUp","isSelected","isStart","isFadingIn","isFadingOut","isCurrent","position","left","MARKER_WIDTH","top","onMouseDown","onMouseUp","dispatch","ControlPoint","computeCubicString","p1","p2","tip","ARROW_LENGTH","TransitionDetail","readRef","handleSelectChange","onChange","changeDirection","target","selectLeft","selectRight","handleFocus","onFocus","handleBlur","onBlur","handleDeleteClick","onDelete","inputClassName","readInputClassName","selectorClassName","deleteButtonClassName","disabled","placeholder","handleInputChange","maxLength","onClick","focus","property","TransitionDetails","handleDetailChange","changeDetail","stance","computeStance","isTopStance","renderAddDetailButton","glowingDetail","handleDetailDelete","handleDetailFocus","handleDetailBlur","deleteDetail","focusDetail","blurDetail","addDetail","computeSelfLoopStance","computeStandardStance","theta","angle","computeClassNameFromAngle","PI","anchor","test","handleAddDetailButton","ShadowNode","add","isVisible","Canvas","computeMousePos","handleMouseMove","mouseMove","onMouseMove","xmlns","width","height","currentTarget","getBoundingClientRect","clientX","clientY","whichButtonTypes","EditButtonTypes","ADD_STATE","REMOVE_STATE","ADD_SELF_TRANSITION","MAKE_START","TOGGLE_ACCEPTING","REMOVE_TWO_STATES","ADD_TRANSITION","TOGGLE_TWO_ACCEPTING","REMOVE_MANY_STATES","TOGGLE_MANY_ACCEPTING","UNMAKE_START","EditControls","handleUndoButtonClick","handleRedoButtonClick","buttonConfig","addState","removeStates","addTransition","makeStart","toggleFinal","inEditMode","buttonTypes","config","copy1","multiply","AppControls","handleNewClick","handleDownloadClick","download","handleUploadClick","upload","handleExampleSelection","snapshotName","snapshots","loadExample","href","process","rel","Tape","tapeRef","handleScroll","handleClearButtonClick","clear","renderReadHead","onScroll","CELL_WIDTH","l","index","handleCellChange","handleCellFocus","renderFeeders","renderClearButton","renderReadWriteOverlay","scrollTo","oldProps","focusedCell","updateFocus","centerActive","cellToFocus","childNodes","changeCell","focusCell","smooth","behavior","right","SimControls","reset","resetRunning","togglePlayPause","pause","step","handleSpeedChange","setIntervalDivisor","Number","playPauseClassName","min","NameInput","handleNameChange","changeName","Message","handleMessageClick","stopPropagation","dismiss","App","handleKeyDown","handleKeyUp","loadSaved","ReactDOM","render","getElementById"],"mappings":"0IAAAA,EAAOC,QAAU,00Y,cCAjBD,EAAOC,QAAU,k3X,gBCAjBD,EAAOC,QAAU,IAA0B,sC,gBCA3CD,EAAOC,QAAU,IAA0B,sC,ovjCC0F9BC,EAAsB,SAACC,GAAD,MAA4B,CAC7DC,KAFmC,wBAGnCC,QAAS,CAAEF,WAoDAG,EAAW,SAACC,GAAD,MAAmC,CACzDH,KAFuB,YAGvBC,QAAS,CAAEE,eAIAC,EAAkB,SAACC,GAAD,MAA6B,CAC1DL,KAF+B,oBAG/BC,QAAS,CAAEI,YAwCAC,EAAiB,SAACC,EAAiBC,EAAkBC,EAAyBC,GAA7D,MAAsG,CAClIV,KAF6B,kBAG7BC,QAAS,CAAEM,QAAOC,SAAQC,gBAAeC,uBAc9BC,EAAiB,SAACC,EAAeC,GAAhB,MAA4D,CACxFb,KAF6B,kBAG7BC,QAAS,CAAEW,QAAOC,aASPC,EAAW,WAKXC,EAAW,WAKXC,EAAY,YAKZC,EAAoB,oBAMpBC,EAAW,iBAAe,CACrClB,KAFuB,cAYZmB,EAAiB,SAACC,GAAD,MAAkC,CAC9DpB,KAF8B,mBAG9BC,QAAS,CAAEmB,UAIAC,EAAuB,SAACC,GAAD,MAAiC,CACnEtB,KAFqC,0BAGrCC,QAAS,CAAEqB,eAIAC,EAAiB,SAACH,GAAD,MAAkC,CAC9DpB,KAF8B,mBAG9BC,QAAS,CAAEmB,UAIAI,EAAgB,SAACJ,GAAD,MAAkC,CAC7DpB,KAF8B,mBAG9BC,QAAS,CAAEmB,UAIAK,EAAiB,SAACL,GAAD,MAAkC,CAC9DpB,KAF+B,oBAG/BC,QAAS,CAAEmB,UAIAM,EAAkB,SAAC3B,GAAD,MAAmC,CAChEC,KAF+B,oBAG/BC,QAAS,CAAEF,WAIA4B,EAAyB,SAACC,GAAD,MAA0C,CAC9E5B,KAFuC,4BAGvCC,QAAS,CAAE2B,kBAIAC,EAA6B,SAACC,GAAD,MAA8C,CACtF9B,KAF2C,gCAG3CC,QAAS,CAAE6B,sBAGAC,EAAc,cACdC,EAAa,iBAAe,CACvChC,KAAM+B,IAGKE,EAAc,cACdC,EAAa,iBAAe,CACvClC,KAAMiC,IAKKE,EAAa,SAACC,GAAD,MAAyB,CACjDpC,KAFyB,cAGzBC,QAAS,CAAEmC,UAiBAC,EAAe,iBAAe,CACzCrC,KAF2B,kBAWhBsC,EAAkB,SAACC,EAAeC,GAAhB,MAA+C,CAC5ExC,KAF8B,mBAG9BC,QAAS,CAAEsC,WAAUC,c,6PC9ThB,IAAMC,EAAgB,SAAIC,GAAJ,OAC3BA,EAAMC,KAAOD,EAAME,WAURC,EAAc,SAACH,GAAD,OAAkBI,IAAEC,IAAIL,EAAO,aAK7CM,EAAmB,SAACN,EAAcH,GAO7C,O,qVAAO,CAAP,GACKG,EADL,CAEEO,SAAUH,IAAEI,UAAUX,EARC,SAACY,GAAD,OACvBL,IAAEI,UAAUC,EAAO,SAACA,EAAOC,GAAR,MACT,QAARA,EAAgB,KAAOD,S,cC4BdE,E,WAjEb,WAAmBC,EAAkBC,GAAY,yBAA9BD,IAA6B,KAAXC,I,wDAQnC,OAAOC,KAAKC,KAAKC,KAAKJ,EAAII,KAAKJ,EAAII,KAAKH,EAAIG,KAAKH,K,kCAKjD,IAAMI,EAAMD,KAAKE,YACjB,GAAY,IAARD,EACF,MAAM,IAAIE,MAAM,6BAElB,OAAO,IAAIR,EAAOK,KAAKJ,EAAIK,EAAKD,KAAKH,EAAII,K,6BAMzC,OAAO,IAAIN,GAAQK,KAAKH,EAAGG,KAAKJ,K,2BAI7BQ,GACH,OAAO,IAAIT,EAAOK,KAAKJ,EAAIQ,EAAER,EAAGI,KAAKH,EAAIO,EAAEP,K,4BAIvCO,GACJ,OAAOJ,KAAKK,KAAKD,EAAEE,OAAO,M,4BAItBC,GACJ,OAAO,IAAIZ,EAAOY,EAASP,KAAKJ,EAAGW,EAASP,KAAKH,K,8BAKjD,OAAOC,KAAKU,MAAMR,KAAKH,EAAGG,KAAKJ,K,8BAIzBQ,GACN,OAAOA,EAAEE,MAAMN,KAAKS,IAAIL,GAAKA,EAAEK,IAAIL,M,0BAIjCA,GACF,OAAOJ,KAAKJ,EAAIQ,EAAER,EAAII,KAAKH,EAAIO,EAAEP,K,+BAlDjC,OAAO,IAAIF,EADqC,EAApCC,EAAoC,EAAjCC,O,aCSNa,EAAS,SAAIC,EAASC,GAEjC,IADA,IAAMC,EAAM,IAAIC,MAAMF,GACbG,EAAI,EAAGA,EAAIH,EAAOG,IACzBF,EAAIE,GAAKJ,EAEX,OAAOE,G,4NCXF,IAAMG,EAAiC,CAC5CC,KAAM,OACNC,IAAK,OAGMC,EAA2B,CACtCzC,KAAMsC,EAAMC,MAIDG,EAAe,SAACpC,GAAD,OAA2BA,EAAMN,KAAKA,OAASsC,EAAMC,MAEpEI,GAAc,SAACrC,EAAcsC,GACxC,OAAQA,EAAOhF,MACb,IJ6RuB,cI5RrB,OAAOmC,GAAWO,EAAOsC,EAAO/E,QAAQmC,MAC1C,QACE,OAAOM,EAAMN,OAIbD,GAAa,SAACO,EAAcN,GAAf,O,qVAAA,IACdM,EAAMN,KADQ,CAEjBA,U,ujBCbK,IAAM6C,GAAuB,CAClCC,SAAU,IAAI7B,EAAO,EAAG,GACxB8B,SAAU,GACVC,iBAAiB,EACjBC,yBAAyB,EACzBC,cAAc,EACdC,0BAA0B,EAC1BC,iBAAiB,GAINN,GAAW,SAACxC,GAAD,OAA0BA,EAAM+C,GAAGP,UAG9CQ,GAAgB,SAAChD,GAAD,OAA2BA,EAAM+C,GAAGN,SAASQ,SAAS,UAGtEP,GAAkB,SAAC1C,GAAD,OAA2BA,EAAM+C,GAAGL,iBAGtDC,GAA0B,SAAC3C,GAAD,OAA2BA,EAAM+C,GAAGJ,yBAG9DC,GAAe,SAAC5C,GAAD,OAA2BA,EAAM+C,GAAGH,cAInDE,GAAkB,SAAC9C,GAAD,OAA2BA,EAAM+C,GAAGD,iBAEtDI,GAAY,SAAClD,EAAcsC,GACtC,IAAIF,EAAapC,GA6Bf,OAAOA,EAAM+C,GA5Bb,OAAQT,EAAOhF,MACb,ILyHkB,WKxHhB,OAAO6F,GAAQnD,EAAOsC,EAAO/E,QAAQmD,KACvC,IL6HgB,SK5Hd,OAAO0C,GAAMpD,EAAOsC,EAAO/E,QAAQmD,KACrC,IL1CyB,kBK2CvB,OAAO2C,GAAcrD,GACvB,ILtCuB,gBKuCrB,OAAOsD,GAAYtD,GACrB,ILWkC,2BKVhC,OAAOuD,GAAsBvD,GAC/B,ILegC,yBKd9B,OAAOwD,GAAoBxD,GAC7B,IL4F2B,oBK3FzB,OAAOyD,GAAgBzD,GACzB,ILgGyB,kBK/FvB,OAAO0D,GAAc1D,GACvB,ILvC2B,oBKwCzB,OAAO2D,GAAgB3D,GACzB,ILpCkB,WKqChB,OAAO4D,GAAQ5D,GACjB,IL+F2B,oBK9FzB,OAAO6D,GAAgB7D,EAAOsC,EAAO/E,QAAQuG,KAC/C,QACE,OAAO9D,EAAM+C,KAQfI,GAAU,SAACnD,EAAcU,GAAf,aACXV,EAAM+C,GADK,CAEdN,SAAUrC,IAAE2D,KAAF,sBAAW/D,EAAM+C,GAAGN,UAApB,CAA8B/B,QAGpC0C,GAAQ,SAACpD,EAAcU,GAAf,aACTV,EAAM+C,GADG,CAEZN,SAAUzC,EAAM+C,GAAGN,SAASuB,OAAO,SAAAC,GAAC,OAAIA,IAAMvD,OAG1C2C,GAAgB,SAACrD,GAAD,aACjBA,EAAM+C,GADW,CAEpBL,iBAAiB,KAGbY,GAAc,SAACtD,GAAD,aACfA,EAAM+C,GADS,CAElBL,iBAAiB,EACjBG,0BAA0B,KAGtBU,GAAwB,SAACvD,GAAD,aACzBA,EAAM+C,GADmB,CAE5BJ,yBAAyB,KAGrBa,GAAsB,SAACxD,GAAD,aACvBA,EAAM+C,GADiB,CAE1BJ,yBAAyB,KAGrBc,GAAkB,SAACzD,GAAD,aACnBA,EAAM+C,GADa,CAEtBD,iBAAiB,KAGbY,GAAgB,SAAC1D,GAAD,aACjBA,EAAM+C,GADW,CAEpBL,iBAAiB,EACjBC,yBAAyB,EACzBE,0BAA0B,KAGtBc,GAAkB,SAAC3D,GAAD,aACnBA,EAAM+C,GADa,CAEtBH,cAAc,KAGVgB,GAAU,SAAC5D,GAAD,aACXA,EAAM+C,GADK,CAEdH,cAAc,EACdC,0BAA0B,KAGtBgB,GAAkB,SAAC7D,EAAc8D,GAAf,aACnB9D,EAAM+C,GADa,CAEtBP,SAAUsB,EACVhB,iBAAiB,K,ujBC3GZ,IAWMoB,GAAW,SAAClE,GAAD,OACtBmE,OAAOC,OAAOrE,EAAcC,EAAMO,SAAS1C,OAAOwG,OAIvCC,GAAW,SAACtE,EAAcuE,GACrC,IAAM7F,EAAOwF,GAASlE,GAAOwE,KAAK,SAAAC,GAAC,OAAIA,EAAEF,KAAOA,IAChD,IAAK7F,EACH,MAAM,IAAIyC,MAAJ,2BAA8BoD,EAA9B,MAER,OAAO7F,GAIIgG,GAAiB,SAAC1E,EAAcuE,GAAf,OAC5BxE,EAAcC,EAAMO,SAAS1C,OAAO8G,SAAS1B,SAASsB,IAI3CK,GAAc,SAAC5E,EAAcuE,GAAf,OACzBxE,EAAcC,EAAMO,SAAS1C,OAAOwG,KAAKE,GAAIM,SAIlCC,GAAgB,SAAC9E,GAAD,OAC3BD,EAAcC,EAAMO,SAAS1C,OAAO8G,UAIzBI,GAAc,SAAC/E,EAAcuE,GAAyB,IACzDS,EAAcjF,EAAcC,EAAMO,SAAS1C,OAA3CmH,UACR,OAAsB,OAAdA,GAAuBA,IAAcT,GAgBlCU,GAAe,SAACjF,EAAcsC,GACzC,IAAIF,EAAapC,GAgCf,OAAOA,EAAMO,SAAS1C,MA/BtB,OAAQyE,EAAOhF,MAEb,IN7DkB,WM8DhB,OAAOsG,GAAQ5D,EAAOsC,EAAO/E,QAAQuG,KACvC,INjCmB,YMkCjB,OAAOoB,GAASlF,EAAOsC,EAAO/E,QAAQ4H,MAAO7C,EAAO/E,QAAQ6H,KAC9D,IN4FyB,kBM3FvB,OAAOxH,GAAeoC,EAAOsC,EAAO/E,QAAQM,OAC9C,INxDkC,2BMyDhC,OAAOwH,GAAcrF,GACvB,INrDqC,8BMsDnC,OAAOsF,GAAiBtF,GAC1B,INlD0B,mBMmDxB,OAAOuF,GAAevF,GAGxB,IN/FyB,kBMgGvB,OAAOqD,GAAcrD,EAAOsC,EAAO/E,QAAQgH,IAC7C,IN3FuB,gBM4FrB,OAAOjB,GAAYtD,GACrB,IN2C2B,oBM1CzB,OAAOyD,GAAgBzD,EAAOsC,EAAO/E,QAAQuG,KAC/C,IN+CyB,kBM9CvB,OAAOJ,GAAc1D,GACvB,INkD2B,oBMjDzB,OAAO6D,GAAgB7D,EAAOsC,EAAO/E,QAAQuG,KAC/C,QACE,OAAO9D,EAAMO,SAAS1C,QAUxB+F,GAAU,SAAC5D,EAAc8D,GAC7B,IAAMS,EAAKiB,MACL9G,EAAO,CAAE6F,KAAIT,MAAK2B,SAAU,GAAIZ,SAAS,GAC/C,MAAO,CACL5E,IAAK,KACLC,UAAWE,IAAEsF,UAAU,GAAI1F,EAAMO,SAAS1C,MAAMqC,UAAW,CACzDmE,KAAK,eACFE,EAAK7F,IAGP,SAACiH,EAAIC,EAAIlF,GAAT,MAAyB,aAARA,EAAqB,CAAC6D,QAAMsB,MAM9CX,GAAW,SAAClF,EAAcmF,EAAeC,GAA9B,MAA0D,CACzEnF,IAAK,KACLC,UAAU,MACLF,EAAMO,SAAS1C,MAAMqC,UADjB,CAEPyE,SAAUQ,IAAUC,EAChB,GACApF,EAAMO,SAAS1C,MAAMqC,UAAUyE,aAIjC/G,GAAiB,SAACoC,EAAc8F,GAA8B,IAC1D5F,EAAcF,EAAMO,SAAS1C,MAA7BqC,UACR,MAAO,CACLD,IAAK,KACLC,UAAU,MACLA,EADI,CAEPmE,KAAMjE,IAAE2F,KAAK7F,EAAUmE,KAAMyB,GAC7BnB,SAAU,GACVK,UAAW9E,EAAU8E,WAAac,EAAI7C,SAAS/C,EAAU8E,WACrD,KACA9E,EAAU8E,cAKdK,GAAgB,SAACrF,GAAD,MAA8B,CAClDC,IAAK,KACLC,UAAWE,IAAE4F,MAAM,GAAIhG,EAAMO,SAAS1C,MAAMqC,UAAW,CACrD8E,UAAWhF,EAAMO,SAAS1C,MAAMqC,UAAUyE,SAAS,OAQjDW,GAAmB,SAACtF,GACxB,IAAM2E,EAAWG,GAAc9E,GAAOiG,IAAI,SAAA1B,GAAE,OAAID,GAAStE,EAAOuE,KAC1D2B,EAAkBvB,EAASwB,KAAK,SAAAzH,GAAI,OAAIA,EAAKmG,UAC7CuB,EAAUzB,EAAS0B,OAAO,SAACC,EAAK1F,GAAN,aAC3B0F,EAD2B,eAE7B1F,EAAE2D,GAF2B,MAEjB3D,EAFiB,CAEdiE,SAAUqB,OACxB,IAEJ,MAAO,CACLjG,IAAK,KACLC,UAAWE,IAAE4F,MAAM,GAAIhG,EAAMO,SAAS1C,MAAMqC,UAAW,CACrDmE,KAAK,MACA+B,OAMLb,GAAiB,SAACvF,GAAD,MAA8B,CACnDC,IAAK,KACLC,UAAU,MACLF,EAAMO,SAAS1C,MAAMqC,UADjB,CAEPyE,SAAUR,OAAOoC,KAAKvG,EAAMO,SAAS1C,MAAMqC,UAAUmE,UAWnDhB,GAAgB,SAACrD,EAAcuE,GAA2B,IHlNjC3D,EAAM4F,EGmN3B3I,EAAUmC,EAAMO,SAAhB1C,MACA8G,EAAa9G,EAAMqC,UAAnByE,SACR,MAAO,CACL1E,IAAK,KACLC,UAAU,MACLrC,EAAMqC,UADF,CAEPyE,SAAU3B,GAAchD,IHzNCY,EG0NT2D,EH1NeiC,EG0NX7B,EHzNxB6B,EAAGvD,SAASrC,GAAK4F,EAAGxC,OAAO,SAAAnD,GAAC,OAAIA,IAAMD,IAAtC,sBAA+C4F,GAA/C,CAAmD5F,KG0N3C+D,EAAS1B,SAASsB,GAAMI,EAAW,CAACJ,OAQxCjB,GAAc,SAACtD,GAAD,MAA8B,CAChDC,IAAK,KACLC,UAAU,MACLH,EAAcC,EAAMO,SAAS1C,OADzB,CAEP4I,QAAS,OAOPhD,GAAkB,SAACzD,EAAcwC,GACrC,IAAKE,GAAgB1C,GAAQ,OAAOA,EAAMO,SAAS1C,MADkB,IAG7DA,EAAUmC,EAAMO,SAAhB1C,MACF4I,EAAU5I,EAAMqC,UAAUyE,SAAS0B,OAAO,SAACC,EAAKI,GACpD,IAAMhI,EAAOb,EAAMqC,UAAUmE,KAAKqC,GAClC,OAAO,MACFJ,EADL,eAEGI,EAAS/F,EAAOgG,KAAKjI,EAAKoF,KAAK8C,MAAMpE,MAEvC,IAEH,OAAO,MACF3E,EADL,CAEEoC,IAAI,MACCpC,EAAMqC,UADR,CAEDuG,eAUA/C,GAAgB,SAAC1D,GAAD,ODhOkB,SAACA,GAAD,OAA2BA,EAAM+C,GAAGF,yBCiO1EA,CAAyB7C,GACvBA,EAAMO,SAAS1C,MACf,CACAoC,IAAK,KACLC,UAAU,MACLF,EAAMO,SAAS1C,MAAMqC,UADjB,CAEPyE,SAAU3B,GAAchD,GAASA,EAAMO,SAAS1C,MAAMqC,UAAUyE,SAAW,OAQ3Ed,GAAkB,SAAC7D,EAAcwC,GAAiC,IAC9D3E,EAAUmC,EAAMO,SAAhB1C,MAER,IAAK6E,GAAgB1C,KAAWnC,EAAMoC,IAAK,OAAOpC,EAKlD,IAAMgJ,EAAQ1C,OAAOoC,KAAK1I,EAAMoC,IAAIwG,SAASJ,OAAO,SAACC,EAAK/B,GACxD,IAAM7F,EAAOb,EAAMoC,IAAKoE,KAAKE,GACvBuC,EAAatE,EAASnB,KAAKxD,EAAMoC,IAAKwG,QAAQlC,IACpD,OAAO,MACF+B,EADL,eAEG/B,EAFH,MAEa7F,EAFb,CAEmBoF,IAAKgD,OAEvB,IAEH,OAAO1G,IAAE4F,MAAM,GAAInI,EAAO,CACxBoC,IAAK,CACHoE,KAAK,MACAwC,O,6NC1RJ,IAKME,GAAY,SAAC/G,GAAD,OACvBmE,OAAOC,OAAOpE,EAAMO,SAASzC,OAAOuG,OAIzB2C,GAAY,SAAChH,EAAcuE,GACtC,IAAMlH,EAAQ2C,EAAMO,SAASzC,OAAOuG,KAAKE,GACzC,IAAKlH,EACH,MAAM,IAAI8D,MAAJ,4BAA+BoD,EAA/B,MAER,OAAOlH,GAqBI4J,GAAgB,SAACjH,EAAcsC,GAC1C,IAAIF,EAAapC,GAWf,OAAOA,EAAMO,SAASzC,OAVtB,OAAQwE,EAAOhF,MACb,IPGmB,YOFjB,OAAO4H,GAASlF,EAAOsC,EAAO/E,QAAQ4H,MAAO7C,EAAO/E,QAAQ6H,IAAK9C,EAAO/E,QAAQgH,IAClF,IPgIyB,kBO/HvB,OAAO3G,GAAeoC,EAAOsC,EAAO/E,QAAQO,QAC9C,QACE,OAAOkC,EAAMO,SAASzC,SAQxBoH,GAAW,SAAClF,EAAcmF,EAAeC,EAAab,GAA3C,OACfnE,IAAE4F,MAAM,GAAIhG,EAAMO,SAASzC,OAAQ,CACjCuG,KAAK,eACFE,EAAK,CAAEY,QAAOC,MAAKb,UAKpB3G,GAAiB,SAACoC,EAAc8F,GAAf,O,uVAAA,IAClB9F,EAAMO,SAASzC,OADG,CAErBuG,KAAMjE,IAAE2F,KAAK/F,EAAMO,SAASzC,OAAOuG,KAAMyB,M,ujBC1BpC,IAYMoB,GAAmB,SAAClH,GAAD,OAC9BmE,OAAOC,OAAOrE,EAAcC,EAAMO,SAASxC,eAAesG,OAI/C8C,GAAuB,SAACnH,EAAcoH,GACjD,IAAMC,EAAKH,GAAiBlH,GAAOwE,KAAK,qBAAGnH,QAAsB+J,IACjE,IAAKC,EACH,MAAM,IAAIlG,MAAJ,2DAA8DiG,EAA9D,MAER,OAAOC,GAGIC,GAAuB,SAACtH,EAAcsC,GACjD,IAAIF,EAAapC,GAsBf,OAAOA,EAAMO,SAASxC,cArBtB,OAAQuE,EAAOhF,MACb,IRtBmB,YQuBjB,OAAO4H,GAASlF,EAAOsC,EAAO/E,QAAQ4H,MAAO7C,EAAO/E,QAAQ6H,IAAK9C,EAAO/E,QAAQgH,IAClF,IRuGyB,kBQtGvB,OAAO3G,GAAeoC,EAAOsC,EAAO/E,QAAQQ,eAC9C,IRnBkC,2BQoBhC,OAAOwF,GAAsBvD,EAAOsC,EAAO/E,QAAQgH,IACrD,IRfgC,yBQgB9B,OAAOf,GAAoBxD,GAC7B,IR8D2B,oBQ7DzB,OAAOyD,GAAgBzD,EAAOsC,EAAO/E,QAAQuG,KAC/C,IRuE2B,oBQtEzB,OAAOD,GAAgB7D,EAAOsC,EAAO/E,QAAQuG,KAC/C,IRgEyB,kBQ/DzB,IR/EuB,gBQgFrB,OAAOyD,GAAoBvH,GAC7B,QACE,OAAOA,EAAMO,SAASxC,gBAWxBmH,GAAW,SAAClF,EAAcmF,EAAeC,EAAa/H,GAC1D,IAAMkH,EAAKiB,MACLgC,EAAW7G,EAAOgG,KAAKrC,GAAStE,EAAOmF,GAAOrB,KAC9C2D,EAAStC,IAAUC,EAAMoC,EAAW7G,EAAOgG,KAAKrC,GAAStE,EAAOoF,GAAKtB,KAerE4D,EAAavC,IAAUC,EAC3BoC,EAASZ,MAAM,IAAIjG,EAAO,EAAG,KAdF,SAACwE,EAAeC,GAC3C,IAAMuC,EAAOvC,EAAIwB,MAAMzB,GAMjByC,EAA4B,IAArBD,EAAKzG,YACdyG,EAAKC,OAAOC,YAAYvG,OAAO,GAC/B,IAAIX,EAAO,GAAI,GACnB,OAAOgH,EAAKrG,MAAM,IAAOD,KAAKuG,GAAMvG,KAAK8D,GAKzC2C,CAAqBN,EAAUC,GAEjC,MAAO,CACLxH,IAAK,KACLC,UAAWE,IAAE4F,MAAM,GAAIhG,EAAMO,SAASxC,cAAcmC,UAAW,CAC7DmE,KAAK,eACFE,EAAK,CAAEA,KAAIlH,QAAOyG,IAAK4D,QAM1B9J,GAAiB,SAACoC,EAAc8F,GAAf,MAAqD,CAC1E7F,IAAK,KACLC,UAAU,MACLF,EAAMO,SAASxC,cAAcmC,UADzB,CAEPmE,KAAMjE,IAAE2F,KAAK/F,EAAMO,SAASxC,cAAcmC,UAAUmE,KAAMyB,OAQxDvC,GAAwB,SAACvD,EAAcuE,GAAf,aACzBvE,EAAMO,SAASxC,cADU,CAE5BkC,IAAK,KACLC,UAAU,MACLF,EAAMO,SAASxC,cAAcmC,UADzB,CAEPyE,SAAUJ,OAMRf,GAAsB,SAACxD,GAAD,MAAsC,CAChEC,IAAK,KACLC,UAAU,MACLH,EAAcC,EAAMO,SAASxC,eADzB,CAEP4G,SAAU,KACVoD,eAAgB,SASdtE,GAAkB,SAACzD,EAAcwC,GACrC,OAAIG,GAAwB3C,GAAegI,GAAkBhI,EAAOwC,GAC3DE,GAAgB1C,GAAeiI,GAAoBjI,EAAOwC,GACvDxC,EAAMO,SAASxC,eAMvBiK,GAAoB,SAAChI,EAAcwC,GACvC,IAAMzE,EAAgBiC,EAAMO,SAASxC,cAAcmC,UACnD,IAAKnC,EAAc4G,SACjB,OAAO3E,EAAMO,SAASxC,cAExB,IAAMmB,EAAenB,EAAcsG,KAAKtG,EAAc4G,UAChDoD,EAAiBpH,EAAOgG,KAAKzH,EAAa4E,KAAK8C,MAAMpE,GAC3D,OAAO,MACFxC,EAAMO,SAASxC,cADpB,CAEEkC,IAAKG,IAAE4F,MAAM,GAAIjI,EAAe,CAC9BgK,sBAcAE,GAAsB,SAACjI,EAAcwC,GACzC,IAAMzE,EAAgBiC,EAAMO,SAASxC,cAAcmC,UAC7CyE,EAAWG,GAAc9E,GASzBkI,EALgB/D,OAAOC,OAAOrG,EAAcsG,MAAML,OAAO,SAAA9E,GAC7D,IAAM7B,EAAQ2J,GAAUhH,EAAOd,EAAa7B,OAC5C,OAAOsH,EAAS1B,SAAS5F,EAAM8H,QAAUR,EAAS1B,SAAS5F,EAAM+H,OAGjCiB,OAAO,SAACC,EAAKe,GAAN,aACpCf,EADoC,eAEtCe,EAAG9C,GAAK,IAAI5D,EAAO0G,EAAGvD,IAAIlD,EAAI4B,EAAS5B,EAAGyG,EAAGvD,IAAIjD,EAAI2B,EAAS3B,MAC7D,IAIEsH,EAAchE,OAAOC,OAAOrG,EAAcsG,MAAMgC,OAAO,SAACC,EAAK8B,GACjE,ILhOgBxH,EAAYC,EKgOtBxD,EAAQ2J,GAAUhH,EAAOoI,EAAE/K,OAC3BgL,EAAgB1D,EAAS1B,SAAS5F,EAAM8H,OACxCmD,EAAc3D,EAAS1B,SAAS5F,EAAM+H,KAC5C,GLnO4BvE,EKmOJyH,ILnOR1H,EKmOPyH,KLlOLxH,GAAQD,GAAKC,EKmOf,OAAOyF,EAGT,IAAMiC,EAAW5H,EAAOgG,KAAKrC,GAAStE,EAAOsI,EAAcjL,EAAM8H,MAAQ9H,EAAM+H,KAAKtB,KAC9E0E,EAAY7H,EAAOgG,KAAKrC,GAAStE,EAAOqI,EAAgBhL,EAAM8H,MAAQ9H,EAAM+H,KAAKtB,KACjF2E,EAAeD,EAAU5B,MAAMpE,GAC/BmF,EAAOY,EAAS3B,MAAM4B,GACtBE,EAAO/H,EAAOgG,KAAKyB,EAAEtE,KAAK8C,MAAM4B,GAChCG,EAAWD,EAAKE,QAAQjB,GACxBkB,EAAgBF,EAASzH,YAAcyG,EAAKzG,YAC5C0G,EAAOc,EAAK9B,MAAM+B,GAElBG,GADWlB,EAAKnG,IAAIkH,EAASf,QAAU,EAAI,GAAK,GACxBA,EAAK1G,YAEnC,OAAO,MACFoF,EADL,eAEG8B,EAAE7D,GAAK,CAAEgE,WAAUE,eAAcI,gBAAeC,iBAElD,IAIH,OAAO,MACF9I,EAAMO,SAASxC,cADpB,CAEEkC,IAAI,MACClC,EADF,CAEDmK,cACAC,mBAUAtE,GAAkB,SAAC7D,EAAcwC,GACrC,OAAIG,GAAwB3C,GAAe+I,GAAW/I,EAAOwC,GACpDE,GAAgB1C,GAAegJ,GAAahJ,EAAOwC,GAChDxC,EAAMO,SAASxC,eAOvBgL,GAAa,SAAC/I,EAAcwC,GAAyC,IACjEzE,EAAkBiC,EAAMO,SAAxBxC,cAER,IAAKA,EAAckC,MAAQlC,EAAckC,IAAI0E,WAAa5G,EAAckC,IAAI8H,eAC1E,OAAOhK,EAGT,IAAMmB,EAAenB,EAAckC,IAAIoE,KAAKtG,EAAckC,IAAI0E,UACxDmC,EAAatE,EAASnB,KAAKV,EAAOgG,KAAK5I,EAAckC,IAAI8H,iBAE/D,OAAO,MACFhK,EADL,CAEEkC,IAAKG,IAAE4F,MAAM,GAAIjI,EAAckC,IAAK,CAClCoE,KAAK,eACFnF,EAAaqF,GADZ,MACsBrF,EADtB,CACoC4E,IAAKgD,UAS7CkC,GAAe,SAAChJ,EAAcwC,GAAyC,IACnEzE,EAAkBiC,EAAMO,SAAxBxC,cAER,IAAKA,EAAckC,IACjB,OAAOlC,EAGT,IAAMkL,EAAY9E,OAAOoC,KAAKxI,EAAckC,IAAIiI,aAAa7B,OAAO,SAACC,EAAK/B,GACxE,IAAMrF,EAAenB,EAAckC,IAAKoE,KAAKE,GACvCuC,EAAatE,EAASnB,KAAKV,EAAOgG,KAAK5I,EAAckC,IAAKiI,YAAY3D,KAC5E,OAAO,MACF+B,EADL,eAEG/B,EAFH,MAEarF,EAFb,CAE2B4E,IAAKgD,OAE/B,IAEGoC,EAAY/E,OAAOoC,KAAKxI,EAAckC,IAAIkI,aAAa9B,OAAO,SAACC,EAAK/B,GACxE,IAAMrF,EAAenB,EAAckC,IAAKoE,KAAKE,GADkC,EAEjBxG,EAAckC,IAAKkI,YAAY5D,GAArFgE,EAFuE,EAEvEA,SAAUE,EAF6D,EAE7DA,aAAcI,EAF+C,EAE/CA,cAAeC,EAFgC,EAEhCA,WACzCK,EAAS3G,EAASnB,KAAKoH,GACvBd,EAAOY,EAAS3B,MAAMuC,GACtBC,EAAYzB,EAAKrG,MAAMuH,GAAexH,KAAK8H,GAG3CrC,EAAkC,IAArBa,EAAKzG,YACpByG,EAAKC,OAAOC,YAAYvG,MAAMwH,GAAYzH,KAAK+H,GAC/C,IAAIzI,EAAO,GAAI,IAAIU,KAAK+H,GAE5B,OAAO,MACF9C,EADL,eAEG/B,EAFH,MAEarF,EAFb,CAE2B4E,IAAKgD,OAE/B,IAEH,OAAO,MACF/I,EADL,CAEEkC,IAAKG,IAAE4F,MAAM,GAAIjI,EAAckC,IAAK,CAClCoE,KAAK,MACA4E,EADD,GAECC,QAQL3B,GAAsB,SAACvH,GAAD,aACvBA,EAAMO,SAASxC,cADQ,CAE1BkC,IAAK,KACLC,UAAU,MACLH,EAAcC,EAAMO,SAASxC,eADzB,CAEP4G,SAAU,KACVoD,eAAgB,KAChBG,YAAa,GACbC,YAAa,Q,ujBCtVV,IAAMkB,GAAyB,CACpCC,YAAY,EACZC,mBAAoB,KACpBC,YAAa,KACbC,eAAgB,EAChBC,eAAe,EACfC,YAAa,KACbC,WAAY,KACZC,YAAa,KACbC,aAAc,KACdC,oBAAqB,KACrBC,wBAAyB,KACzBC,gBAAiB,GAMNP,GAAgB,SAAC1J,GAAD,OAA2BA,EAAMkK,IAAIR,eAErDH,GAAqB,SAACvJ,GAAD,OAAmCA,EAAMkK,IAAIX,oBAElEC,GAAc,SAACxJ,GAC1B,OAAIA,EAAMkK,IAAIV,YACLxJ,EAAMkK,IAAIV,YHsCI,SAACxJ,GACxB,IAAMmF,EAAQpF,EAAcC,EAAMO,SAAS1C,OAAOmH,UAClD,GAAc,OAAVG,EACF,MAAM,IAAIhE,MAAM,yCAElB,OAAOgE,EGzCAH,CAAUhF,IAGNmK,GAAgB,SAACnK,EAAcuE,GAC1C,OAAIvE,EAAMkK,IAAIV,YACLxJ,EAAMkK,IAAIV,cAAgBjF,EAE5BQ,GAAY/E,EAAOuE,IAGfkF,GAAiB,SAACzJ,GAAD,OAA0BA,EAAMkK,IAAIT,gBAErDW,GAAgB,SAACpK,EAAcuE,GAAf,OAAuCvE,EAAMkK,IAAIP,cAAgBpF,GAEjF8F,GAAiB,SAACrK,EAAcuE,GAAf,OAAuCvE,EAAMkK,IAAIN,aAAerF,GAEjF+F,GAAkB,SAACtK,EAAcuE,GAAf,OAAuCvE,EAAMkK,IAAIL,cAAgBtF,GAEnFgG,GAAiB,SAACvK,EAAcuE,GAAf,OAAuCvE,EAAMkK,IAAIJ,eAAiBvF,GAEnFiG,GAAwB,SAACxK,EAAcuE,GAAf,OAAuCvE,EAAMkK,IAAIH,sBAAwBxF,GAEjGyF,GAA0B,SAAChK,GAAD,OAAiCA,EAAMkK,IAAIF,yBAErES,GAAc,SAACzK,GAAD,OACzBc,KAAK4J,MApCyB,IAoCA1K,EAAMkK,IAAID,kBAG7BU,GAAqB,SAAC3K,GAAD,OAA0BA,EAAMkK,IAAID,iBAEzDW,GAAa,SAAC5K,EAAcsC,GACvC,OAAQA,EAAOhF,MACb,KAAKuN,EACH,OAAOC,GAAQ9K,GACjB,KAAK6K,EACH,OAAOE,GAAQ/K,GACjB,IT4JqB,YS3JnB,OAAOxB,GAASwB,GAClB,IT+JoC,2BS9JlC,OAAOgL,GAAsBhL,EAAOsC,EAAO/E,QAAQ0N,SACrD,ITmK4B,mBSlK1B,OAAOxM,GAAeuB,EAAOsC,EAAO/E,QAAQmB,MAC9C,ITuKmC,0BStKjC,OAAOC,GAAqBqB,EAAOsC,EAAO/E,QAAQqB,WACpD,IToDqB,YSnDnB,OAAOpB,GAASwC,EAAOsC,EAAO/E,QAAQE,WACxC,ITyK4B,mBSxK1B,OAAOoB,GAAemB,EAAOsC,EAAO/E,QAAQmB,MAC9C,IT6K4B,mBS5K1B,OAAOI,GAAckB,EAAOsC,EAAO/E,QAAQmB,MAC7C,ITiL6B,oBShL3B,OAAOK,GAAeiB,EAAOsC,EAAO/E,QAAQmB,MAC9C,ITqL6B,oBSpL3B,OAAOM,GAAgBgB,EAAOsC,EAAO/E,QAAQF,OAC/C,ITyLqC,4BSxLnC,OAAO4B,GAAuBe,EAAOsC,EAAO/E,QAAQ2B,cACtD,IT6LyC,gCS5LvC,OAAOC,GAA2Ba,EAAOsC,EAAO/E,QAAQ6B,kBAC1D,QACE,OAAOY,EAAMkK,MAIbY,GAAU,SAAC9K,GAAD,aACXA,EAAMkK,IADK,CAEdZ,YAAY,EACZC,mBAAoBvJ,EAAMkK,IAAIZ,WAC1BtJ,EAAMkK,IAAIX,mBACV2B,GAAYlL,MAGZ+K,GAAU,SAAC/K,GAAD,aACXA,EAAMkK,IADK,CAEdZ,YAAY,EACZC,mBAAoBvJ,EAAMkK,IAAIZ,WAC1BtJ,EAAMkK,IAAIX,mBACV2B,GAAYlL,MAGZxB,GAAW,SAACwB,GAAD,aACZA,EAAMkK,IADM,CAEfZ,YAAY,EACZC,mBAAoB,KACpBC,YAAa,KACbC,eAAgB,EAChBC,eAAe,EACfC,YAAa,KACbC,WAAY,KACZC,YAAa,KACbC,aAAc,KACdC,oBAAqB,KACrBC,wBAAyB,QAGrBgB,GAAwB,SAAChL,EAAciL,GAAf,aACzBjL,EAAMkK,IADmB,CAE5BD,gBAAiBgB,KAGbxM,GAAiB,SAACuB,EAActB,GAAf,aAClBsB,EAAMkK,IADY,CAErBV,YAAa9K,KAGTC,GAAuB,SAACqB,EAAcpB,GAAf,aACxBoB,EAAMkK,IADkB,CAE3BR,cAAe9K,KAGXpB,GAAW,SAACwC,EAAcvC,GAAf,aACZuC,EAAMkK,IADM,CAEfT,eAAgBhM,IAAc0N,GAAeC,EACzCtK,KAAKuK,IAAI,EAAGrL,EAAMkK,IAAIT,eAAiB,GACvCzJ,EAAMkK,IAAIT,eAAiB,KAG3B5K,GAAiB,SAACmB,EAActB,GAAf,aAClBsB,EAAMkK,IADY,CAErBP,YAAajL,KAGTI,GAAgB,SAACkB,EAActB,GAAf,aACjBsB,EAAMkK,IADW,CAEpBN,WAAYlL,KAGRK,GAAiB,SAACiB,EAActB,GAAf,aAClBsB,EAAMkK,IADY,CAErBL,YAAanL,KAGTM,GAAkB,SAACgB,EAAc3C,GAAf,aACnB2C,EAAMkK,IADa,CAEtBJ,aAAczM,KAGV4B,GAAyB,SAACe,EAAcd,GAAf,aAC1Bc,EAAMkK,IADoB,CAE7BH,oBAAqB7K,KAGjBC,GAA6B,SAACa,EAAcZ,GAAf,aAC9BY,EAAMkK,IADwB,CAEjCF,wBAAyB5K,K,ujBCjLpB,IAGMkM,GAA2B,CACtCC,QAAS7J,EAAO,GAHgB,IAIhC8J,WAAY,EACZC,QAAS,MAIEN,GAAmD,CAC9DO,EAAG,IACHN,EAAG,KAKQF,GAAc,SAAClL,GAAD,OAA4BA,EAAMO,SAASoL,KAAKJ,SAE9DK,GAAkB,SAAC5L,GAAD,OAAiCA,EAAMO,SAASoL,KAAKF,SAEvEI,GAAoB,SAAC7L,GAChC,IAAM8L,EAAarC,GAAezJ,GAClC,OAAOA,EAAMO,SAASoL,KAAKJ,QAAQO,IAGxBC,GAAc,SAAC/L,EAAcsC,GACxC,OAAQA,EAAOhF,MACb,IV+E4B,mBU9E1B,OAAO0O,GAAehM,EAAOsC,EAAO/E,QAAQuG,IAAKxB,EAAO/E,QAAQkD,OAClE,IVwF8B,qBUvF5B,OAAOwL,GAAiBjM,EAAOsC,EAAO/E,QAAQiO,YAChD,IV4F2B,kBU3FzB,OAAOU,GAAclM,EAAOsC,EAAO/E,QAAQuG,KAC7C,IV+EsB,aU9EpB,OAAOqI,GAAUnM,GACnB,IVoG6B,oBUnG3B,OAAOtC,GAAgBsC,EAAOsC,EAAO/E,QAAQI,QAC/C,IV4LqB,YU3LnB,OAAOa,GAASwB,GAClB,QACE,OAAOA,EAAMO,SAASoL,OAItBK,GAAiB,SAAChM,EAAc8D,EAAarD,GAA5B,aAClBT,EAAMO,SAASoL,KADG,CAErBJ,QAASnL,IAAEgM,OAAOhM,IAAEiM,MAAMrM,EAAMO,SAASoL,KAAKJ,SAAUzH,EAAK,SAAA1D,GAAC,OAAIK,IAClEgL,QAAShL,EAAM6L,OAAS,GAAqC,OAAhCtM,EAAMO,SAASoL,KAAKF,QAC7CzL,EAAMO,SAASoL,KAAKF,QAAU,EAC9BzL,EAAMO,SAASoL,KAAKF,WAGpBS,GAAgB,SAAClM,EAAc8D,GAAf,aACjB9D,EAAMO,SAASoL,KADE,CAEpBF,QAAS3H,KAGLqI,GAAY,SAACnM,GAAD,OAA6BsL,IAEzCW,GAAmB,SAACjM,EAAcwL,GAAf,aACpBxL,EAAMO,SAASoL,KADK,CAEvBJ,QAASgB,GAAavM,EAAMO,SAASoL,KAAKJ,QAASC,GACnDA,gBAGIe,GAAe,SAAChB,EAAmBiB,GACvC,IACMC,EAAWlB,EAAQe,OAASxL,KAAK4J,MAAM8B,EApErB,IAuExB,OAAIC,EAJe,GAKX,GAAN,mBAAWlB,GAAX,YAAuB7J,EAAO,GALb,MAUV+K,EAAW,IAAkBlB,EAAQmB,OAV3B,IAU8CC,MAAM,SAAAC,GAAG,OAAmB,IAAfA,EAAIN,SACzEf,EAAQmB,MAAM,GAXJ,IAaZnB,GAGH7N,GAAkB,SAACsC,EAAcrC,GAA+B,IAC5DgO,EAAS3L,EAAMO,SAAfoL,KACFkB,EAASpD,GAAezJ,GAC9B,OAAO,MACF2L,EADL,CAEEJ,QAASnL,IAAE0M,IAAI1M,IAAEiM,MAAMV,EAAKJ,SAAUsB,EAAQlP,MAI5Ca,GAAW,SAACwB,GAChB,IAAM+M,EAAiBxD,GAAmBvJ,GAC1C,OAAO,MACFA,EAAMO,SAASoL,KADpB,CAEEJ,QAASwB,GAAkB/M,EAAMO,SAASoL,KAAKJ,W,ujBChF5C,IAMMyB,GAAuB,SAAChN,GAAD,OAClCmE,OAAOC,OAAOpE,EAAMO,SAASvC,kBAAkBqG,OAKpC4I,GAA8B,SAACjN,GAAD,OACzCI,IAAE8M,QAAQF,GAAqBhN,GAAQ,SAAAmN,GAAM,OAAIA,EAAO9P,SAI7C+P,GAA4B,SAACpN,EAAc3C,GAAf,OACvC4P,GAA4BjN,GAAO3C,IASxBgQ,GAA6B,SAACrN,GACzC,IAEMsN,EAFUnJ,OAAOC,OAPe,SAACpE,GAAD,OACtCI,IAAE8M,QAAQF,GAAqBhN,GAAQ,SAAAmN,GAAM,OAAInG,GAAUhH,EAAOmN,EAAO9P,OAAO8H,QAMlDoI,CAAyBvN,IAC7BiG,IAAI,SAAAuH,GAAE,OAAIrJ,OAAOC,OAAOhE,IAAE8M,QAAQM,EAAI,SAAAL,GAAM,OAAIA,EAAOM,UACpDxH,IAAI,SAAAuH,GAAE,OAAIA,EAAGxJ,OAAO,SAAA0J,GAAK,OAAIA,EAAMpB,OAAS,MAEzE,OADkBlM,IAAEuN,YAAYL,GACfrH,IAAI,SAAAkH,GAAM,OAAIA,EAAO5I,MAI3BqJ,GAAgB,SAAC5N,GAAD,OAAiCA,EAAMO,SAASvC,kBAAkByN,SAElFoC,GAA2B,SAAC7N,EAAcsC,GACrD,IAAIF,EAAapC,GAuBf,OAAOA,EAAMO,SAASvC,kBAtBtB,OAAQsE,EAAOhF,MACb,IXmB+B,wBWlB7B,OAAOF,GAAoB4C,EAAOsC,EAAO/E,QAAQF,OACnD,IXRmB,YWSjB,OAAO6H,GAASlF,EAAOsC,EAAO/E,QAAQgH,IACxC,IXSkC,2BWRhC,OAAOuJ,GAAuB9N,EAAOsC,EAAO/E,QAAQ4P,QACtD,IXmBkC,2BWlBhC,OAAOY,GAAuB/N,EAAOsC,EAAO/E,QAAQgH,IACtD,IXiHyB,kBWhHvB,OAAO3G,GAAeoC,EAAOsC,EAAO/E,QAAQS,mBAC9C,IXqBiC,0BWpB/B,OAAOgQ,GAAsBhO,EAAOsC,EAAO/E,QAAQgH,IACrD,IXyBgC,yBWxB9B,OAAO0J,GAAqBjO,GAC9B,IX6BoC,6BW5BlC,OAAOkO,GAAyBlO,EAAOsC,EAAO/E,QAAQuI,KACxD,QACE,OAAO9F,EAAMO,SAASvC,oBAQxBZ,GAAsB,SAAC4C,EAAc3C,GACzC,IAAMkH,EAAKiB,MACL2H,EAAS,CAAE5I,KAAIlH,QAAOoQ,KAAM,GAAIU,MAAO,GAAIC,KAAMjD,GAAeO,EAAG2C,WAAW,GACpF,OAAOjO,IAAE4F,MAAM,GAAIhG,EAAMO,SAASvC,kBAAmB,CACnDqG,KAAK,eACFE,EAAK4I,GAER1B,QAASlH,KAKPW,GAAW,SAAClF,EAAc3C,GAAf,OACfD,GAAoB4C,EAAO3C,IAGvByQ,GAAyB,SAAC9N,EAAcmN,GAAf,OAC7B/M,IAAE4F,MAAM,GAAIhG,EAAMO,SAASvC,kBAAmB,CAC5CqG,KAAK,eACF8I,EAAO5I,GAAK4I,MAKbY,GAAyB,SAAC/N,EAAcuE,GAAuC,IAC3EvG,EAAsBgC,EAAMO,SAA5BvC,kBACR,OAAO,MACFA,EADL,CAEEqG,KAAMjE,IAAE2F,KAAK/H,EAAkBqG,KAAME,MAInC3G,GAAiB,SAACoC,EAAc8F,GAAf,aAClB9F,EAAMO,SAASvC,kBADG,CAErBqG,KAAMjE,IAAE2F,KAAK/F,EAAMO,SAASvC,kBAAkBqG,KAAMyB,MAGhDkI,GAAwB,SAAChO,EAAcuE,GAAf,aACzBvE,EAAMO,SAASvC,kBADU,CAE5ByN,QAASlH,KAGL0J,GAAuB,SAACjO,GAAD,aACxBA,EAAMO,SAASvC,kBADS,CAE3ByN,QAAS,QAGLyC,GAA2B,SAAClO,EAAc8F,GAAf,aAC5B9F,EAAMO,SAASvC,kBADa,CAE/BqG,KAAMjE,IAAEI,UAAUR,EAAMO,SAASvC,kBAAkBqG,KAAM,SAAA8I,GAAM,aAC1DA,EAD0D,CAE7DmB,YAAaxI,EAAI7C,SAASkK,EAAO5I,W,gkBCjI9B,IAKMgK,GAAkB,SAACvO,EAAcsC,GAC5C,IAAIF,EAAapC,GA6Bf,OAAOA,EAAMwO,SA5Bb,OAAQlM,EAAOhF,MACb,IZLuB,gBYMrB,OAAOgG,GAAYtD,GACrB,IZkDgC,yBYjD9B,OAAOwD,GAAoBxD,GAC7B,IZKkB,WYJhB,OAAOyO,GAAUzO,EAAO,YAC1B,IZckC,2BYbhC,OAAOyO,GAAUzO,EAAO,wBAC1B,IZiBqC,8BYhBnC,OAAOyO,GAAUzO,EAAO,6CAC1B,IZ6BmB,YY3BnB,IZoD+B,wBYnD7B,OAAOyO,GAAUzO,EAAO,sBAC1B,IZwJyB,kBYvJvB,OAAOyO,GAAUzO,EAAO,mBAC1B,IZ0CkC,2BYzChC,OAAOyO,GAAUzO,EAAO,qBAC1B,IZ6E0B,mBY5ExB,OAAOyO,GAAUzO,EAAO,oBAC1B,IZiFoB,aYhFlB,OAAOyO,GAAUzO,EAAO,cAC1B,QACE,OAAOA,EAAMwO,WAYflL,GAAc,SAACtD,GACnB,OAAI8C,GAAgB9C,GAAeyO,GAAUzO,EAAO,aACxCA,EAAMwO,UAGdhL,GAAsB,SAACxD,GAC3B,OAAI8C,GAAgB9C,GAAeyO,GAAUzO,EAAO,sBACxCA,EAAMwO,UAGPE,GAAO,SAAC1O,GACnB,GAAsC,IAAlCA,EAAMwO,SAASG,QAAQrC,OAAc,OAAOtM,EADL,mBAEjBA,EAAMwO,SAASG,SAAlCC,EAFoC,KAEzBC,EAFyB,WAKrCC,EAAU,MAAQF,EAAR,CAAgBnO,MADdN,EAAYH,KAG9B,OAAO,MADSM,EAAiBN,EAAO4O,EAAOnO,OAC/C,CAEE+N,SAAS,MACJxO,EAAMwO,SADH,CAENG,QAASE,EACTE,SAAS,CAAED,GAAH,mBAAkB9O,EAAMwO,SAASO,gBAKlCC,GAAO,SAAChP,GACnB,GAAuC,IAAnCA,EAAMwO,SAASO,SAASzC,OAAc,OAAOtM,EADN,mBAEjBA,EAAMwO,SAASO,UAAlCH,EAFoC,KAEzBC,EAFyB,WAKrCI,EAAU,MAAQL,EAAR,CAAgBnO,MADdN,EAAYH,KAG9B,OAAO,MADSM,EAAiBN,EAAO4O,EAAOnO,OAC/C,CAEE+N,SAAS,MACJxO,EAAMwO,SADH,CAENG,QAAQ,CAAEM,GAAH,mBAAkBjP,EAAMwO,SAASG,UACxCI,SAAUF,OAOHJ,GAAY,SAACzO,EAAckP,GAEtC,MAAO,CAILP,QAAQ,CALK,CAAEO,cAAazO,MAAON,EAAYH,KAKxC,mBAAcA,EAAMwO,SAASG,QAAQjC,MAAM,EARpC,MAUdqC,SAAU,K,ujBCxGP,IAMMI,GAAc,SAACnP,GAAD,OAA2BA,EAAMoP,QAAQC,MAEvDC,GAAe,SAACtP,GAAD,OAAiCA,EAAMoP,QAAQlR,OAE9DqR,GAAiB,SAACvP,GAAD,OAA+CA,EAAMoP,QAAQjR,SAE9EqR,GAAiB,SAACxP,EAAcsC,GAC3C,OAAQA,EAAOhF,MACb,IbuL2B,kBatLzB,OAAOW,GAAe+B,EAAOsC,EAAO/E,QAAQW,MAAOoE,EAAO/E,QAAQY,SACpE,Ib2L2B,kBa1LzB,OAAOsR,GAAezP,GACxB,QACE,OAAOA,EAAMoP,UAIbnR,GAAiB,SAAC+B,EAAc9B,EAAeC,GAA9B,aAClB6B,EAAMoP,QADY,CAErBC,MAAM,EACNnR,QACAC,aAAqB0H,IAAZ1H,EAAwBA,EAAU,QAGvCsR,GAAiB,SAACzP,GAAD,aAClBA,EAAMoP,QADY,CAErBC,MAAM,EACNnR,MAAO,KACPC,QAAS,Q,6NCpCJ,IAIMuR,GAAc,SAAC1P,GAAD,OAA0BA,EAAMO,SAASoP,SAASC,MAEhEC,GAAkB,SAAC7P,EAAcsC,GAC5C,OAAQA,EAAOhF,MACb,Id4S+B,sBc3S7B,OAAOwS,GAAkB9P,EAAOsC,EAAO/E,QAAQqS,MACjD,QACG,OAAO5P,EAAMO,SAASoP,WAIvBG,GAAoB,SAAC9P,EAAc4P,GAAf,O,uVAAA,IACrB5P,EAAMO,SAASoP,SADM,CAExBC,UCOWG,GAAmB,CAC9BxP,SAAU,CACR1C,MTDoC,CACtCoC,IAAK,KACLC,UAAW,CACTmE,KAAM,GACNM,SAAU,GACV8B,QAAS,GACTzB,UAAW,OSJXlH,ORbsC,CACxCuG,KAAM,IQaJtG,cPsBoD,CACtDkC,IAAK,KACLC,UAAW,CACTmE,KAAM,GACNM,SAAU,KACVoD,eAAgB,KAChBG,YAAa,GACbC,YAAa,KO5BbnK,kBJR4D,CAC9DqG,KAAM,GACNoH,QAAS,MIOPE,KAAML,GACNqE,SD/B4C,CAC9CC,KAAM,aCgCN7M,GAAIR,GACJiM,SHzB8C,CAC9CG,QAAS,GACTI,SAAU,IGwBVK,QFjC4C,CAC5CC,MAAM,EACNnR,MAAO,KACPC,QAAS,ME+BTuB,KAAMyC,EACN+H,IAAKb,I,ujBC7BP,IAiCMzJ,GAAkB,SAACI,EAAcH,EAAeC,GAA9B,aACnBQ,EAAiBN,EAAOH,GADL,CAEtB2O,SAAU1O,EACN2O,GAAUzO,EAAO,2BACjBA,EAAMwO,SACVtE,IAAKb,MAGD2G,GAAa,SAAChQ,GAClB,IAAMiQ,EAAgB9P,EAAY4P,IAClC,OAAO,MACFzP,EAAiBN,EAAOiQ,GAD7B,CAEEzB,SAAUC,GAAUzO,EAAO,sBAC3BkK,IAAKb,MAIM6G,GAlDC,WAAoD,IAAnDlQ,EAAkD,uDAArC+P,GAAWzN,EAA0B,uCACjE,OAAQA,EAAOhF,MACb,IhBmLgB,OgBlLd,OAAOoR,GAAK1O,GACd,IhBsLgB,OgBrLd,OAAOgP,GAAKhP,GACd,IhB4T4B,mBgB3T1B,OAAOJ,GAAgBI,EAAOsC,EAAO/E,QAAQsC,SAAUyC,EAAO/E,QAAQuC,UACxE,IhB2SuB,cgB1SrB,OAAOkQ,GAAWhQ,GACpB,QACE,OAAO,MACFA,EADL,CAEEO,SAAS,MACJP,EAAMO,SADH,CAEN1C,MAAOoH,GAAajF,EAAOsC,GAC3BxE,OAAQmJ,GAAcjH,EAAOsC,GAC7BvE,cAAeuJ,GAAqBtH,EAAOsC,GAC3CtE,kBAAmB6P,GAAyB7N,EAAOsC,GACnDqJ,KAAMI,GAAY/L,EAAOsC,GACzBqN,SAAUE,GAAgB7P,EAAOsC,KAEnCS,GAAIG,GAAUlD,EAAOsC,GACrBkM,SAAUD,GAAgBvO,EAAOsC,GACjC8M,QAASI,GAAexP,EAAOsC,GAC/B5C,KAAM2C,GAAYrC,EAAOsC,GACzB4H,IAAKU,GAAW5K,EAAOsC,OCjCzB6N,GAA6C,CACjD,EAAK,SAACC,EAAIC,GACR,GAAIA,EAAEC,SAAWlO,EAAagO,GAC5B,MjB4CuC,CAC3C9S,KAF8B,qBiBxC9B,EAAK,SAAC8S,EAAIC,GACR,GAAIA,EAAEC,SAAWlO,EAAagO,GAC5B,MjBwB4C,CAChD9S,KAFmC,0BiBpBnC,IAAK,SAAC8S,EAAIC,GACR,GAAIA,EAAEC,SAAWlO,EAAagO,GAE5B,OADAC,EAAEE,iBjBQsC,CAC5CjT,KAF+B,sBiBH/B,EAAK,SAAC8S,EAAIC,GAER,GADyBvL,GAAcsL,GAAI9D,OAAS,GAC5B+D,EAAEC,SAAWlO,EAAagO,GAEhD,OADAC,EAAEE,iBjB8JmD,CACzDjT,KAF6C,oCiBzJ7C,EAAK,SAAC8S,EAAIC,GACR,GAAIvL,GAAcsL,GAAI9D,OAAS,GAAK+D,EAAEC,SAAWlO,EAAagO,GAC5D,MjBgBiD,CACrD9S,KAFyC,gCiBZzC,EAAK,SAAC8S,EAAIC,GACR,GAAiC,IAA7BvL,GAAcsL,GAAI9D,QAAgB+D,EAAEC,SAAWlO,EAAagO,GAC9D,MjBM8C,CAClD9S,KAFsC,6BiBFtC,EAAK,SAAC8S,EAAIC,GACR,IAAKA,EAAEC,SAAWD,EAAEG,UAAYpO,EAAagO,GAC3C,MjByJ6B,CACjC9S,KAFkB,SiBrJlB,EAAK,SAAC8S,EAAIC,GACR,IAAKA,EAAEC,SAAWD,EAAEG,UAAYpO,EAAagO,GAE3C,OADAC,EAAEE,iBjByJ2B,CACjCjT,KAFkB,SiBpJlB,EAAK,SAAC8C,EAAGiQ,GACP,GAAIA,EAAEC,SAAWD,EAAEG,QAEjB,OADAH,EAAEE,iBACK1F,M,0BChCE4F,I,0LAfX,OACE,yBAAKC,UAAU,gBACb,yBAAKA,UAAU,yBACb,0BAAMA,UAAU,uBAAhB,uBACA,0BAAMA,UAAU,yBAAyB1P,KAAK2P,MAAMC,aAEtD,yBAAKF,UAAU,yBACb,0BAAMA,UAAU,uBAAhB,wBACA,0BAAMA,UAAU,yBAAyB1P,KAAK2P,MAAME,gB,GAVpCC,IAAMC,Y,wCCE1BC,GACJ,4BACE,iEAGA,yBAAKC,IAAKC,KAAOC,IAAI,qBACrB,yHAGA,yBAAKF,IAAKG,KAAOD,IAAI,gEAKvB,qBAAC,GAAD,CAAaP,WAlBC,iJAkBoBC,SAAUG,K,wCCdxCA,GACJ,6BACE,qFAGA,yBAAKC,IAAKI,KAASF,IAAI,kCACvB,+IAIA,yBAAKF,IAAKK,KAASH,IAAI,iCAKzB,qBAAC,GAAD,CAAaP,WAnBC,gJAmBoBC,SAAUG,KC0B/BO,I,0LAxCH,IACUC,EAAexQ,KAAK2P,MAA9Bc,SACR,OACE,yBAAKf,UAAU,eACb,yBAAKA,UAAU,sBAAf,sBAEE,0BAAMA,UAAS,mDAA8Cc,EAAa,WAAa,aACpFA,EAAa,WAAa,YAH/B,uBAME,0BAAMd,UAAU,8BACb1P,KAAK0Q,kBAAkB1Q,KAAK2P,MAAMgB,kBAPvC,qBAUE,0BAAMjB,UAAU,8BACb1P,KAAK0Q,kBAAkB1Q,KAAK2P,MAAMiB,mBAXvC,mB,wCAmBoBrG,GACxB,IAAMsG,EAAWzR,IAAE0R,QAAQ1R,IAAEiM,MAAMd,IAE7BwG,EADU3R,IAAE0R,QAAQ1R,IAAE4R,UAAUH,EAAU,SAAAjR,GAAC,OAAiB,IAAbA,EAAE0L,UACrBrG,IAAI,SAAArF,GAAC,OAAiB,IAAbA,EAAE0L,OAAe,SAAM1L,IAC5DqR,EAAW,sBAAOF,GAAP,CAA0B,SAAK,SAAK,WACrD,OACE,oCACGE,EAAYhM,IAAI,SAACiM,EAAGnQ,GAAJ,OACf,0BAAMrB,IAAKqB,EAAG2O,UAAS,uBAAwB,WAANwB,EAAY,QAAU,GAAxC,eACpBA,U,GAjCYpB,IAAMC,YCPhB,YAACY,EAA2BC,GAA5B,OACb,kBAAC,GAAD,CAAYH,UAAU,EACVE,gBAAiBA,EACjBC,iBAAkBA,KCHjB,YAACD,EAA2BC,GAA5B,OACb,kBAAC,GAAD,CAAYH,UAAU,EACVE,gBAAiBA,EACjBC,iBAAkBA,K,kDCHPO,IAAV,SAAUA,KAAV,uEACPC,EAAe,IADR,OAGX,OAHW,SAGLC,aAAMD,GAHD,OAIX,OAJW,SAILE,aAAIzH,KAJC,6D,iBCUL0H,I,aAaAxH,I,aAeAyH,I,aAkEAC,I,aAgCAC,I,aA8BAC,I,aAOAC,I,aAOAC,I,aAOe3I,IAjLzB,SAAUqI,GAAKO,GAAf,2EACwB,OADxB,SAC8BC,aAAKC,KADnC,OAEmB,OADXC,EADR,gBAEyBC,aAAKnI,GAAS+H,EAAYG,GAFnD,OAGqB,OADbE,EAFR,gBAG2BC,aAAK,CAACvI,EAAaA,EAAqBA,EAAeA,IAHlF,OAIE,OADMwI,EAHR,iBAIQC,aAAOH,GAJf,WAKME,EAAW/V,OAASuN,EAL1B,iBAQI,OARJ,UAQUuI,aAAKH,GARf,QASI,OATJ,UASUX,aAAIzH,KATd,wCAaA,SAAUE,GAAQ+H,EAAqBG,GAAvC,iEAEI,OAFJ,kBAEUX,aAAIzH,EAAa7I,EAAME,MAFjC,WAGQ4Q,EAHR,gBAIM,OAJN,SAIYC,aAAKP,GAAUS,GAJ3B,8BAOQ,OAPR,UAOcF,aAAKP,GAAUS,GAP7B,+BAWI,OAXJ,oBAWUX,aAAIzH,EAAa7I,EAAMC,OAXjC,sFAeA,SAAUuQ,GAASS,GAAnB,yFACkB,OADlB,SACwBM,aAAO/J,IAD/B,OAEkB,OADVgK,EADR,gBAEwBD,aAAO1H,IAF/B,OAOyB,OALjB4H,EAFR,gBAO+BF,aAAOG,GAAyBF,EAASC,GAPxE,UAOQE,EAPR,wBASoB,OATpB,UAS0BJ,aAAO,SAAAvT,GAAK,OAAI4E,GAAY5E,EAAOwT,KAT7D,oCAWM,OAXN,UAWYlB,aAAIzH,KAXhB,gCAaM,OAbN,UAaYyH,aAAIzH,KAbhB,0CAsBmB,OAHfnE,EACEiN,EADFjN,OAAQkN,EACND,EADMC,eAAgBxM,EACtBuM,EADsBvM,QAASyM,EAC/BF,EAD+BE,mBAAoBC,EACnDH,EADmDG,YAAaC,EAChEJ,EADgEI,cAnBtE,UAsByBR,aAAO9I,IAtBhC,QAwBE,OAFMuJ,EAtBR,iBAwBQd,aAAKT,GAAUuB,EAAUR,EAAS9M,GAxB1C,QAyBE,OAzBF,UAyBQwM,aAAKR,GAAUsB,EAAUF,EAAaC,EAAed,GAzB7D,QA0BE,OA1BF,UA0BQC,aAAKP,GAAWqB,EAAU5M,GA1BlC,QA2BE,OA3BF,UA2BQ8L,aAAKN,GAAsBoB,EAAUH,GA3B7C,QA4BE,OA5BF,UA4BQX,aAAKL,GAAkBmB,EAAUJ,GA5BzC,wCA+BA,IAAMF,GAA0B,SAAC1T,EAAcwJ,EAAqBiK,GAClE,IAAMQ,ElBnBsB,SAACjU,EAAc0G,GAAf,OAC5BK,GAAU/G,GAAOgE,OAAO,SAAA3G,GAAK,OAAIA,EAAM8H,QAAUuB,IkBkB1BwN,CAAelU,EAAOwJ,GAEvC2D,EADU/M,IAAE+T,QAAQF,EAAehO,IAAI,SAAA5I,GAAK,OAAI+P,GAA0BpN,EAAO3C,EAAMkH,OACtEC,KAAK,SAAA2I,GAAM,OAAIA,EAAOM,OAASgG,IAEtD,IAAKtG,EACH,OAAO,KAGT,IAAM9P,EAAQ4W,EAAezP,KAAK,SAAAnH,GAAK,OAAIA,EAAMkH,KAAO4I,EAAO9P,QAC/D,IAAKA,EACH,MAAM,IAAI8D,MAAJ,kFAAqFgM,EAAO9P,MAA5F,MAGR,IAAM6B,EAAeiI,GAAqBnH,EAAO3C,EAAMkH,IAEvD,MAAO,CACLmC,OAAQrJ,EAAM+H,IACdgC,QAAS/J,EAAMkH,GACfqP,eAAgB1U,EAAaqF,GAC7BsP,mBAAoB1G,EAAO5I,GAC3BuP,YAAa3G,EAAOgB,MACpB4F,cAAe5G,EAAOiB,OAa1B,SAAUqE,GAASuB,EAAkBR,EAAiBY,GAAtD,uEAOI,OAHEC,GAAoB,EAJ1B,kBAOU/B,aAAIzH,EAAiB2I,IAP/B,OAQI,OARJ,SAQUnB,aAAM2B,EAAW,GAR3B,OAWI,OAXJ,SAWU1B,aAAIzH,EAAiB2I,IAX/B,OAYI,OAZJ,UAYUlB,aAAIzH,EAAiB,OAZ/B,QAaI,OAbJ,UAaUwH,aAAM2B,EAAW,GAb3B,QAcI,OAdJ,UAcU1B,aAAIzH,EAAiB,OAd/B,QAeI,OAfJ,UAeUwH,aAAM2B,EAAW,GAf3B,QAkBI,OAlBJ,UAkBU1B,aAAIzH,EAAiBuJ,IAlB/B,QAoBI,OADAC,GAAoB,EAnBxB,UAoBU/B,aAAIzH,EAAgBuJ,IApB9B,QAqBI,OArBJ,UAqBU/B,aAAM2B,EAAW,GArB3B,QAsBI,OAtBJ,UAsBU1B,aAAIzH,EAAgB,OAtB9B,QAuBI,OAvBJ,UAuBUyH,aAAIzH,EAAiBuJ,IAvB/B,QAwBI,OAxBJ,UAwBU/B,aAAM2B,EAAW,GAxB3B,QA0BQ,OA1BR,oBA0BcM,eA1Bd,uCA2BWD,EA3BX,iBA2B8B,OA3B9B,UA2BoC/B,aAAIzH,EAAiBuJ,IA3BzD,sFAgCA,SAAU1B,GAASsB,EAAkBF,EAAqBrW,EAA0BwV,GAApF,yEAMI,OAHEsB,GAAmB,EACnBC,GAAe,EAJrB,kBAMUnC,aAAM2B,EAAW,GAN3B,OASI,OATJ,SASU1B,aAAIzH,GAAuB,IATrC,OAUI,OAVJ,SAUUwH,aAAM2B,EAAW,GAV3B,OAaI,OAbJ,UAaU1B,aAAIzH,EAAkBiJ,IAbhC,QAeI,OADAS,GAAmB,EAdvB,UAeUlC,aAAM2B,EAAW,GAf3B,QAgBI,OAhBJ,UAgBU1B,aAAIzH,GAAuB,IAhBrC,QAmBI,OAnBJ,UAmBUyH,aAAIzH,EAAWpN,IAnBzB,QAoBI+W,GAAe,EApBnB,QAsBQ,OAtBR,oBAsBcF,eAtBd,uCAuBWC,EAvBX,iBAuB6B,OAvB7B,UAuBmCjC,aAAIzH,EAAkBiJ,IAvBzD,WAwBWU,EAxBX,iBAwByB,OAxBzB,UAwB+BlC,aAAIzH,EAAWpN,IAxB9C,QAyBM,OAzBN,UAyBY6U,aAAIW,GAAe,GAzB/B,sFA8BA,SAAUN,GAAUqB,EAAkB5M,GAAtC,iEACE,OADF,SACQiL,aAAM2B,EAAW,GADzB,OAEE,OAFF,SAEQ1B,aAAIzH,EAAkBzD,IAF9B,OAGE,OAHF,SAGQiL,aAAM,EAAI2B,EAAW,GAH7B,OAIE,OAJF,SAIQ1B,aAAIzH,EAAkB,OAJ9B,uCAOA,SAAU+H,GAAqBoB,EAAkBH,GAAjD,iEACE,OADF,SACQxB,aAAM2B,EAAW,GADzB,OAEE,OAFF,SAEQ1B,aAAIzH,EAA6BgJ,IAFzC,OAGE,OAHF,SAGQxB,aAAM2B,EAAW,GAHzB,OAIE,OAJF,SAIQ1B,aAAIzH,EAA6B,OAJzC,uCAOA,SAAUgI,GAAiBmB,EAAkBJ,GAA7C,iEACE,OADF,SACQvB,aAAM2B,EAAW,GADzB,OAEE,OAFF,SAEQ1B,aAAIzH,EAAyB+I,IAFrC,OAGE,OAHF,SAGQvB,aAAM2B,EAAW,GAHzB,OAIE,OAJF,SAIQ1B,aAAIzH,EAAyB,OAJrC,uCAOe,SAAUX,KAAV,iEACb,OADa,SACPuK,aAAU5J,EAAY0H,IAAM,GADrB,OAEb,OAFa,SAEPkC,aAAU5J,EAAY0H,IAAM,GAFrB,uC,iBC1LUmC,IAAV,SAAUA,KAAV,iEACb,OADa,SACPC,aAAI,CACRxC,KACAjI,OAHW,uCCGf,IAAM0K,GAAiBC,cAEjBC,GAAQC,sBACZ7E,GACA8E,8BAAoBC,0BVqDuB,SAAAC,GAAG,OAAI,SAAAd,GAAI,OAAI,SAAA9R,GAC1D,GjB4GsB,aiB5GlBA,EAAOhF,KAAqB,OAAO8W,EAAK9R,GAE5C,IAAMtC,EAAQkV,EAAIC,WAHkD,EAI7C7S,EAAO/E,QAAtBmD,EAJ4D,EAI5DA,IAAK0U,EAJuD,EAIvDA,MAEPC,EAAalF,GAAYzP,GAC/B,IAAK2U,EAAY,OAAOjB,EAAK9R,GAE7B,IAAMgT,EAAYD,EAAWrV,EAAOoV,GACpC,OAAKE,GAELlB,EAAK9R,GACE8R,EAAKkB,IAHWlB,EAAK9R,MWhEW,SAAA4S,GAAG,OAAI,SAAAd,GAAI,OAAI,SAAA9R,GACtD,G5B+K6C,oC4B/KzCA,EAAOhF,KAA4C,OAAO8W,EAAK9R,GAEnE,IAAMtC,EAAQkV,EAAIC,WACZtX,EAAQiH,GAAc9E,GACtBmF,EAAQtH,EAAM,GACduH,EAAMvH,EAAM,IAAMA,EAAM,GACxB0X,ErB+ByB,SAACvV,EAAcwV,EAAiBC,GAE/D,OADc1O,GAAU/G,GAAOwE,KAAK,SAAAkR,GAAC,OAAIA,EAAEvQ,QAAUqQ,GAAWE,EAAEtQ,MAAQqQ,KAC1D,KqBjCME,CAAkB3V,EAAOmF,EAAOC,GAEtD,GAAImQ,EACF,OAAOnB,EAAKvJ,EAAsB0K,EAAchR,KAEhD,IAAM6C,EAAU5B,MAChB,OAAO4O,E5B0Ca,SAACjP,EAAeC,EAAab,GAA7B,MAAqD,CAC3EjH,KAFuB,YAGvBC,QAAS,CAAE4H,QAAOC,MAAKb,O4B5CTsG,CAAW1F,EAAOC,EAAKgC,OCfW,SAAA8N,GAAG,OAAI,SAAAd,GAAI,OAAI,SAAA9R,GAC/D,G7BsFsC,6B6BtFlCA,EAAOhF,KAAqC,OAAO8W,EAAK9R,GADa,MAGnDA,EAAO/E,QAArBgH,EAHiE,EAGjEA,GAAIlH,EAH6D,EAG7DA,MACN2C,EAAQkV,EAAIC,WAGlB,GAFyB/H,GAA0BpN,EAAO3C,GAAO2G,OAAO,SAAAmJ,GAAM,OAAIA,EAAO5I,KAAOA,IAE3E+H,OAAS,EAAG,OAAO8H,EAAK9R,GAE7C,IAAMsR,EAAiBzM,GAAqBnH,EAAO3C,GAAOkH,GAC1D,OAAO6P,EAAKvJ,EAAiB,GAAI,CAACxN,GAAQ,CAACuW,GAAiB,CAACrP,QCRzB,SAAA2Q,GAAG,OAAI,SAAAd,GAAI,OAAI,SAAA9R,GACnD,G9B6BmC,0B8B7B/BA,EAAOhF,KAAkC,OAAO8W,EAAK9R,GAEzD,IAAMtC,EAAQkV,EAAIC,WACZS,EAAU9Q,GAAc9E,GACxBlC,EAASsC,IAAE+T,QAAQyB,EAAQ3P,IAAI,SAAA1B,GAAE,OvB2BZ,SAACvE,EAAc0G,GAAf,OAC3BK,GAAU/G,GAAOgE,OAAO,SAAA3G,GAAK,OAAIA,EAAM8H,QAAUuB,GAAUrJ,EAAM+H,MAAQsB,IuB5B9BmP,CAAc7V,EAAOuE,MAC1DuR,EAAW1V,IAAE2D,KAAK3D,IAAE+T,QAAQrW,EAAOmI,IAAI,qBAAG1B,OAC1CwR,EAAkBD,EAAS7P,IAAI,SAAA1B,GAAE,OAAI4C,GAAqBnH,EAAOuE,KAAK0B,IAAI,qBAAG1B,KAE7EyR,EADoB5V,IAAE+T,QAAQ2B,EAAS7P,IAAI,SAAA1B,GAAE,OAAI6I,GAA0BpN,EAAOuE,MAC1C0B,IAAI,qBAAG1B,KAErD,OAAO6P,EAAKvJ,EAAiB+K,EAASE,EAAUC,EAAiBC,OCdd,SAAAd,GAAG,OAAI,SAAAd,GAAI,OAAI,SAAA9R,GAQlE,IAPmB,C/BiFgB,wBANG,2BAYA,2BAgGT,kBA/HN,a+BjDPW,SAASX,EAAOhF,MAAO,OAAO8W,EAAK9R,GAEnD8R,EAAK9R,GACL,IAAMgL,EAAaD,GAA2B6H,EAAIC,YAClD,OAAOf,E/B+F2D,CAClE9W,KAFwC,6BAGxCC,QAAS,CAAEuI,I+BjG4BwH,QCZC,SAAA4H,GAAG,OAAI,SAAAd,GAAI,OAAI,SAAA9R,GACvD,IAAK,CAACuI,EAAYA,GAAY5H,SAASX,EAAOhF,MAAO,OAAO8W,EAAK9R,GAEjE,IAAMtC,EAAQkV,EAAIC,WAClB,O1BoE0B,SAACnV,GAAD,OACwB,OAAlDD,EAAcC,EAAMO,SAAS1C,OAAOmH,U0BrE/BiR,CAAajW,GAGTqN,GAA2BrN,GAAOsM,OAAS,EAC3C8H,EAAKvJ,EAAiB,+BAAgCqL,KAGxD9B,EAAK9R,GANH8R,EAAKvJ,EAAiB,sBAAuBsL,QLMpDvB,GMX4B,SAAAM,GAAG,OAAI,SAAAd,GAAI,OAAI,SAAA9R,GAC7C,IAAK,CAACuI,EAAeA,GAAe5H,SAASX,EAAOhF,MAAO,OAAO8W,EAAK9R,GAEvE,IAAMtC,EAAQkV,EAAIC,WACZxD,EAAkBpI,GAAmBvJ,IAAU,GAC/C4R,EAAmB1G,GAAYlL,GAErCoU,EAAKvJ,KAEL,IAAMuL,EAAkB9T,EAAOhF,OAASuN,EAAgBwL,GAASC,GACjE,OAAOlC,EAAKvJ,EAAiB,iBAAkBuL,EAAgBzE,EAAiBC,QCb1C,SAAAxR,GAAC,OAAI,SAAAgU,GAAI,OAAI,SAAA9R,GACnD,GlCwU2B,kBkCxUvBA,EAAOhF,KAA0B,OAAO8W,EAAK9R,GACjD,IACE,IAAMiU,EAAQC,aAAaC,QAAQ,WACnC,IAAKF,EAAO,OACZ,IAAM1W,EAAW6W,KAAKC,MAAMJ,GAC5BnC,EAAKvJ,EAAkBhL,GAAU,IACjC,MAAMO,GACNoW,aAAaI,UAAU,eAIa,SAAA1B,GAAG,OAAI,SAAAd,GAAI,OAAI,SAAA9R,GACrD,GlCuT2B,kBkCvTvBA,EAAOhF,KAA0B,OAAO8W,EAAK9R,GACjD,IAAMtC,EAAQkV,EAAIC,WACZtV,EAAWM,EAAYH,GAC7B,IACEwW,aAAaK,QAAQ,UAAWH,KAAKI,UAAUjX,IAC/C,MAAMO,GACN,WChBgC,SAAA8U,GAAG,OAAI,SAAAd,GAAI,OAAI,SAAA9R,GACjD,GnCgV8B,qBmChV1BA,EAAOhF,KAA6B,OAAO8W,EAAK9R,GAEpD,IAAMtC,EAAQkV,EAAIC,WACZtV,EAAWM,EAAYH,GACvB+W,EAAgBL,KAAKI,UAAUjX,EAAU,KAAM,MAC/CmX,EAAO,8CAA0CC,mBAAmBF,IAEpEG,EADOxH,GAAY1P,GACMmX,cAAcC,MAAM,KAAKC,KAAK,KACvDC,EAAWJ,EAAkB5K,OAAS,EAAI4K,EAAoB,mBAE9DK,EAAUC,SAASC,cAAc,KACvCF,EAAQG,aAAa,OAAQV,GAC7BO,EAAQG,aAAa,WAAYJ,GACjCC,EAAQI,WAIwB,SAAAvX,GAAC,OAAI,SAAAgU,GAAI,OAAI,SAAA9R,GAC7C,GnCmU4B,mBmCnUxBA,EAAOhF,KAA2B,OAAO8W,EAAK9R,GADK,SAGxCsV,IAHwC,4EAGvD,+BAAAlC,EAAA,4DACEmC,EAAUC,oBAAoB,SAAUF,GAD1C,kBAGgC5W,KAAK+W,MAAM,GAAGC,OAH9C,cAGUjB,EAHV,OAIUkB,EAAUvB,KAAKC,MAAMI,GAJ/B,kBAKW3C,EAAKvJ,EAAkBoN,GAAS,KAL3C,yDAOW7D,EAAKvJ,EACV,eACA,uGATN,wDAHuD,sBAkBvD,IAAMgN,EAAYL,SAASC,cAAc,SACzCI,EAAUva,KAAO,OACjBua,EAAUxB,OAAS,cACnBwB,EAAUK,iBAAiB,SAAUN,GACrCC,EAAUF,cRpBZ/C,GAAeuD,IAAIC,IAEJtD,U,oBSCTuD,I,mNAGIC,SAA4CxH,IAAMyH,Y,yEAGxD,IAAM7H,EAAY8H,KAAW,QAAS,CACpC,kBAAmBxX,KAAK2P,MAAM8H,aAG1BC,EAAa1X,KAAK2P,MAAMgI,WAC1B3X,KAAK4X,yBACL5X,KAAK6X,6BACT,OACE,2BACE,0BAAMnI,UAAWA,EAAWoI,EAAGJ,EAAYK,IAAK/X,KAAKsX,WACpDtX,KAAKgY,WAAWN,M,mDAKc,MAWJ1X,KAAK2P,MAA5BxL,EAX2B,EAW3BA,MAAOC,EAXoB,EAWpBA,IAAK6T,EAXe,EAWfA,QACdC,EAAM/T,EAAM9D,KAAK+D,EAAIwB,MAAMzB,GAAO7D,MAAM,KACxC6X,EAAeD,EAAI7X,KAAK4X,EAAQrS,MAAMsS,GAAK5X,MAAM,IACvD,MAAM,KAAN,OAAY6D,EAAMvE,EAAlB,YAAuBuE,EAAMtE,EAA7B,cAAoCsY,EAAcvY,EAAlD,YAAuDuY,EAActY,EAArE,YAA0EuE,EAAIxE,EAA9E,YAAmFwE,EAAIvE,K,+CAGxD,MAOJG,KAAK2P,MAAxBxL,EAPuB,EAOvBA,MACFiU,EARyB,EAOhBH,QACIrS,MAAMzB,GAAO7D,MAAM,EAAI,GAIpC+X,EAAwB,IAAnBD,EAAGlY,YACVkY,EAAGxR,OAAOC,YAAYvG,MAJP,IAKf,IAAIX,EALW,GAKQ,GACrB2Y,EAAQnU,EAAM9D,KAAK+X,GAAIxS,MAAMyS,GAC7BE,EAAQpU,EAAM9D,KAAK+X,GAAI/X,KAAKgY,GAClC,MAAM,KAAN,OAAYlU,EAAMvE,EAAlB,YAAuBuE,EAAMtE,EAA7B,cAAoCyY,EAAM1Y,EAA1C,YAA+C0Y,EAAMzY,EAArD,YAA0D0Y,EAAM3Y,EAAhE,YAAqE2Y,EAAM1Y,EAA3E,YAAgFsE,EAAMvE,EAAtF,YAA2FuE,EAAMtE,K,iCAGhF6X,GACjB,GAAI1X,KAAK2P,MAAM8H,aAAezX,KAAK2P,MAAM6I,UAAW,OAAO,KAG3D,IAAMlN,EAAStL,KAAKsX,SAAS9E,QAAUxS,KAAKsX,SAAS9E,QAAQiG,iBAAmB,IAChF,OACE,0BAAM/I,UAAU,cACVoI,EAAGJ,EACHgB,MAAO,CACLC,gBAAiBrN,EACjBsN,iBAAkBtN,EAClBuN,kBAAkB,GAAD,OAAK,EAAI7Y,KAAK2P,MAAMlG,YAAc,EAAlC,a,GArEXqG,IAAMC,YA0FX+I,eAfS,SAAC9Z,EAAc+Z,GACrC,IAAM5U,EAAQb,GAAStE,EAAO+Z,EAASC,QAAQ7U,OACzCC,EAAMd,GAAStE,EAAO+Z,EAASC,QAAQ5U,KACvClG,EAAeiI,GAAqBnH,EAAO+Z,EAASC,QAAQzV,IAClE,MAAO,CACLY,MAAOxE,EAAOgG,KAAKxB,EAAMrB,KACzBsB,IAAKzE,EAAOgG,KAAKvB,EAAItB,KACrBmV,QAAStY,EAAOgG,KAAKzH,EAAa4E,KAClC6U,WAAYxT,EAAMZ,KAAOa,EAAIb,GAC7BkU,WAAYrW,EAAapC,GACzBwZ,UAAWjP,GAAevK,EAAO+Z,EAASC,QAAQzV,IAClDkG,YAAaA,GAAYzK,KAId8Z,CAEbzB,ICzFI4B,I,mNAwCIC,gBAAkB,SAAC7J,GACzB,EAAKM,MAAMwJ,a,EAGLC,cAAgB,SAAC/J,GACvB,EAAKM,MAAM0J,W,yEA3CX,IAAM3J,EAAY8H,KAAW,OAAQ,CACnC,iBAAkBxX,KAAK2P,MAAM2J,WAC7B,cAAetZ,KAAK2P,MAAMqJ,QAAQnV,QAClC,cAAe7D,KAAK2P,MAAM4J,QAC1B,iBAAkBvZ,KAAK2P,MAAM8H,WAC7B,iBAAkBzX,KAAK2P,MAAM8H,YAAczX,KAAK2P,MAAM6I,UACtD,mBAAoBxY,KAAK2P,MAAM8H,YAAczX,KAAK2P,MAAM6J,WACxD,oBAAqBxZ,KAAK2P,MAAM8H,YAAczX,KAAK2P,MAAM8J,cAGrD3W,EAAMnD,EAAOgG,KAAK3F,KAAK2P,MAAMqJ,QAAQlW,KAK3C,OACE,yBAAK4M,UAAU,mBACZ1P,KAAK2P,MAAM+J,WAAa1Z,KAAK2P,MAAM8H,YAClC,yBAAK/H,UAAU,uBACVgJ,MAAO,CACLiB,SAAU,WACVC,KAAM9W,EAAIlD,EAAIia,EACdC,IAAKhX,EAAIjD,EA1BC,GAiBD,GASkC,KAGpD,yBAAK6P,UAAWA,EACXqK,YAAa/Z,KAAKkZ,gBAClBc,UAAWha,KAAKoZ,cAChBV,MAAO,CACLiB,SAAU,WACVC,KAAM9W,EAAIlD,EAlCE,GAmCZka,IAAKhX,EAAIjD,EAnCG,GAoCZgZ,kBAAkB,GAAD,OAAK7Y,KAAK2P,MAAMlG,YAAc,EAA9B,c,GAlCbqG,IAAMC,YAiEV+I,eAhBS,SAAC9Z,EAAc+Z,GAAf,MAAkC,CACxDO,WAAY5V,GAAe1E,EAAO+Z,EAASC,QAAQzV,IACnDgW,QAASxV,GAAY/E,EAAO+Z,EAASC,QAAQzV,IAC7CkU,WAAYrW,EAAapC,GACzB0a,UAAWvQ,GAAcnK,EAAO+Z,EAASC,QAAQzV,IACjDiV,UAAWpP,GAAcpK,EAAO+Z,EAASC,QAAQzV,IACjDiW,WAAYnQ,GAAerK,EAAO+Z,EAASC,QAAQzV,IACnDkW,YAAanQ,GAAgBtK,EAAO+Z,EAASC,QAAQzV,IACrDkG,YAAaA,GAAYzK,KAGA,SAACib,EAAoBlB,GAArB,MAAwC,CACjEI,UAAW,kBAAMc,ErC/EmC,CACpD3d,KAF6B,kBAG7BC,QAAS,CAAEgH,GqC6E+BwV,EAASC,QAAQzV,OAC3D8V,QAAS,kBAAMY,ErC1EyB,CACxC3d,KAF2B,qBqC8Edwc,CAGbG,IClEIiB,I,mNAqDIhB,gBAAkB,SAAC7J,GACzB,EAAKM,MAAMwJ,a,EAGLC,cAAgB,SAAC/J,GACvB,EAAKM,MAAM0J,W,yEAxDX,IAAM3J,EAAY8H,KAAW,gBAAiB,CAC5C,0BAA2BxX,KAAK2P,MAAM8H,WACtC,0BAA2BzX,KAAK2P,MAAM8H,YAAczX,KAAK2P,MAAM6I,YAG3Dd,EAAa1X,KAAK2P,MAAMgI,WAC5B3X,KAAKma,qBACLna,KAAK6X,6BACP,OAAO,0BAAMnI,UAAWA,EACXoI,EAAGJ,EACHqC,YAAa/Z,KAAKkZ,gBAClBc,UAAWha,KAAKoZ,kB,mDAMO,IAAD,EACZpZ,KAAK2P,MAApBxL,EAD2B,EAC3BA,MAAOC,EADoB,EACpBA,IACTtB,EAAMnD,EAAOgG,KAAK3F,KAAK2P,MAAMqJ,QAAQlW,KACrC6D,EAAOvC,EAAIwB,MAAMzB,GAGjBiU,EAA0B,IAArBzR,EAAKzG,YACZyG,EAAKE,YAAYvG,MA5BJ,IA6Bb,IAAIX,EA7BS,GA6BY,GACvB0Y,EAAKD,EAAGxR,OAAOtG,MAAM,EAAI,GACzB8Z,EAAKtX,EAAI8C,MAAMwS,GAAI/X,KAAKgY,GACxBgC,EAAKvX,EAAI8C,MAAMwS,GAAIxS,MAAMyS,GAC/B,MAAM,KAAN,OAAY+B,EAAGxa,EAAf,YAAoBwa,EAAGva,EAAvB,cAA8BiD,EAAIlD,EAAlC,YAAuCkD,EAAIjD,EAA3C,cAAkDwa,EAAGza,EAArD,YAA0Dya,EAAGxa,K,2CAMjC,IACpBsE,EAAUnE,KAAK2P,MAAfxL,MACFrB,EAAMnD,EAAOgG,KAAK3F,KAAK2P,MAAMqJ,QAAQlW,KACrC6D,EAAO7D,EAAI8C,MAAMzB,GAGjBiU,EAA0B,IAArBzR,EAAKzG,YACZyG,EAAKE,YACL,IAAIlH,EAAO,EAAG,GACZ0Y,EAAKD,EAAGxR,OAAOtG,MAhDJ,IAiDXga,EAAMxX,EAAIzC,KAAKgY,EAAG/X,MAAM,EAAI,IAC5B8Z,EAAKE,EAAI1U,MAAMyS,GAAIhY,KAAK+X,EAAG9X,MAAMia,IACjCF,EAAKC,EAAI1U,MAAMyS,GAAIzS,MAAMwS,EAAG9X,MAAMia,IACxC,MAAM,KAAN,OAAYH,EAAGxa,EAAf,YAAoBwa,EAAGva,EAAvB,cAA8Bya,EAAI1a,EAAlC,YAAuC0a,EAAIza,EAA3C,cAAkDwa,EAAGza,EAArD,YAA0Dya,EAAGxa,O,GAlDtCiQ,IAAMC,YAgFlB+I,eAlBS,SAAC9Z,EAAc+Z,GACrC,IAAM1c,EAAQ2J,GAAUhH,EAAO+Z,EAASC,QAAQ3c,OAC1C8H,EAAQb,GAAStE,EAAO3C,EAAM8H,OAC9BC,EAAMd,GAAStE,EAAO3C,EAAM+H,KAClC,MAAO,CACLD,MAAOxE,EAAOgG,KAAKxB,EAAMrB,KACzBsB,IAAKzE,EAAOgG,KAAKvB,EAAItB,KACrB6U,WAAYxT,EAAMZ,KAAOa,EAAIb,GAC7BkU,WAAYrW,EAAapC,GACzBwZ,UAAWhP,GAAsBxK,EAAO+Z,EAASC,QAAQzV,MAIlC,SAAC0W,EAAoBlB,GAArB,MAAwC,CACjEI,UAAW,kBAAMc,EtCvC2C,CAC5D3d,KAFsC,2BAGtCC,QAAS,CAAEgH,GsCqCuCwV,EAASC,QAAQzV,OACnE8V,QAAS,kBAAMY,EtClCiC,CAChD3d,KAFoC,8BsCsCvBwc,CAGboB,I,ikBCiCaM,G,6MA9HLC,QAA6C3K,IAAMyH,Y,EAyFnDmD,mBAAqB,SAACrL,GACvB,EAAKM,MAAMgL,UAChB,EAAKC,gBAAgBvL,EAAEwL,OAAOpb,Q,EAMxBqb,WAAa,WACnB,EAAKF,gBAAgBzQ,GAAeO,I,EAG9BqQ,YAAc,WACpB,EAAKH,gBAAgBzQ,GAAeC,I,EAW9B4Q,YAAc,WAChB,EAAKrL,MAAMsL,SAAS,EAAKtL,MAAMsL,W,EAG7BC,WAAa,WACf,EAAKvL,MAAMwL,QAAQ,EAAKxL,MAAMwL,U,EAG5BC,kBAAoB,WACtB,EAAKzL,MAAM0L,UAAU,EAAK1L,MAAM0L,Y,yEAxH5B,IAAD,EACuBrb,KAAK2P,MAAMxD,OAAjCM,EADD,EACCA,KAAMU,EADP,EACOA,MAAOC,EADd,EACcA,KAEfsC,EAAY8H,KAAW,oBAAqB,CAChD,8BAA+BxX,KAAK2P,MAAM8H,YAAczX,KAAK2P,MAAM6I,YAG/D8C,EAAiB9D,KAAW,2BAA4B,CAC5D,kCAAmCxX,KAAK2P,MAAMtC,UAC9C,qCAAsCrN,KAAK2P,MAAM8H,aAK7C8D,EAAqB/D,KAAW8D,EAAgB,CACpD,kCAAmCtb,KAAK2P,MAAMxD,OAAOmB,cAGjDkO,EAAoBhE,KAAW,8BAA+B,CAClE,qCAAsCxX,KAAK2P,MAAMtC,UACjD,wCAAyCrN,KAAK2P,MAAM8H,aAGhDgE,EAAwBjE,KAAW,mCAAoC,CAC3E,4CAA6CxX,KAAK2P,MAAM8H,aAG1D,OACE,yBAAK/H,UAAWA,GACd,2BAAOA,UAAW6L,EACXxD,IAAK/X,KAAKya,QACViB,UAAW1b,KAAK2P,MAAM8H,WACtBhY,MAAOgN,EACPkP,YAAY,SACZhB,SAAU3a,KAAK4b,kBAAkB,QACjCX,QAASjb,KAAKgb,YACdG,OAAQnb,KAAKkb,WACb5e,KAAK,OACLuf,UAAW,IAClB,0BAAMnM,UAAU,gCAAhB,KACA,2BAAOA,UAAW4L,EACXI,UAAW1b,KAAK2P,MAAM8H,WACtBhY,MAAO0N,EACPwO,YAAY,SACZhB,SAAU3a,KAAK4b,kBAAkB,SACjCX,QAASjb,KAAKgb,YACdG,OAAQnb,KAAKkb,WACb5e,KAAK,OACLuf,UAAW,IAClB,4BAAQnM,UAAW8L,EACXE,UAAW1b,KAAK2P,MAAM8H,WACtBhY,MAAO2N,EACPuN,SAAU3a,KAAK0a,oBACrB,4BAAQjb,MAAO0K,GAAeO,EAAGqP,YAAa/Z,KAAK8a,YAAnD,UACA,4BAAQrb,MAAO0K,GAAeC,EAAG2P,YAAa/Z,KAAK+a,aAAnD,WAEF,4BAAQrL,UAAW+L,EACXK,QAAS9b,KAAKob,uB,0CAUtBpb,KAAK2P,MAAMtC,WAAWrN,KAAK+b,U,8BAI3B/b,KAAKya,QAAQjI,SAASxS,KAAKya,QAAQjI,QAAQuJ,U,wCAGvBC,GAA6B,IAAD,OACpD,OAAO,SAAC3M,GACD,EAAKM,MAAMgL,UAGY,MAAnBtL,EAAEwL,OAAOpb,OAClB,EAAKkQ,MAAMgL,SAAX,MACK,EAAKhL,MAAMxD,OADhB,eAEG6P,EAAW3M,EAAEwL,OAAOpb,Y,sCAqBHhD,GACjBuD,KAAK2P,MAAMgL,UAChB3a,KAAK2P,MAAMgL,SAAX,MACK3a,KAAK2P,MAAMxD,OADhB,CAEEiB,KAAM3Q,S,GA9GmBqT,IAAMC,WCoB/BkM,I,mNAoCIC,mBAAqB,SAAC/P,GAC5B,EAAKwD,MAAMwM,aAAahQ,I,yEApChB,IAAD,SACsBnM,KAAK2P,MAA1BqJ,EADD,EACCA,QAASf,EADV,EACUA,QACXmE,EAASpc,KAAKqc,gBACd3M,EAAY8H,KAChB,qBAD0B,8BAEH4E,IAGzB,OACE,yBAAK1M,UAAWA,EACXgJ,MAAO,CAILiB,SAAU,WACVC,KAAM3B,EAAQrY,EACdka,IAAK7B,EAAQpY,IAEjBG,KAAK2P,MAAM8H,aAAezX,KAAKsc,YAAYF,IAAWpc,KAAKuc,wBAC3DvD,EAAQ/T,IAAI,SAAAkH,GAAM,OACjB,kBAAC,GAAD,CAAkBzM,IAAKyM,EAAO5I,GACZ4I,OAAQA,EACRkB,UAAW,EAAKsC,MAAM/C,gBAAkBT,EAAO5I,GAC/CkU,WAAY,EAAK9H,MAAM8H,WACvBe,UAAW,EAAK7I,MAAM6M,gBAAkBrQ,EAAO5I,GAC/CoX,SAAU,EAAKuB,mBACfb,SAAU,EAAKoB,mBAAmBtQ,EAAO5I,GAAI4I,EAAO9P,OACpD4e,QAAS,EAAKyB,kBAAkBvQ,EAAO5I,IACvC4X,OAAQ,EAAKwB,iBAAiBxQ,EAAO5I,QAExDvD,KAAK2P,MAAM8H,YAAczX,KAAKsc,YAAYF,IAAWpc,KAAKuc,2B,yCAStChZ,EAAYlH,GAAgB,IAAD,OACpD,OAAO,kBAAM,EAAKsT,MAAMiN,aAAarZ,EAAIlH,M,wCAGjBkH,GAAa,IAAD,OACpC,OAAO,kBAAM,EAAKoM,MAAMkN,YAAYtZ,M,uCAGbA,GAAa,IAAD,OACnC,OAAO,kBAAM,EAAKoM,MAAMmN,WAAWvZ,M,4CAGPlH,GAAgB,IAAD,OAC3C,OAAO,kBAAM,EAAKsT,MAAMoN,UAAU1gB,M,sCAMlC,OAAI2D,KAAK2P,MAAMgI,WACN3X,KAAKgd,wBAELhd,KAAKid,0B,8CAMiB,IAAD,EACHjd,KAAK2P,MAAxBxL,EADsB,EACtBA,MACF+Y,EAFwB,EACfjF,QACOrS,MAAMzB,GAAOgZ,QACnC,OAAOnd,KAAKod,0BAA0BF,K,8CAOP,IAAD,EACEld,KAAK2P,MAA7BxL,EADsB,EACtBA,MAAOC,EADe,EACfA,IACTgU,EAFwB,EACVH,QACDrS,MAAMzB,GACnBkU,EAAKD,EAAGxQ,QAAQxD,EAAIwB,MAAMzB,IAC1BgZ,EAAQ/E,EAAGxS,MAAMyS,GAAI8E,QAC3B,OAAOnd,KAAKod,0BAA0BD,K,gDAONA,GAEhC,OAAI,EAAIA,GAASA,GAASrd,KAAKud,GAAK,EAAU,WAErCvd,KAAKud,GAAK,EAAIF,GAASA,GAASrd,KAAKud,GAAW,aAE/Cvd,KAAKud,GAAK,EAAIF,GAASA,IAAUrd,KAAKud,GAAW,eAE/C,gB,kCAOMC,GAClB,MAAO,OAAOC,KAAKD,K,8CAInB,OACE,4BAAQ5N,UAAU,iCACVoM,QAAS9b,KAAKwd,sBAAsBxd,KAAK2P,MAAMvJ,UADvD,e,GA/G0B0J,IAAMC,YA+IvB+I,eAxBS,SAAC9Z,EAAc+Z,GACrC,IAAM1c,EAAQ2J,GAAUhH,EAAO+Z,EAAS3S,SAClCjC,EAAQb,GAAStE,EAAO3C,EAAM8H,OAC9BC,EAAMd,GAAStE,EAAO3C,EAAM+H,KAC5B6T,EAAU9R,GAAqBnH,EAAO3C,EAAMkH,IAClD,MAAO,CACLY,MAAOxE,EAAOgG,KAAKxB,EAAMrB,KACzBsB,IAAKzE,EAAOgG,KAAKvB,EAAItB,KACrBmV,QAAStY,EAAOgG,KAAKsS,EAAQnV,KAC7B6U,WAAYxT,EAAMZ,KAAOa,EAAIb,GAC7BqJ,cAAeA,GAAc5N,GAC7ByY,WAAYrW,EAAapC,GACzBwd,cAAexT,GAAwBhK,KAIhB,SAACib,GAAD,MAAyB,CAClDkC,aAAc,SAAChQ,GAAD,OAAkC8N,ExChGZ,SAAC9N,GAAD,MAA2C,CAC/E7P,KAFsC,2BAGtCC,QAAS,CAAE4P,WwC8F8CtC,CAAyBsC,KAClFyQ,aAAc,SAACrZ,EAAYlH,GAAb,OAA+B4d,ExCrFT,SAAC1W,EAAYlH,GAAb,MAAwC,CAC5EC,KAFsC,2BAGtCC,QAAS,CAAEgH,KAAIlH,UwCmFuCwN,CAAyBtG,EAAIlH,KACnF0gB,UAAW,SAAC1gB,GAAD,OAAmB4d,EAASpQ,EAAsBxN,KAC7DwgB,YAAa,SAACtZ,GAAD,OAAgB0W,ExCjFM,SAAC1W,GAAD,MAAyB,CAC5DjH,KAFqC,0BAGrCC,QAAS,CAAEgH,OwC+E2BsG,CAAwBtG,KAC9DuZ,WAAY,SAACvZ,GAAD,OAAgB0W,ExC5EM,SAAC1W,GAAD,MAAyB,CAC3DjH,KAFoC,yBAGpCC,QAAS,CAAEgH,OwC0E0BsG,CAAuBtG,OAG/CuV,CAGbmD,IC1KIwB,I,mNAcIrE,cAAgB,SAAC/J,GACvB,EAAKM,MAAM+N,IAAI,EAAK/N,MAAM7M,M,yEAdlB,IAAD,EACoB9C,KAAK2P,MAAxBgO,EADD,EACCA,UAAW7a,EADZ,EACYA,IACnB,OAAQ6a,GACN,yBAAKjO,UAAU,cACVsK,UAAWha,KAAKoZ,cAChBV,MAAO,CACLiB,SAAU,WACVC,KAAM9W,EAAIlD,EJGI,GIFdka,IAAKhX,EAAIjD,EJEK,GIFa,S,GATfiQ,IAAMC,YA4BhB+I,eATS,SAAC9Z,GAAD,MAAmB,CACzC2e,UAAW/b,GAAa5C,GACxB8D,IAAKtB,GAASxC,KAGW,SAACib,GAAD,MAAyB,CAClDyD,IAAK,SAAC5a,GAAD,OAAiBmX,EzCVD,SAACnX,GAAD,MAA0B,CAC/CxG,KAFsB,WAGtBC,QAAS,CAAEuG,QyCQoB+G,CAAU/G,OAG5BgW,CAGb2E,ICrBIG,I,mNA8BI1E,gBAAkB,SAAC7J,GACzB,EAAKM,MAAMwJ,UAAU,EAAK0E,gBAAgBxO,K,EAGpC+J,cAAgB,WACtB,EAAKzJ,MAAM0J,W,EAMLyE,gBAAkB,SAACzO,GACzBA,EAAEE,iBACF,EAAKI,MAAMoO,UAAU,EAAKF,gBAAgBxO,K,yEA1ClC,IAAD,EACqDrP,KAAK2P,MAAzD7S,EADD,EACCA,OAAQD,EADT,EACSA,MAAOE,EADhB,EACgBA,cAAeC,EAD/B,EAC+BA,kBAQtC,OACE,yBAAK0S,UAAU,SACRqK,YAAa/Z,KAAKkZ,gBAClBc,UAAWha,KAAKoZ,cAChB4E,YAAahe,KAAK8d,iBACvB,yBAAKG,MAAM,6BACNC,MAAM,OACNC,OAAO,QACTrhB,EAAOmI,IAAI,SAAA+T,GAAO,OAAI,kBAAC,GAAD,CAAOtZ,IAAKsZ,EAAQzV,GAAIyV,QAASA,MACvDjc,EAAckI,IAAI,SAAA+T,GAAO,OAAI,kBAAC,GAAD,CAActZ,IAAKsZ,EAAQzV,GAAIyV,QAASA,OAEvEnc,EAAMoI,IAAI,SAAA+T,GAAO,OAAI,kBAAC,GAAD,CAAMtZ,IAAKsZ,EAAQzV,GAAIyV,QAASA,MACrD7V,OAAOoC,KAAKvI,GAAmBiI,IAAI,SAAAmB,GAAO,OACzC,kBAAC,GAAD,CAAmB1G,IAAK0G,EAASA,QAASA,EAAS4S,QAAShc,EAAkBoJ,OAEhF,kBAAC,GAAD,S,sCAuBkBiJ,GAAsB,IAAD,EACrBA,EAAE+O,cAAcC,wBAA9BzE,EADmC,EACnCA,KAAME,EAD6B,EAC7BA,IACNwE,EAAqBjP,EAArBiP,QAASC,EAAYlP,EAAZkP,QACjB,OAAO,IAAI5e,EAAO2e,EAAU1E,EAAM2E,EAAUzE,O,GAnD3BhK,IAAMC,YAoEZ+I,eAbS,SAAC9Z,GAAD,MAAmB,CACzClC,OAAQiJ,GAAU/G,GAClBnC,MAAOqG,GAASlE,GAChBjC,cAAemJ,GAAiBlH,GAChChC,kBAAmBiP,GAA4BjN,KAGtB,SAACib,GAAD,MAAyB,CAClDd,UAAW,SAACrW,GAAD,OAAiBmX,E1CgEC,SAACnX,GAAD,MAA0B,CACvDxG,KAF+B,oBAG/BC,QAAS,CAAEuG,Q0ClE0B+G,CAAkB/G,KACvDuW,QAAS,kBAAMY,E1CqE2B,CAC1C3d,KAF6B,qB0CnE7ByhB,UAAW,SAACjb,GAAD,OAAiBmX,E1CyEC,SAACnX,GAAD,MAA0B,CACvDxG,KAF+B,oBAG/BC,QAAS,CAAEuG,Q0C3E0B+G,CAAkB/G,OAG1CgW,CAGb8E,IChGWY,GAAmB,SAACxf,GAE/B,OADsB8E,GAAc9E,GAAOsM,QAEzC,KAAK,EAAG,MAAO,CACbmT,GAAgBC,WAElB,KAAK,EAAG,MAAO,CACbD,GAAgBC,UAChBD,GAAgBE,aAChBF,GAAgBG,oBAChBH,GAAgBI,WAChBJ,GAAgBK,kBAElB,KAAK,EAAG,MAAO,CACbL,GAAgBC,UAChBD,GAAgBM,kBAChBN,GAAgBO,eAChBP,GAAgBQ,sBAElB,QAAS,MAAO,CACdR,GAAgBC,UAChBD,GAAgBS,mBAChBT,GAAgBU,yBAiBTV,GAAqD,CAChEC,UAAW,YACXC,aAAc,eACdI,kBAAmB,oBACnBG,mBAAoB,qBACpBN,oBAAqB,sBACrBI,eAAgB,iBAChBH,WAAY,aACZO,aAAc,eACdN,iBAAkB,mBAClBG,qBAAsB,uBACtBE,sBAAuB,yBClCnBE,I,qNA0BIC,sBAAwB,WAC9B,EAAK3P,MAAMjC,Q,EAGL6R,sBAAwB,WAC9B,EAAK5P,MAAM3B,Q,EAGLwR,c,mBACLf,GAAgBC,UAAY,CAC3Bpd,OAAQ,kBAAM,EAAKqO,MAAM8P,YACzB/P,UAAW,YACXxS,MAAO,kB,cAERuhB,GAAgBE,aAAe,CAC9Brd,OAAQ,kBAAM,EAAKqO,MAAM+P,gBACzBhQ,UAAW,eACXxS,MAAO,iB,cAERuhB,GAAgBM,kBAAoB,CACnCzd,OAAQ,kBAAM,EAAKqO,MAAM+P,gBACzBhQ,UAAW,oBACXxS,MAAO,kB,cAERuhB,GAAgBS,mBAAqB,CACpC5d,OAAQ,kBAAM,EAAKqO,MAAM+P,gBACzBhQ,UAAW,qBACXxS,MAAO,kB,cAERuhB,GAAgBG,oBAAsB,CACrCtd,OAAQ,kBAAM,EAAKqO,MAAMgQ,iBACzBjQ,UAAW,sBACXxS,MAAO,wB,cAERuhB,GAAgBO,eAAiB,CAChC1d,OAAQ,kBAAM,EAAKqO,MAAMgQ,iBACzBjQ,UAAW,iBACXxS,MAAO,mB,cAERuhB,GAAgBI,WAAa,CAC5Bvd,OAAQ,kBAAM,EAAKqO,MAAMiQ,aACzBlQ,UAAW,aACXxS,MAAO,iC,cAERuhB,GAAgBK,iBAAmB,CAClCxd,OAAQ,kBAAM,EAAKqO,MAAMkQ,eACzBnQ,UAAW,mBACXxS,MAAO,mC,cAERuhB,GAAgBQ,qBAAuB,CACtC3d,OAAQ,kBAAM,EAAKqO,MAAMkQ,eACzBnQ,UAAW,uBACXxS,MAAO,qC,cAERuhB,GAAgBU,sBAAwB,CACvC7d,OAAQ,kBAAM,EAAKqO,MAAMkQ,eACzBnQ,UAAW,wBACXxS,MAAO,qC,4EAlFD,IAAD,OACP,OACE,yBAAKwS,UAAU,iBACb,yBAAKA,UAAU,oCACb,4BAAQA,UAAU,mDACVxS,MAAM,OACN4e,QAAS9b,KAAKsf,wBACtB,4BAAQ5P,UAAU,mDACVxS,MAAM,OACN4e,QAAS9b,KAAKuf,yBAGvBvf,KAAK2P,MAAMmQ,YAAc9f,KAAK2P,MAAMoQ,YAAY9a,IAAI,SAAA3I,GACnD,IAAM0jB,EAAS,EAAKR,aAAaljB,GACjC,OAAO0jB,GACL,4BAAQtQ,UAAS,+CAA0CsQ,EAAOtQ,UAAjD,WACTxS,MAAO8iB,EAAO9iB,MACdwC,IAAKpD,EACLwf,QAASkE,EAAO1e,gB,GAnBTwO,IAAMC,YAuGlB+I,eAfS,SAAC9Z,GAAD,MAAmB,CACzC8gB,WAAY1e,EAAapC,GACzB+gB,YAAavB,GAAiBxf,KAGL,SAACib,GAAD,MAAyB,CAClDvM,KAAM,kBAAMuM,E5CmFqB,CACjC3d,KAFkB,U4CjFlB0R,KAAM,kBAAMiM,E5CuFqB,CACjC3d,KAFkB,U4CrFlBmjB,SAAU,kBAAMxF,E5CvF4B,CAC5C3d,KAF+B,uB4CyF/BojB,aAAc,kBAAMzF,E5C7E4B,CAChD3d,KAFmC,2B4C+EnCqjB,cAAe,kBAAM1F,E5CoEoC,CACzD3d,KAF6C,qC4ClE7CsjB,UAAW,kBAAM3F,E5C1EiC,CAClD3d,KAFsC,8B4C4EtCujB,YAAa,kBAAM5F,E5CtEkC,CACrD3d,KAFyC,mC4C0E5Bwc,CAGbuG,I,kBC3Ha,I,MAEbY,GACAC,ICOIC,I,mNA6DIC,eAAiB,WACvB,EAAKzQ,MAAMX,c,EAGLqR,oBAAsB,WAC5B,EAAK1Q,MAAM2Q,Y,EAGLC,kBAAoB,WAC1B,EAAK5Q,MAAM6Q,U,EAGLC,uBAAyB,SAACpR,GAChC,IAAMqR,EAAerR,EAAEwL,OAAOpb,MACxBZ,EAAW8hB,GAAUnd,KAAK,SAAA0N,GAAC,OAAIA,EAAEvC,SAASC,OAAS8R,IACrD7hB,GACF,EAAK8Q,MAAMiR,YAAY/hB,I,yEA3EzB,OACE,yBAAK6Q,UAAU,gBACb,yBAAKA,UAAU,yBACb,4BAAQA,UAAU,gDACVxS,MAAM,oBACN4e,QAAS9b,KAAKogB,iBACtB,4BAAQ1Q,UAAU,qDACVxS,MAAM,0BACN4e,QAAS9b,KAAKqgB,sBACtB,4BAAQ3Q,UAAU,mDACVxS,MAAM,wBACN4e,QAAS9b,KAAKugB,qBAGxB,4BAAQ7Q,UAAU,yBACVjQ,MAAM,UACNkb,SAAU3a,KAAKygB,wBACrB,4BAAQhhB,MAAM,UAAUic,UAAQ,EAAChc,IAAI,WAArC,YACCihB,GAAU1b,IAAI,SAAAiM,GAAC,OACd,4BAAQxR,IAAKwR,EAAEvC,SAASC,KAAMnP,MAAOyR,EAAEvC,SAASC,MAAOsC,EAAEvC,SAASC,SAItE,uBAAGc,UAAU,qBACVmR,KAAI,UAAKC,MAAL,kBACJjG,OAAO,SACPkG,IAAI,uBAHP,YAMA,uBAAGrR,UAAU,qBACVmR,KAAI,UAAKC,MAAL,eACJjG,OAAO,SACPkG,IAAI,uBAHP,SAMA,uBAAGrR,UAAU,qBACVmR,KAAI,UAAKC,MAAL,eACJjG,OAAO,SACPkG,IAAI,uBAHP,SAMA,uBAAGrR,UAAU,+CACVmR,KAAK,gCACL3jB,MAAM,mBACN2d,OAAO,SACPkG,IAAI,uBAJP,UAOA,uBAAGrR,UAAU,4CACVmR,KAAK,uCACL3jB,MAAM,eACN2d,OAAO,SACPkG,IAAI,uBAJP,qB,GAlDkBjR,IAAMC,YAyFjB+I,eACb,KARyB,SAACmB,GAAD,MAAyB,CAClDjL,WAAY,kBAAMiL,E9CmOqB,CACvC3d,KAFyB,iB8CjOzBgkB,SAAU,kBAAMrG,E9CuP4B,CAC5C3d,KAF8B,sB8CrP9BkkB,OAAQ,kBAAMvG,E9C2P4B,CAC1C3d,KAF4B,oB8CzP5BskB,YAAa,SAAC/hB,GAAD,OAAmBob,EAASpQ,EAAkBhL,GAAU,OAGxDia,CAGbqH,IClFIa,I,mNACIC,QAA2CnR,IAAMyH,Y,EAyFjD2J,aAAe,SAAC7R,GACtB,EAAKM,MAAM1E,iBAAiBoE,EAAEwL,OAAOrQ,a,EAG/B2W,uBAAyB,WAC/B,EAAKxR,MAAMyR,S,yEA5FH,IAAD,OACC3J,EAAezX,KAAK2P,MAApB8H,WASR,OACE,oCACGzX,KAAKqhB,iBACN,yBAAK3R,UAAU,OACVqI,IAAK/X,KAAKihB,QACVK,SAAUthB,KAAKkhB,aACfxI,MAAO,CAAEwF,MAAM,GAAD,OAAKqD,IAAL,QACjB,yBAAK7R,UAAU,eACb,yBAAKA,UAAU,qBAAqBgJ,MAAO,CAAEwF,MAV5BqD,MAUjB,kDAGCvhB,KAAK2P,MAAMpF,QAAQtF,IAAI,SAACuc,EAAGzgB,GAAJ,OACtB,2BAAOrB,IAAKqB,EACL2a,UAAW,EAAK/L,MAAM8H,WACtB/H,WArBM+R,EAqBmB1gB,EArBDyW,KAAW,aAAc,CAChE,uBAAwBC,EACxB,sBAAuBA,GAAcgK,IAAU,EAAK9R,MAAM7E,cAoB3CrL,MAAO+hB,EACP7F,YAAY,SACZhB,SAAU,EAAK+G,iBAAiB3gB,GAChCka,QAAS,EAAK0G,gBAAgB5gB,GAC9B2X,MAAO,CAAEwF,MAAM,GAAD,OrC3CT,GqC2CS,OACd5hB,KAAK,OACLuf,UAAW,IA5BN,IAAC4F,IA8Bf,yBAAK/R,UAAU,sBAAsBgJ,MAAO,CAAEwF,MAAM,GAAD,OAAKqD,GAAL,WAGtDvhB,KAAK4hB,gBACL5hB,KAAK6hB,oBACL7hB,KAAK8hB,4B,0CAMN9hB,KAAKihB,QAAQzO,SACfxS,KAAKihB,QAAQzO,QAAQuP,SAASR,GAAgB,K,yCAI/BS,GACbA,EAASC,cAAgBjiB,KAAK2P,MAAMsS,aAA0C,OAA3BjiB,KAAK2P,MAAMsS,aAChEjiB,KAAKkiB,cAEHF,EAASlX,aAAe9K,KAAK2P,MAAM7E,YACrC9K,KAAKmiB,cAAa,GAGhBH,EAASvK,aAAezX,KAAK2P,MAAM8H,YAAezX,KAAK2P,MAAM8H,YAC/DzX,KAAKmiB,cAAa,K,oCAOpB,GAAIniB,KAAKihB,QAAQzO,QAAS,CACxB,IACM4P,EADgBpiB,KAAKihB,QAAQzO,QAAQ6P,WAAW,GACpBA,WAAWriB,KAAK2P,MAAMsS,YAAwB,GAC5EG,GAAcA,EAAiCrG,W,uCAI9BjZ,GAAc,IAAD,OACpC,OAAO,SAACuM,GAGiB,MAAnBA,EAAEwL,OAAOpb,OACb,EAAKkQ,MAAM2S,WAAWxf,EAAKuM,EAAEwL,OAAOpb,U,sCAIhBqD,GAAc,IAAD,OACnC,OAAO,WACL,EAAK6M,MAAM4S,UAAUzf,M,mCAYJ0f,GACnB,GAAIxiB,KAAKihB,QAAQzO,QAAS,CAIxB,IAAMhI,ErClHc,GqCkHDxK,KAAK2P,MAAM7E,WAA0ByW,GACxDvhB,KAAKihB,QAAQzO,QAAQuP,SAAS,CAC5BnI,KAAMpP,EACNsP,IAAK,EACL2I,SAAUD,EAAS,SAAW,Y,uCAUlC,IAAM9S,EAAY8H,KAAW,cAAe,CAC1C,uBAAwBxX,KAAK2P,MAAM8H,aAErC,OACE,yBAAK/H,UAAWA,EACXgJ,MAAO,CACLiB,SAAU,WACVC,KAAK,cAAD,OAAgB2H,GAAhB,Y,+CAMb,IAAM7R,EAAY8H,KAAW,0BAA2B,CACtD,mCAAoCxX,KAAK2P,MAAM/R,YAEjD,OACE,yBAAK8R,UAAWA,EACXgJ,MAAO,CACLiB,SAAU,WACVC,KAAK,cAAD,OAAgB2H,GAAhB,OACJ1I,kBAAkB,GAAD,OAAK7Y,KAAK2P,MAAMlG,YAAc,EAA9B,W,0CAM1B,OACE,4BAAQiG,UAAU,qBACVxS,MAAM,sBACN4e,QAAS9b,KAAKmhB,uBACdzI,MAAO,CACLiB,SAAU,WACV+I,MAAM,cAAD,OAAgBnB,IAAhB,Y,sCAOjB,OACE,oCACE,yBAAK7R,UAAU,4BACVgJ,MAAO,CACLiB,SAAU,WACVC,KAAK,cAAD,OAAgB2H,IAAhB,UAEX,yBAAK7R,UAAU,6BACVgJ,MAAO,CACLiB,SAAU,WACV+I,MAAM,cAAD,OAAgBnB,IAAhB,e,GAvKDzR,IAAMC,YA8LV+I,eAhBS,SAAC9Z,GAAD,MAAmB,CACzCuL,QAASL,GAAYlL,GACrByY,WAAYrW,EAAapC,GACzBijB,YAAarX,GAAgB5L,GAC7B8L,WAAYrC,GAAezJ,GAC3BpB,UAAW8K,GAAc1J,GACzByK,YAAaA,GAAYzK,KAGA,SAACib,GAAD,MAAyB,CAClDqI,WAAY,SAACxf,EAAarD,GAAd,OAAgCwa,E/CvFhB,SAACnX,EAAarD,GAAd,MAAyC,CACrEnD,KAF8B,mBAG9BC,QAAS,CAAEuG,MAAKrD,U+CqFqCoK,CAAiB/G,EAAKrD,KAC3EwL,iBAAkB,SAACT,GAAD,OAAwByP,E/C7EZ,SAACzP,GAAD,MAAiC,CAC/DlO,KAFgC,qBAGhCC,QAAS,CAAEiO,e+C2EwCX,CAAmBW,KACtE+X,UAAW,SAACzf,GAAD,OAAiBmX,E/CxED,SAACnX,GAAD,MAA0B,CACrDxG,KAF6B,kBAG7BC,QAAS,CAAEuG,Q+CsE0B+G,CAAgB/G,KACrDse,MAAO,kBAAMnH,E/CpFyB,CACtC3d,KAFwB,kB+CwFXwc,CAGbkI,ICpMI2B,I,mNAiCIC,MAAQ,WACd,OAAI,EAAKjT,MAAMvO,aACN,EAAKuO,MAAMiT,QAEX,EAAKjT,MAAMkT,gB,EAIdC,gBAAkB,WACpB,EAAKnT,MAAMvO,aAAc,EAAKuO,MAAM4B,OACnC,EAAK5B,MAAMoT,S,EAGVC,KAAO,WACb,EAAKrT,MAAMqT,Q,EAGLC,kBAAoB,SAAC5T,GAC3B,EAAKM,MAAMuT,mBAAmBC,OAAO9T,EAAEwL,OAAOpb,S,yEAlDtC,IACA2B,EAAiBpB,KAAK2P,MAAtBvO,aACFgiB,EAAqB5L,KACzB,uBACApW,EAAe,4BAA8B,8BAG/C,OACE,yBAAKsO,UAAU,gBACb,4BAAQA,UAAU,kDACVxS,MAAM,mBACN4e,QAAS9b,KAAK4iB,QACtB,4BAAQlT,UAAW0T,EACXlmB,MAAOkE,EAAe,kBAAoB,mBAC1C0a,QAAS9b,KAAK8iB,kBACtB,4BAAQpT,UAAU,iDACVxS,MAAM,sCACNwe,UAAWta,EACX0a,QAAS9b,KAAKgjB,OACtB,yBAAKtT,UAAU,+BACb,0BAAMA,UAAU,qCAAhB,QACA,2BAAOpT,KAAK,QACLmD,MAAOO,KAAK2P,MAAM1G,gBAClBoa,IAAK,EACLhZ,IvCTc,GuCUdsQ,SAAU3a,KAAKijB,oBACtB,0BAAMvT,UAAU,qCAAhB,c,GA3BgBI,IAAMC,YAqEjB+I,eAdS,SAAC9Z,GAAD,MAAmB,CACzCoC,aAAcA,EAAapC,GAC3BiK,gBAAiBU,GAAmB3K,KAGX,SAACib,GAAD,MAAyB,CAClD2I,MAAO,kBAAM3I,EAASpQ,MACtBgZ,aAAc,kBAAM5I,EhDwJwB,CAC5C3d,KAAMiB,KgDxJNwlB,MAAO,kBAAM9I,EhDkJwB,CACrC3d,KAAMgB,KgDlJN0lB,KAAM,kBAAM/I,EhDuIwB,CACpC3d,KAAMc,KgDvINmU,KAAM,kBAAM0I,EhD2IwB,CACpC3d,KAAMe,KgD3IN6lB,mBAAoB,SAACjZ,GAAD,OAAqBgQ,EhD8JN,SAAChQ,GAAD,MAA8B,CACjE3N,KAFsC,2BAGtCC,QAAS,CAAE0N,YgDhKuCJ,CAAwBI,OAG7D6O,CAGb6J,IChFIW,I,mNAWIC,iBAAmB,SAAClU,GAC1B,EAAKM,MAAM6T,WAAWnU,EAAEwL,OAAOpb,Q,yEAV/B,OACE,2BAAOiQ,UAAU,aACVpT,KAAK,OACLmD,MAAOO,KAAK2P,MAAMf,KAClB+L,SAAU3a,KAAKujB,iBACf5H,YAAY,qB,GAPD7L,IAAMC,YAwBf+I,eARS,SAAC9Z,GAAD,MAAmB,CACzC4P,KAAMF,GAAY1P,KAGO,SAACib,GAAD,MAAyB,CAClDuJ,WAAY,SAAC5U,GAAD,OAAkBqL,EjD2RC,SAACrL,GAAD,MAA2B,CAC1DtS,KAFiC,sBAGjCC,QAAS,CAAEqS,SiD7R4B/E,CAAoB+E,OAG9CkK,CAGbwK,ICzBIG,I,mNAgBIC,mBAAqB,SAACrU,GAC5BA,EAAEsU,mB,EAGIC,QAAU,WAChB,EAAKjU,MAAMiU,W,yEAnBX,OAAO5jB,KAAK2P,MAAMtB,MAChB,yBAAKqB,UAAU,qBAAqBoM,QAAS9b,KAAK4jB,SAChD,yBAAKlU,UAAU,UAAUoM,QAAS9b,KAAK0jB,oBACrC,wBAAIhU,UAAU,kBAAkB1P,KAAK2P,MAAMzS,OAC3C,yBAAKwS,UAAU,oBAAoB1P,KAAK2P,MAAMxS,SAC9C,4BAAQuS,UAAU,0BACVoM,QAAS9b,KAAK4jB,SADtB,iB,GAPY9T,IAAMC,YAmCb+I,eAVS,SAAC9Z,GAAD,MAAmB,CACzCqP,KAAMF,GAAYnP,GAClB9B,MAAOoR,GAAatP,GACpB7B,QAASoR,GAAevP,KAGC,SAACib,GAAD,MAAyB,CAClD2J,QAAS,kBAAM3J,ElDuK4B,CAC3C3d,KAF6B,uBkDnKhBwc,CAGb2K,IC7BII,I,mNA4BIC,cAAgB,SAACzU,GACvB,EAAKM,MAAMxN,QAAQkN,EAAE3P,IAAK2P,I,EAGpB0U,YAAc,SAAC1U,GACrB,EAAKM,MAAMvN,MAAMiN,EAAE3P,M,yEA/BnB,OACE,yBAAKgQ,UAAU,OACb,kBAAC,GAAD,MACA,kBAAC,GAAD,MACA,kBAAC,GAAD,MACA,kBAAC,GAAD,MACA,kBAAC,GAAD,MACA,kBAAC,GAAD,MACA,kBAAC,GAAD,S,0CAQJ8G,SAASU,iBAAiB,UAAWlX,KAAK8jB,eAC1CtN,SAASU,iBAAiB,QAASlX,KAAK+jB,aACxC/jB,KAAK2P,MAAMqU,c,6CAIXxN,SAASM,oBAAoB,UAAW9W,KAAK8jB,eAC7CtN,SAASM,oBAAoB,QAAS9W,KAAK+jB,iB,GAzB7BjU,IAAMC,YA2CT+I,eACb,KAPyB,SAACmB,GAAD,MAAyB,CAClD9X,QAAS,SAACzC,EAAa0U,GAAd,OAA6C6F,EnDgHjC,SAACva,EAAa0U,GAAd,MAAsD,CAC3E9X,KAFsB,WAGtBC,QAAS,CAAEmD,MAAK0U,UmDlH+CvK,CAAUnK,EAAK0U,KAC9EhS,MAAO,SAAC1C,GAAD,OAAiBua,EnDqHL,SAACva,GAAD,MAA0B,CAC7CpD,KAFoB,SAGpBC,QAAS,CAAEmD,QmDvHsBmK,CAAQnK,KACzCskB,UAAW,kBAAM/J,EnD8QwB,CACzC3d,KAF2B,qBmD1Qdwc,CAGb+K,I,MC/DFI,IAASC,OACP,kBAAC,IAAD,CAAUpQ,MAAOA,IACf,kBAAC,GAAD,OAEF0C,SAAS2N,eAAe,Y","file":"static/js/main.ddd9b70a.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEkAAABNCAYAAADq4knKAAAYRGlDQ1BJQ0MgUHJvZmlsZQAAWIWVWQdUFEuz7tnIwi4555xzDpJzkpwRWJa0ZMkiSBQlXMGECiiSRCQJBhARAQmiCBIEBAOgoCgqBhQlvSHovf9/z3nvvD6nZ76trq6u7qqu7poFgEORGB4ejKAFICQ0KsLWWI/X2cWVF/sKoAAlYAIQYCeSIsN1ra0tAFx+v/+zfB+D+eAyIrUl69/t/2uh8/GNJAEAWcPY2yeSFALj6wCglEnhEVEAoBdhukBsVDiMMbCWgDECVhDGglvYfwerbmHvHWyxzWNvqw9jLwAo8ERihD8A1Ft68caQ/GE51DlwG32oDzkUZr0IYy1SANEHAPZpmEcyJCQMxhx4GIt6/0OO/3/I9P4jk0j0/4N35rJdKAzIkeHBxAP/z+X4v0tIcPTvMQTgig+IMLHdmvPWugWFmW9hWHfofqj3XisY08N4lOyzzb+F5wOiTRx2+VdIkfrwmgFmABB4H6KBOYw5YcwfGrzXYpeu5Uc2MoUxvPYIe3KUqf1OX4RPRJjtrnxEnG+kod1vTIzYHmuLJys6yEF3V+aFAF/T3zJb4gPsnXb0RDyOITvuhTE1jJ9FBtmZ7/K8iw/Q3/ubJyLadktn2OZI4BdhZLvDgxQMifw9L6R6ANl07y62IBG39WGFsUdUgL3JjhxkjG+ks8VvPX18DQx35oVM9Q112NUfeSI8Ss92t295eLD1Lj+y1TfYeIvOD+OByBi7332XomBn25kvCoRHWdvv6IZiDCSaWe+MixIHFkAfGABeEA1XbxAGAgF5YLFpEf6102IEiCAC+ANfILVL+d3DabslFH7agXjwAUa+IPJPP73tVl8QA9PX/1B3nlLAb7s1ZrtHEJiHcQgwB8Hw7+jtXqF/RnMEr2EK+V+jk2Bdg+G61fYvGi/NbxrGEGOAMcEYYcRQ7CgtlAbKAn7qwFUepYpS+63X3/zoefQQehb9BD2NfupJTo34L815gSWYhnU02p2d9z9nhxKGpSqh9FCasHxYNooZxQ6kUIrwSLoobXhsJZj6T12j/8z477XclYWTxSFwLDgdnOi/NNhanX/Of5dOLU6ttKuX95/V0v/D9d9S9P+xfj7w2/y/OZFHkdeQvcgOZB+yFdkEeJF3kc3IfuSdLfzHN15v+8bv0Wy3dQuC5ZD/NR5xd8ytVYuUrZZdkF3bbQNRvnFRW5tFPyz8QATZPyCKVxeO1r68pqEkaUleeVk5NQC2Yv9OaPlqux3TIebBv2nkMQCUG2DixN80f9jfW2YBwFn8TROqgbczHFvv40jRETE7NNTWAw2fKTTwTmED3HDsEoVnJA+UgQbQAYbADFgBe+ACPOA1D4D9NALEggSQAjJANsgDp0EBKAZl4DKoBY2gCbSCDtADHoLH4AmYgn1lDrwHS+A7WIUgCAsRIAaIDeKBhCAJSB5ShbQgQ8gCsoVcIC/IHwqFoqEEKA3Khk5ABVAJVAU1QLegDqgPGoKeQjPQAvQF+oVAIvAIRgQXQhghg1BF6CLMEfaIfQh/xH5EPCIdcQxxFlGKqEHcRHQgHiKeIKYR7xHLSICkQjIj+ZBSSFWkPtIK6Yr0Q0YgDyGzkPnIUmQdsgW29AhyGrmI/InCoBhQvCgp2F9NUA4oEmo/6hAqB1WAuoy6iepCjaBmUEuoDTQBzYmWQKujTdHOaH90LDoDnY++hL6B7ob3zhz6OwaDYcaIYFTgveeCCcQcxORgzmPqMe2YIcwrzDIWi2XDSmA1sVZYIjYKm4E9h63B3sUOY+ewKxRUFDwU8hRGFK4UoRSpFPkUVyjaKIYp3lCs4mhxQjh1nBXOB3cAl4srx7XgBnFzuFVKOkoRSk1Ke8pAyhTKs5R1lN2Uzyi/UlFR8VOpUdlQkamSqc5SXaW6TzVD9RNPjxfH6+Pd8dH4Y/hKfDv+Kf4rgUAQJugQXAlRhGOEKsI9wgvCCjUDtTS1KbUPdRJ1IfVN6mHqjzQ4GiEaXRoPmniafJprNIM0i7Q4WmFafVoi7SHaQtpbtOO0y3QMdHJ0VnQhdDl0V+j66N7SY+mF6Q3pfejT6cvo79G/YkAyCDDoM5AY0hjKGboZ5hgxjCKMpoyBjNmMtYwDjEtM9EyKTI5McUyFTHeYppmRzMLMpszBzLnMjcxjzL9YuFh0WXxZMlnqWIZZfrBysOqw+rJmsdazPmH9xcbLZsgWxHacrYntOTuKXZzdhj2W/QJ7N/siByOHBgeJI4ujkWOSE8EpzmnLeZCzjLOfc5mLm8uYK5zrHNc9rkVuZm4d7kDuU9xt3As8DDxaPGSeUzx3ed7xMvHq8gbznuXt4l3i4+Qz4YvmK+Eb4FvlF+F34E/lr+d/LkApoCrgJ3BKoFNgSZBH0FIwQbBacFIIJ6QqFCB0RqhX6IewiLCT8BHhJuG3IqwipiLxItUiz0QJotqi+0VLRUfFMGKqYkFi58UeiyPElcQDxAvFByUQEsoSZInzEkOSaEk1yVDJUslxKbyUrlSMVLXUjDSztIV0qnST9EcZQRlXmeMyvTIbskqywbLlslNy9HJmcqlyLXJf5MXlSfKF8qMKBAUjhSSFZoXPihKKvooXFCeUGJQslY4odSqtK6soRyjXKS+oCKp4qRSpjKsyqlqr5qjeV0Or6aklqbWq/VRXVo9Sb1T/pCGlEaRxRePtHpE9vnvK97zS5NckapZoTmvxanlpXdSa1ubTJmqXas/qCOj46FzSeaMrphuoW6P7UU9WL0Lvht4PfXX9RP12A6SBsUGWwYAhvaGDYYHhCyN+I3+jaqMlYyXjg8btJmgTc5PjJuOmXKYk0yrTJTMVs0SzLnO8uZ15gfmshbhFhEWLJcLSzPKk5bO9QntD9zZZAStTq5NWz61FrPdb37bB2FjbFNrM28rZJtj22jHYedpdsftur2efaz/lIOoQ7dDpSOPo7ljl+MPJwOmE07SzjHOi80MXdheyS7Mr1tXR9ZLrspuh22m3OXcl9wz3sX0i++L29XmwewR73PGk8SR6XvNCezl5XfFaI1oRS4nL3qbeRd5LJH3SGdJ7Hx2fUz4Lvpq+J3zf+Gn6nfB766/pf9J/IUA7ID9gkaxPLiB/DjQJLA78EWQVVBm0GewUXB9CEeIVciuUPjQotCuMOywubChcIjwjfHq/+v7T+5cizCMuRUKR+yKboxjhS3Z/tGj04eiZGK2YwpiVWMfYa3F0caFx/QfED2QeeBNvFF9xEHWQdLAzgS8hJWEmUTex5BB0yPtQZ5JAUnrSXLJx8uUUypSglEepsqknUr+lOaW1pHOlJ6e/Omx8uDqDOiMiY/yIxpHio6ij5KMDmQqZ5zI3snyyHmTLZudnr+WQch78JffX2b82j/kdG8hVzr2Qh8kLzRs7rn388gm6E/EnXp20PHnzFO+prFPfTnue7stXzC8+Q3km+sz0WYuzzecEz+WdWysIKHhSqFdYX8RZlFn047zP+eELOhfqirmKs4t/XSRfnCgxLrlZKlyaX4YpiymbL3cs761Qrai6xH4p+9J6ZWjl9GXby11VKlVVVziv5FYjqqOrF2rcax7XGtQ210nVldQz12dfBVejr75r8GoYazRv7Lymeq3uutD1ohsMN7JuQjcP3FxqCmiabnZpHrpldquzRaPlxm3p25WtfK2Fd5ju5LZRtqW3bd6Nv7vcHt6+2OHf8arTs3PqnvO90S6broFu8+77PUY993p1e+/e17zf2qfed+uB6oOmh8oPb/Yr9d94pPToxoDywM1BlcHmx2qPW4b2DLUNaw93jBiM9Iyajj58svfJ0JjD2MS4+/j0hM/E26fBTz9PxkyuTiU/Qz/Lek77PP8F54vSl2Iv66eVp+/MGMz0z9rNTr0ivXr/OvL12lz6PGE+/w3Pm6q38m9bF4wWHr9zezf3Pvz96mLGB7oPRR9FP17/pPOpf8l5ae5zxOfNLzlf2b5WflP81rlsvfzie8j31R9ZK2wrl3+q/uz95fTrzWrsGnbt7LrYesuG+cazzZDNzXBiBHH7KoCEK8LPD4AvlQAQXABgeAwApdtObrZbkPDlAwG/HSFp6D2iCxmJEkK9Q5dgPLF82CmKUlwgpTzlGtUgvpgQRb2XRowWQztL101/iSGTMYzJkdmQxYk1hC2D/SJHC+cw1yIPjleQT5ffSyBRsFDolvCkyC8xDnEtCW/JNKkq6UGZr3Ks8toKJMVspQblIZWPagR1cQ2jPd6ah7QKtK/rDOi+0dswYDWUNjIwdjIJMk0wO2Z+waLO8s7efqtJ63mbb3aQPd6BxZHTicdZwEXEVdJN3l19n76HuaeDF4kY5n2I9JdPsW+DX7f/ZMBSIEUQb7BaiF1oWFhWeMX+jogXkavRrDFKsfZx+w/kxdcfHEz4dIg2SSHZISUutSitI30+A39E4ahrZmpWVfZIztox4VyrvAPHy088OvnpNE2+3BmHs3Hnigo6Ct+cJ1xQKna/mFZypXSo7EcF5yXdSt/LR6ouX+mtfl2zWcdaL3vVuMG9MeJa5vULN67ebG2619xz617L7du1rQV3UtpId3XaWdrfddzqTLln3IXretCd0aPbs9p7/X5QH3/f5IPjDy368f1Dj/IHXAe5B2cflw/5DYsOL4xcGQ18Iv7k/Vj1eNCE5MSHp/WT+6cUp1aetT5PeWH0kvBydLpgxmOWf3bh1Y3XR+Y85zXfCLylXUC/Q7ynXOT4oPLR7dORpZbP374qfotbbvuBXbH5WfRrfk16PXqjZXNz2/4C0FWEC5IO2YhyQ1OiazHO8K2mnoKIY8U9pEyn0sOj8fcIh6lNaahpJmhL6YLpVRiwDM8Z+5l6mNtZ7rA2s11jv8pRw1nJVc5dxlPGW8pXwl8qUC5YKVQlXCvSIHpdrEW8Q6Jb8oHUsPSEzHPZF3LP5Z8pTCqOKz1RHlEZVH2g1q3eoXF7z3XNWq1y7QKdXN00vVj9QIN9hnuNdIzlTHhNac2A2ZL5M4tuy5q9J60OWnvbmNrK2rHZQ/YLDsOOt50qnHNd4l193azc9+wT8WDwhDw/ek0R+7ybSBU+J33T/VL8UwPSyGmBqUFpwakhaaFpYanhqftTI1IjU6NSopNjkmOT4pIOHIpPPJiQkJB48FB80oHkONg7ctMq0lsPj2a8P4rMZM+SzzbJ8for9lhObnley/HHJ+ZPrp2myxc5o3nW5pxfQULh8aLy8y0XBotfXfxRii/jK1euMLvkURkBe0jhlbrqjprR2jd1v67iG7gbZa7pXre9QboZ2ZTefOpWBRzBulpH7rxqe3f3cXttR1an/z2DLt6ute6Jnmu9x+6T+/QfcD34/nCwv/JR0oDjoNRj1OPJoYbhjBH3Ubkn6CdTYw3jWRPkp+aT8lM8zxie07xgeMk3rTHjNXvy1eic6HzOW7CQ+Z5/8dHHzCWbL6LfqJZXfnz6+W71w/rXbftLgC7IHJpAuCE+IIOQK6hUNCu6FKOEeQjfaNcpCnFauGnKI1TyVC/x2YQ9hEXq8zS2tFS03XTH6D0Z5BhRjKNMFcxxLJasPKzLbA/YSzjiOK24RLkh7kmea7y5fIH8RgICAhvwPapZOF8kStRaTFRsTXxIokLygJSlNJ/0Z5kO2eNyXvLS8j8VOuH4YKfMqjylUqxKVONXm1Ev1vDYw7FnXPOklpU2QXtYp0CXpCep91X/tkG6oYURo9GUcRkcL+RNf5q1mx+xsLJkhu8TpVZka2nrbzYttkl2hvaU9gMOxx3tnVicJp0vuHi7irp+dLvpnrzPzIPZ4zV8D0gnOnlLkhCkSZ/rvnl+If7mARJkKvKHwMdB14PzQ2JDncPUwznC1/e/jOiILIvKiCbHWMbKxTHHrR6YjX9wsDGhMPHwofAk92TTFOVUgTT6dCj98+H5jLkjC0c/Zn7J+p79K2fjGCIXk4c7TjhBe5LxFMtp9nzuM3xnBc+JFIgXShXJnVe8oFKscVGrRLfUvIxUnlJRfKmtcvLyyhXmasUam9qQuqz6yqtdDdONa9dZbijctGoKbD58q6Sl9fZY6+c2/F3hdp2OfZ0H753pquvu6Xne+62P5oHMQ4f+w4/aBjGPPYd6R8xHZ8eKJmIn459deombqXl95s3Q++hPud90ftZs2X/nG91WwSgDUKENBwT43LArBaCsFc4zVeHzowIAawIA9moAYR8PoBfNAHI59+f8gODEkwLQwhmnEFDY/s4RBFLhXPIGGAKfIBpIDrKH4uEc8AG0jOBA6CECEScRbYh3SFakMTIWWYV8hqJFGaES4ZxsCc7DAuDcaw4jhAnAVGM+YZWwidgeCloKd4oqih84E1wR7gulKWUp5TqVK1UznhUfj39BMCDUUDNTp1B/ovGkGaY1or1Dp0zXQC9NX8cgw3CNUY2xk8mcaYLZn3mFJY9VnLWbzZsdgr1Uj2OOM4tLlmuMO4lHlGeE9xCfBN9T/qMCagLvBM8L2QhjhdtEYkRlRRfFqsT9JUQk3knWSkVKq8kgZPplz8r5yCsoIBVGFS8pxStbqwirbKiOqzWqH9MI2mOmKa6F1/qoPaLTrHtRL1M/ysDL0NJI31jLRM1U0UzOXNZC1lJur7yVsrWGja6tqZ2dvadDiGOiU55zhUur67jb8j5mD3VPktcxYpv3Fx9RX5LfRf+XZO5AUlBtCAh1C7u7XyqiIko8+nasywFM/L2EvEPBye6pbun+GelHa7Ke/8Wa63i88OTw6ZWzvAVWRRkXukooymwqSit/XLGraaxnaki49uqmVfPt22J3zrVTdiZ0Lfce6tvs3z8wPCQwQnySO17z9NbU9eelL5Nn7F9xv345X/DWamHzfc0H50+opbovzt9Qyw0/iD8Zf/WtpW3obscPCKABFWAEvEAG6MLWDwFHQBnoALMQGpKAbKEEOPsfR2AQcnBun41oQSwieZD2yGxkF3IDpY6KRTWhVtAa6CR0N4aAccSUwlbXxP6FnaZQpMikmMFp4M7hflK6UbZTiVDlUv3CB+AnCGaENmpl6noaSZpqWinaRjp1ui56G/oZhkhGCsYSJg3Y2nFwhnmfNYZNiG2C/S8OQ44Nzttc8dwa3Bs8Xbw5fI78AvyfBe4J5gsFCeuLcIn8En0qdlv8gkSspJWUuDRW+q1Mn2yd3Cn5RAWyopOSsbKairSqsBqvOqcG+x4OTR4tIW0pHRVdAz17fT+DeMNcozzjUyZnTS+YVZo3WLRZ9u99bvXZBm3Laadib+MQ7pjn1Og85rLuJuJusy/Jo95zhsjkbU467HPXd9VfIyCBfDcIFWwRcjp0Jlx2f0rESJQofCJNxakcyI9fSXBPvJckmXw2FZMWm/4+g3jkaaZ91lCO9V+juS550yfIpzTzhc8yFCALf57/Uvyp5EvZz0uoy0xXxGsM6nyuHmm8ev1lE90tk9vpd7rbqTrtuy70vOxjfmj4KGAwcSh9JOlJwLj+U8Jk37PoF4wvS2cEZwtfY+f85tveEhbs3p1+P/AB9VH5k/dSzuerX0a/fl2m/y71w3iF+PPgrxOrVWt318c23m3bHwHvfnrAB+99M+AD7/xS0AMWISZIFwqHSqExBB6hjYhG1CLeIoWRvsjLyEWUAioBdR/NjPZD38JQY3wxd7Ec2Hj4zqlFUY4j4A7iPlKSKJ9ROVON493ws4QQwhp1Ho0YTQ8tmY6O7g59GIMwwwxjKZM/szzzOksnaxabA7sQ+wrHAGcV1xFuMo8VryqfMD+LAF4QI4QURotQijKK8YkrSJhLkqUypWtlRmXX5IUVbBQPKVUrP1WlUFNR99U4vadbc1lbWMdZN1uvXf+7oaRRgPEVkw9mCuaJFn17Wa0CrdtsGe1C7HsdBZ1SnWdc9d0q9uE8wjzHiFreVT7Mvml+XwN8yb1BfMGJIVNhe8JLIrCRYVFTMaaxLQek4ssSOBLzkxiST6YypRUc5s+oOaqS2ZPtmPPuWHIe2/HGk7qnbucrnWk8J1twrUj5fGux/sVHpa5lCxXxlYTLZVc0qsdqI+vpr15rdLq2ceNSk3Xzekttq0cb/d2+jtR7e7q+9dTcD36g3A89Ghg8P0QeURhdHqub2DeJmip6LvyifJplJna2/zXrnPV82puKt3cXHr4bfH9/8c6Hko8Zn5yXRJe+fW74EvpV6OvjbweXBZfvfHf8vvQjZQW3cvwn+8/CX/S/slah1QOrc2uWazfWudYPry9s6G4UbHzdtNy8tGX/SD8F+e3jA8LrAYB+sbn5VRgA7AkA1o9vbq6Wbm6ul8HJxjMA2oN3/vfZPmtoASjq3UI9XU3J//3/y/8A49XTHhwd5QoAAAGbaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA1LjQuMCI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjczPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjc3PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CqQGdTUAAAlSSURBVHgB7Zx7UFx3Fce/u7zfyxsSEkIgQMLyCI/SPExr7R82Whtap1qmNW3TiZ1xWu2MOh2dOp04OsbWcbSdtDqNj7FaU8001ldrqkmakPIK7wAxLQnvhSU8AmEXCLuec5FkoYX9XXLvb/nj/v5gL3vPvfd3Pnt+v3vuOef+TOPj427o3GZnr6O3qxPr09KFrzQ7O4vm+loUFJcKH6OXoFmvE3ue1z44gPjEJM+vvG77+fkhKjraq5wMASmQJicmEBgYpFqfgIBAsEX5ukmB5Ha7MetSr+zMzIyv+SjXlwIpJDQUE+NXVStsH+gHDztfNymQ4hOS0N7SrErXKacDAYGBqo7RS1gKJFY2LDwcA/19Qnrw8KyprMDG9Ewheb2FpEBiJbKteWhuOIe+3u5ldeKJuurMScTExtHdLWZZWVk7TTL8pHlleF6qqjgFvmtttuYrt3g/P3+w5ThpeA309aD9fDPWpaYhd2sxTCbT/KE+/ZQKiTWdmZnGxfZWdF36iLYX3r2iLNHI3GxF0pq1PoWy+OLSIc13wOVyYWx0BE7HJN3B/BEeGYnQ0LD53avq02eQVhUFL52RNnF76ceq3m1AEvh5DEgGJAECAiKGJRmQBAgIiBiWZEASICAgYliSAUmAgICIYUkCkPwFZKSLTE9PK+Fef39/RERG+TxksiogDdkH0VhXi6b6OvT39SKagm0JSUkUY3JSkK4HHFXK2pKD/MJiZG+xUuZFbljXp1EAzse9ffRNfHTxv7j/S+UEIAfhEZEfs1yOVg7Y+lBx8gTOVVdi931l2HHHXdKSBD6BxJHId/56DKf+fRyP7NuPnNx80Jj6GJxP+sLhcBDYIxTBbMETX/s61qas+yQxTb+TDokjk7//zWHYBwbw9LeeRVBQ8IoU6qa0+csvHkT5o48rw3BFJxE8SCokjka+8rOfwEJh2vJH993yhHyNMsPPP/tN7N3/JKx5BYIqqxeT6gK89eYfYKZhpQUgVpXTVM/98CB+99ov0NezfBZGPZqbR0iD1NbSRJmSM/jqU8/csgXd7D4QSS7C/qe+gV//8pCSdfHcp9W2FEg8Uf+F7mKsjFmHtHX6pixYyG2oqjitFZcF55ECqa6mClNTU8jIzF5w8eX+cVK26fKQeOnUw489gb8dOwqe97RuUiDVVn2Az+95QFXfg8jNff4fLvzgHRcuCcDinB176B0fXlR1HRFh3SHxI0Yb+TSKLyTSo//LsNuUYjGhhcoHvvu2Gy/8y4XOK8tb1j337lE8dxWXERLV/bGkkzK1LvKYg0NCbnSo3ebG0YblFWZh+8TcISxZ1wPU97qxPc2N+wvMWGOZ2+f5Ny0jEyfee9fzK022dYc0OjKC5EVp6zEnFAtRqwHN/6joAM5ecqE0FXiwyIzkqJtnCY8Ix+jw8M0vNNrSfbhxKtvTirToN8PqGqGJfdHw43Q5FYBoXkKouyXNPZz2L2ATQD9NWAAPouXblMuE64uqCJMigDJyrndmmMkxXXi8k57r2N3ga2pZIac7pCiLBVfHxpTOz5fSFK434bVHvJf5HaC7W5ttDkR8uAn30XPwnZtM8FvC/icmxqnoIlTzUIr+kKLmZthrNAy4ckRN66bpJS7MhN1WN+7ONiHAC9fW5kZYYrQv/NId0rrUDTCbzWhva0Fx6XZhRg5yJr9cYsIdGSb4+y0aV0uc5b1//h05+do/6C5huEv0YgVfcxBtY0YG3jryBmjMCZ8hJAD4TBYDEjuEQyc8aedvLRI7QIWU7pC4LwVFJRghV6C5sUFF18RFebL+1asvU2wqiMoMc8UPFJSUAmnnnXeBJ/DDr7yEyWvXBLsmLnbi+LtU2duPuz+7e0VvHni7khRI/MrEPV/YA35E+fH3v6fpQyiHcf/8xuuUVYkkSJ/zpu+K9kuBxD3bsevTyNq8BYMUtj3wnW9jcvLWLaryzPv4+Ys/UuJT5XsfR1DwykLB3shJDd9yuPXggecwZLcrvsyTTz9DqSKr6iAcAz7y+m9R88FZRb97yx4gSy3zpuuK90uFxL0cHLDh0E9fUCyK/4+JjUX53n1I35S5rCW43S4MDdpx5tR/cJxu9fON56GyBx9SDXr+eJFP6ZC4U2wJhw+9pIRQPDuZkJiI7JxcxMbFK/CcDifGxobR3dlJbxPUL5jL/AMCUP6Vx3D7zl2ep9Bl2yeQWBO+bdfXVuPYn/6oDD812lnJYfziQw8jQeWLhmqu4SnrM0jzneA8XG1VJRrOVeNCa6tyB5zf5/kZFx9P+bUilNy+A+s3pHnu0n3b55A8NZymODjPWaMUXhmnh2IeUlwXwM9jcfEJnqJSt1cVJKmaq7iYND9JRZ9WnagBSeAnMSAZkAQICIgYlmRAEiAgIGJYkgFJgICAiGFJBiQBAgIihiUJQNI97ybQhxsiHD7hVDUvpDBFhe5cfhMUHIJgCssGh4TekJO9sSog2enJv5+W5+C1TMIoTxdNT/2hYeHEwo0rQ3YMDw0RNActqpCCZKrb5iU6ZDafRgGGCUBrM+fiTLDmFyLSEkXZXj8lIDdnSSYEUi6Nawi4CGJsZBhN9HoFLzXEa59wdZuM5hNIHK9uoXDsgK0Xt23fhUiqF7g6Nqqs+8avR/CaJjz0uJlMZtofhcTkNUhZv4HKkiMwMnwFNWdPY0N6hrJsh96gpENSIpG07A9nW7eWbIOD4t1tLY2w0VBLIhCJyWuVStoQWpJjbo6axPCVIdjoxRxedGrtulRkURw8iHJ5tVUVSokNL47HtUl6NamQuDK28vRJJdK4JbdAmYcaaquUuYYTAAxmucYWxvXgPEy3lpTSYnrJaDxXg+vXZ1BMYV29mlRITXU1SgybFbrc8SFam+qRV1iiDCM1CnbSseebGpBHywelUNVK9dn3FevjFXP0aNL8pEFbv/IuGwPqp3fYGFDJtk+pBsQQUjdmoPC2bfR+XA34vEWlO9Bx8QKujo7qwQhSIPHc0n6+Scl0cD1AU121cjdTu/akJwFeYyk7J4+GW7UydxVR7RPPbXo0KZBstMLWDMGJoaTjBYLFNUtqVi9dSnEuSeai1QutzYijxfVGyUXgO5/WTQqkvp4uZFLOn32d7s5LlP/XpoaI/Seeh7oudyjZXZ78+VpaN90hcaE7zxvs57BF8XpusRrm0PhdXS43ZPeAPXK+htbtf9LddMoKOB/NAAAAAElFTkSuQmCC\"","module.exports = __webpack_public_path__ + \"static/media/nondet-0.8af20a01.png\";","module.exports = __webpack_public_path__ + \"static/media/nondet-1.5e829d46.png\";","import Vector from '../tools/Vector';\nimport { TransitionDetail as TransitionDetailInfo } from './TransitionDetail';\nimport { Mode } from './Mode';\n\n// Many actions are specific to a particular part of the state (e.g. to nodes,\n// or arrows), and I've grouped these for easy access. However, a number of\n// actions are more general; these I've placed at the bottom of the file.\n\nexport interface Action {\n  type: string;\n  payload?: any;\n}\n\n// Node actions:\nexport const MOUSE_DOWN_NODE = 'MOUSE_DOWN_NODE';\nexport const mouseDownNode = (id: string): Action => ({\n  type: MOUSE_DOWN_NODE,\n  payload: { id },\n});\n\nexport const MOUSE_UP_NODE = 'MOUSE_UP_NODE';\nexport const mouseUpNode = (): Action => ({\n  type: MOUSE_UP_NODE,\n});\n\n// We have 2 actions related to adding a node instead of one: the first\n// indicates that the user is in the process of adding a node, but has not yet\n// fixed its placement on the screen; the second indicates that the node should\n// be added at a particular location -- where the user has clicked.\nexport const START_ADDING_NODE = 'START_ADDING_NODE';\nexport const startAddingNode = (): Action => ({\n  type: START_ADDING_NODE,\n});\n\nexport const ADD_NODE = 'ADD_NODE';\nexport const addNode = (pos: Vector): Action => ({\n  type: ADD_NODE,\n  payload: { pos },\n});\n\nexport const DELETE_SELECTED_NODES = 'DELETE_SELECTED_NODES';\nexport const deleteSelectedNodes = (): Action => ({\n  type: DELETE_SELECTED_NODES,\n});\n\nexport const MAKE_SELECTED_START_NODE = 'MAKE_SELECTED_START_NODE';\nexport const makeSelectedStartNode = (): Action => ({\n  type: MAKE_SELECTED_START_NODE,\n});\n\nexport const TOGGLE_SELECTED_FINAL_NODES = 'TOGGLE_SELECTED_FINAL_NODES';\nexport const toggleSelectedFinalNodes = (): Action => ({\n  type: TOGGLE_SELECTED_FINAL_NODES,\n});\n\nexport const SELECT_ALL_NODES = 'SELECT_ALL_NODES';\nexport const selectAllNodes = (): Action => ({\n  type: SELECT_ALL_NODES,\n});\n\n// Arrow actions:\n// We include the arrow's ID as part of the payload because when we create a new\n// arrow, we also create a control point and transition detail for it as well\n// (and these require the arrow's ID).\nexport const ADD_ARROW = 'ADD_ARROW';\nexport const addArrow = (start: string, end: string, id: string): Action => ({\n  type: ADD_ARROW,\n  payload: { start, end, id },\n});\n\n// Control point actions:\nexport const MOUSE_DOWN_CONTROL_POINT = 'MOUSE_DOWN_CONTROL_POINT';\nexport const mouseDownControlPoint = (id: string): Action => ({\n  type: MOUSE_DOWN_CONTROL_POINT,\n  payload: { id },\n});\n\nexport const MOUSE_UP_CONTROL_POINT = 'MOUSE_UP_CONTROL_POINT';\nexport const mouseUpControlPoint = (): Action => ({\n  type: MOUSE_UP_CONTROL_POINT,\n});\n\n// Transition-detail actions:\nexport const CHANGE_TRANSITION_DETAIL = 'CHANGE_TRANSITION_DETAIL';\nexport const changeTransitionDetail = (detail: TransitionDetailInfo): Action => ({\n  type: CHANGE_TRANSITION_DETAIL,\n  payload: { detail },\n});\n\nexport const ADD_TRANSITION_DETAIL = 'ADD_TRANSITION_DETAIL';\nexport const addTransitionDetail = (arrow: string): Action => ({\n  type: ADD_TRANSITION_DETAIL,\n  payload: { arrow },\n});\n\nexport const DELETE_TRANSITION_DETAIL = 'DELETE_TRANSITION_DETAIL';\nexport const deleteTransitionDetail = (id: string, arrow: string): Action => ({\n  type: DELETE_TRANSITION_DETAIL,\n  payload: { id, arrow },\n});\n\nexport const FOCUS_TRANSITION_DETAIL = 'FOCUS_TRANSIITON_DETAIL';\nexport const focusTransitionDetail = (id: string): Action => ({\n  type: FOCUS_TRANSITION_DETAIL,\n  payload: { id },\n});\n\nexport const BLUR_TRANSITION_DETAIL = 'BLUR_TRANSITION_DETAIL';\nexport const blurTransitionDetail = (id: string): Action => ({\n  type: BLUR_TRANSITION_DETAIL,\n  payload: { id },\n});\n\nexport const MARK_DUPLICATE_TRANSITIONS = 'MARK_DUPLICATE_TRANSITIONS';\nexport const markDuplicateTransitions = (ids: string[]): Action => ({\n  type: MARK_DUPLICATE_TRANSITIONS,\n  payload: { ids },\n});\n\n// Tape actions:\nexport const CHANGE_TAPE_CELL = 'CHANGE_TAPE_CELL';\nexport const changeTapeCell = (pos: number, value: string): Action => ({\n  type: CHANGE_TAPE_CELL,\n  payload: { pos, value },\n});\n\nexport const CLEAR_TAPE = 'CLEAR_TAPE';\nexport const clearTape = (): Action => ({\n  type: CLEAR_TAPE,\n});\n\nexport const UPDATE_SCROLL_LEFT = 'UPDATE_SCROLL_LEFT';\nexport const updateScrollLeft = (scrollLeft: number): Action => ({\n  type: UPDATE_SCROLL_LEFT,\n  payload: { scrollLeft },\n});\n\nexport const FOCUS_TAPE_CELL = 'FOCUS_TAPE_CELL';\nexport const focusTapeCell = (pos: number): Action => ({\n  type: FOCUS_TAPE_CELL,\n  payload: { pos },\n});\n\nexport const MOVE_TAPE = 'MOVE_TAPE';\nexport const moveTape = (direction: 'L' | 'R'): Action => ({\n  type: MOVE_TAPE,\n  payload: { direction },\n});\n\nexport const WRITE_TAPE_SYMBOL = 'WRITE_TAPE_SYMBOL';\nexport const writeTapeSymbol = (symbol: string): Action => ({\n  type: WRITE_TAPE_SYMBOL,\n  payload: { symbol },\n});\n\n// Canvas and UI actions:\nexport const MOUSE_DOWN_CANVAS = 'MOUSE_DOWN_CANVAS';\nexport const mouseDownCanvas = (pos: Vector): Action => ({\n  type: MOUSE_DOWN_CANVAS,\n  payload: { pos },\n});\n\nexport const MOUSE_UP_CANVAS = 'MOUSE_UP_CANVAS';\nexport const mouseUpCanvas = (): Action => ({\n  type: MOUSE_UP_CANVAS,\n});\n\nexport const MOUSE_MOVE_CANVAS = 'MOUSE_MOVE_CANVAS';\nexport const mouseMoveCanvas = (pos: Vector): Action => ({\n  type: MOUSE_MOVE_CANVAS,\n  payload: { pos },\n});\n\nexport const KEY_DOWN = 'KEY_DOWN';\nexport const keyDown = (key: string, event: React.KeyboardEvent): Action => ({\n  type: KEY_DOWN,\n  payload: { key, event },\n});\n\nexport const KEY_UP = 'KEY_UP';\nexport const keyUp = (key: string): Action => ({\n  type: KEY_UP,\n  payload: { key },\n});\n\n// General actions:\nexport const ADD_TRANSITION_BETWEEN_SELECTED = 'ADD_TRANSITION_BETWEEN_SELECTED';\nexport const addTransitionBetweenSelected = (): Action => ({\n  type: ADD_TRANSITION_BETWEEN_SELECTED,\n});\n\nexport const DELETE_ENTITIES = 'DELETE_ENTITIES';\nexport const deleteEntities = (nodes: string[], arrows: string[], controlPoints: string[], transitionDetails: string[]): Action => ({\n  type: DELETE_ENTITIES,\n  payload: { nodes, arrows, controlPoints, transitionDetails },\n});\n\nexport const UNDO = 'UNDO';\nexport const undo = (): Action => ({\n  type: UNDO,\n});\n\nexport const REDO = 'REDO';\nexport const redo = (): Action => ({\n  type: REDO,\n});\n\nexport const DISPLAY_MESSAGE = 'DISPLAY_MESSAGE';\nexport const displayMessage = (title: string, content?: string | JSX.Element): Action => ({\n  type: DISPLAY_MESSAGE,\n  payload: { title, content },\n});\n\nexport const DISMISS_MESSAGE = 'DISMISS_MESSAGE';\nexport const dismissMessage = (): Action => ({\n  type: DISMISS_MESSAGE,\n});\n\n// Simulation actions:\nexport const STEP_SIM = 'STEP_SIM';\nexport const stepSim = (): Action => ({\n  type: STEP_SIM,\n});\n\nexport const PLAY_SIM = 'PLAY_SIM';\nexport const playSim = (): Action => ({\n  type: PLAY_SIM,\n});\n\nexport const PAUSE_SIM = 'PAUSE_SIM';\nexport const pauseSim = (): Action => ({\n  type: PAUSE_SIM,\n});\n\nexport const RESET_RUNNING_SIM = 'RESET_RUNNING_SIM';\nexport const resetRunningSim = (): Action => ({\n  type: RESET_RUNNING_SIM,\n});\n\nexport const RESET_SIM = 'RESET_SIM';\nexport const resetSim = (): Action => ({\n  type: RESET_SIM,\n});\n\nexport const SET_SIM_INTERVAL_DIVISOR = 'SET_SIM_INTERVAL_DIVISOR';\nexport const setSimIntervalDivisor = (divisor: number): Action => ({\n  type: SET_SIM_INTERVAL_DIVISOR,\n  payload: { divisor },\n});\n\nexport const SET_CURRENT_NODE = 'SET_CURRENT_NODE';\nexport const setCurrentNode = (node: null | string): Action => ({\n  type: SET_CURRENT_NODE,\n  payload: { node },\n});\n\nexport const SET_TAPE_WRITING_STATUS = 'SET_TAPE_WRITING_STATUS';\nexport const setTapeWritingStatus = (isWriting: boolean): Action => ({\n  type: SET_TAPE_WRITING_STATUS,\n  payload: { isWriting },\n});\n\nexport const SET_GLOWING_NODE = 'SET_GLOWING_NODE';\nexport const setGlowingNode = (node: null | string): Action => ({\n  type: SET_GLOWING_NODE,\n  payload: { node },\n});\n\nexport const SET_FADE_IN_NODE = 'SET_FADE_IN_NODE';\nexport const setFadeInNode = (node: null | string): Action => ({\n  type: SET_FADE_IN_NODE,\n  payload: { node },\n});\n\nexport const SET_FADE_OUT_NODE = 'SET_FADE_OUT_NODE';\nexport const setFadeOutNode = (node: null | string): Action => ({\n  type: SET_FADE_OUT_NODE,\n  payload: { node },\n});\n\nexport const SET_GLOWING_ARROW = 'SET_GLOWING_ARROW';\nexport const setGlowingArrow = (arrow: null | string): Action => ({\n  type: SET_GLOWING_ARROW,\n  payload: { arrow },\n});\n\nexport const SET_GLOWING_CONTROL_POINT = 'SET_GLOWING_CONTROL_POINT';\nexport const setGlowingControlPoint = (controlPoint: null | string): Action => ({\n  type: SET_GLOWING_CONTROL_POINT,\n  payload: { controlPoint },\n});\n\nexport const SET_GLOWING_TRANSITION_DETAIL = 'SET_GLOWING_TRANSITION_DETAIL';\nexport const setGlowingTransitionDetail = (transitionDetail: null | string): Action => ({\n  type: SET_GLOWING_TRANSITION_DETAIL,\n  payload: { transitionDetail },\n});\n\nexport const HALT_ACCEPT = 'HALT_ACCEPT';\nexport const haltAccept = (): Action => ({\n  type: HALT_ACCEPT,\n});\n\nexport const HALT_REJECT = 'HALT_REJECT';\nexport const haltReject = (): Action => ({\n  type: HALT_REJECT,\n});\n\n// Mode actions:\nexport const SWITCH_MODE = 'SWITCH_MODE';\nexport const switchMode = (mode: Mode): Action => ({\n  type: SWITCH_MODE,\n  payload: { mode },\n});\n\n// Machine metadata actions:\nexport const CHANGE_MACHINE_NAME = 'CHANGE_MACHINE_NAME';\nexport const changeMachineName = (name: string): Action => ({\n  type: CHANGE_MACHINE_NAME,\n  payload: { name },\n});\n\n// New, Save, Load, Download, and Upload actions:\nexport const NEW_MACHINE = 'NEW_MACHINE';\nexport const newMachine = (): Action => ({\n  type: NEW_MACHINE,\n});\n\nexport const SAVE_SNAPSHOT = 'SAVE_SNAPSHOT';\nexport const saveSnapshot = (): Action => ({\n  type: SAVE_SNAPSHOT,\n});\n\nexport const LOAD_SNAPSHOT = 'LOAD_SNAPSHOT';\nexport const loadSnapshot = (): Action => ({\n  type: LOAD_SNAPSHOT,\n});\n\nexport const INSTALL_SNAPSHOT = 'INSTALL_SNAPSHOT';\nexport const installSnapshot = (snapshot: any, undoable: boolean): Action => ({\n  type: INSTALL_SNAPSHOT,\n  payload: { snapshot, undoable },\n});\n\nexport const DOWNLOAD_MACHINE = 'DOWNLOAD_MACHINE';\nexport const downloadMachine = (): Action => ({\n  type: DOWNLOAD_MACHINE,\n});\n\nexport const UPLOAD_MACHINE = 'UPLOAD_MACHINE';\nexport const uploadMachine = (): Action => ({\n  type: UPLOAD_MACHINE,\n});\n","import _ from 'lodash';\nimport { State } from './state';\n\n// This file contains state-management functions and type definitions that are\n// general-purpose enough to be useful in a number of places.\n\n// In many cases, we choose to maintain not one but TWO intances of some part of\n// the state. Here is an example illustrating why: suppose we move a node from\n// one position to another. On the one hand, we need the current node position\n// to be maintained in the state so that we can display it properly. On the\n// other hand, we don't want to replace its previous (pre-move) position,\n// because this information is useful for undo/redo purposes. Our solution is to\n// maintain a \"work-in-progress\" (wip) state for these transient changes, and a\n// \"committed\" state that always contains the last meaningful snapshot of the\n// state.\nexport interface Transient<A> {\n  wip: null | A;\n  committed: A;\n}\n\n// The wip state, if it is non-null, is always more up-to-date than the last\n// commit. If the wip state is nonexistent, we simply fall back on the last\n// commit.\nexport const currentLatest = <A>(state: Transient<A>): A => (\n  state.wip || state.committed\n);\n\n// This interface represents any type that has a string ID (e.g. any of the\n// \"entities\" in our application state).\nexport interface IDAble {\n  id: string;\n}\n\n// A \"snapshot\" is a record of all of the entities in play.\nexport const getSnapshot = (state: State) => _.get(state, 'entities');\n\n// There are several situations in which we wish to revert to a previous\n// snapshot of the state (e.g. undo/redo, upload). Doing so is fairly\n// straightforward, but we must mindful to throw away any \"WIP\" states.\nexport const revertToSnapshot = (state: State, snapshot: any): State => {\n  const toplevelIteratee = (value: any) => (\n    _.mapValues(value, (value, key) => (\n      key === 'wip' ? null : value\n    ))\n  );\n\n  return {\n    ...state,\n    entities: _.mapValues(snapshot, toplevelIteratee),\n  } as State;\n};\n","// Much of the work in rendering the components in this app can be reduced by\n// expressing positions and operations in vector form. This class provides all\n// the functionality we need in this regard in a self-contained package.\n\nclass Vector {\n  constructor(public x: number, public y: number) {}\n\n  static from({ x, y }: SerializableVector): Vector {\n    return new Vector(x, y);\n  }\n\n  // Return the length of this vector.\n  magnitude() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  // Return a unit vector that shares this vector's direction\n  normalize() {\n    const len = this.magnitude();\n    if (len === 0) {\n      throw new Error('Cannot normalize 0 vector');\n    }\n    return new Vector(this.x / len, this.y / len);\n  }\n\n  // Return a vector perpendicular to this vector (with the same length). NOTE:\n  // this effectively rotates the vector 90 deg clockwise.\n  perp() {\n    return new Vector(-this.y, this.x);\n  }\n\n  // Return the sum of this vector and the input.\n  plus(v: Vector) {\n    return new Vector(this.x + v.x, this.y + v.y);\n  }\n\n  // Return the difference between this vector and the input.\n  minus(v: Vector) {\n    return this.plus(v.scale(-1));\n  }\n\n  // Scale this vector by the specified amount.\n  scale(factor: number) {\n    return new Vector(factor * this.x, factor * this.y);\n  }\n\n  // Return this vector's angle.\n  angle() {\n    return Math.atan2(this.y, this.x);\n  }\n\n  // Project this vector onto the input vector.\n  project(v: Vector) {\n    return v.scale(this.dot(v) / v.dot(v));\n  }\n\n  // Return the dot product of this vector and the input vector.\n  dot(v: Vector) {\n    return this.x * v.x + this.y * v.y;\n  }\n}\n\n// A RawVector contains the same data as a Vector (i.e. an x and y coordinate),\n// but has none of the associated methods. It is suitable for serialization, and\n// for this reason, we use it everywhere we might need a serializable vector.\nexport interface SerializableVector {\n  x: number;\n  y: number;\n}\n\nexport default Vector;\n","// This file contains a number of functions that are useful for performing\n// various tasks, and are general enough not to be included alongside any of\n// their uses.\n\n// If x is a member of the Array, remove it; otherwise, add it.\nexport const mod2Include = <A>(x: A, xs: A[]): A[] => (\n  xs.includes(x) ? xs.filter(y => y !== x) : [...xs, x]\n);\n\n// X xOr Y is true if either X or Y is true, but not both.\nexport const xOr = (x: boolean, y: boolean): boolean => (\n  (x || y) && !(x && y)\n);\n\n// repeat(what, times) constructs an Array containing \"what\" repeated \"times\"\n// times.\nexport const repeat = <A>(what: A, times: number): A[] => {\n  const res = new Array(times);\n  for (let i = 0; i < times; i++) {\n    res[i] = what;\n  }\n  return res;\n};\n","import { State } from './state';\nimport { Action } from './actions';\nimport * as A from './actions';\n\nexport interface ModeState {\n  mode: Mode;\n}\n\nexport type Mode = 'EDIT' | 'SIM';\n\nexport const Modes: { [key: string]: Mode } = {\n  EDIT: 'EDIT',\n  SIM: 'SIM',\n};\n\nexport const initModeState: ModeState = {\n  mode: Modes.EDIT,\n};\n\n// Test if we are currently in edit mode:\nexport const isInEditMode = (state: State): boolean => state.mode.mode === Modes.EDIT;\n\nexport const modeReducer = (state: State, action: Action): ModeState => {\n  switch (action.type) {\n    case A.SWITCH_MODE:\n      return switchMode(state, action.payload.mode);\n    default:\n      return state.mode;\n  }\n};\n\nconst switchMode = (state: State, mode: Mode): ModeState => ({\n  ...state.mode,\n  mode,\n});\n","import _ from 'lodash';\nimport { State } from './state';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport Vector from '../tools/Vector';\nimport { isInEditMode } from './Mode';\n\n// The UI state is fairly self-explanatory: it consists of miscellaneous tidbits\n// of information regarding where the mouse is, what keys are pressed, etc.\n\nexport interface UIState {\n  mousePos: Vector;\n  keysDown: string[];\n  isMouseDownNode: boolean;\n  isMouseDownControlPoint: boolean;\n  isAddingNode: boolean;\n  wasMouseReleasedOverNode: boolean;\n  wasMouseDragged: boolean;\n}\n\nexport const initUIState: UIState = {\n  mousePos: new Vector(0, 0),\n  keysDown: [],\n  isMouseDownNode: false,\n  isMouseDownControlPoint: false,\n  isAddingNode: false,\n  wasMouseReleasedOverNode: false,\n  wasMouseDragged: false,\n};\n\n// Return the current mouse position.\nexport const mousePos = (state: State): Vector => state.ui.mousePos;\n\n// Test if we are currently in \"multiselect\" mode.\nexport const isMultiselect = (state: State): boolean => state.ui.keysDown.includes('Shift');\n\n// Test if the mouse is currently pressed over a node.\nexport const isMouseDownNode = (state: State): boolean => state.ui.isMouseDownNode;\n\n// Test if the mouse is current pressed over a control point.\nexport const isMouseDownControlPoint = (state: State): boolean => state.ui.isMouseDownControlPoint;\n\n// Test if we are in the process of adding a node.\nexport const isAddingNode = (state: State): boolean => state.ui.isAddingNode;\n\nexport const wasMouseReleasedOverNode = (state: State): boolean => state.ui.wasMouseReleasedOverNode;\n\nexport const wasMouseDragged = (state: State): boolean => state.ui.wasMouseDragged;\n\nexport const uiReducer = (state: State, action: Action): UIState => {\n  if (isInEditMode(state)) {\n    switch (action.type) {\n      case A.KEY_DOWN:\n        return keyDown(state, action.payload.key);\n      case A.KEY_UP:\n        return keyUp(state, action.payload.key);\n      case A.MOUSE_DOWN_NODE:\n        return mouseDownNode(state);\n      case A.MOUSE_UP_NODE:\n        return mouseUpNode(state);\n      case A.MOUSE_DOWN_CONTROL_POINT:\n        return mouseDownControlPoint(state);\n      case A.MOUSE_UP_CONTROL_POINT:\n        return mouseUpControlPoint(state);\n      case A.MOUSE_DOWN_CANVAS:\n        return mouseDownCanvas(state);\n      case A.MOUSE_UP_CANVAS:\n        return mouseUpCanvas(state);\n      case A.START_ADDING_NODE:\n        return startAddingNode(state);\n      case A.ADD_NODE:\n        return addNode(state);\n      case A.MOUSE_MOVE_CANVAS:\n        return mouseMoveCanvas(state, action.payload.pos);\n      default:\n        return state.ui;\n    }\n  }\n  else {\n    return state.ui;\n  }\n};\n\nconst keyDown = (state: State, key: string): UIState => ({\n  ...state.ui,\n  keysDown: _.uniq([...state.ui.keysDown, key]),\n});\n\nconst keyUp = (state: State, key: string): UIState => ({\n  ...state.ui,\n  keysDown: state.ui.keysDown.filter(k => k !== key),\n});\n\nconst mouseDownNode = (state: State): UIState => ({\n  ...state.ui,\n  isMouseDownNode: true,\n});\n\nconst mouseUpNode = (state: State): UIState => ({\n  ...state.ui,\n  isMouseDownNode: false,\n  wasMouseReleasedOverNode: true,\n});\n\nconst mouseDownControlPoint = (state: State): UIState => ({\n  ...state.ui,\n  isMouseDownControlPoint: true,\n});\n\nconst mouseUpControlPoint = (state: State): UIState => ({\n  ...state.ui,\n  isMouseDownControlPoint: false,\n});\n\nconst mouseDownCanvas = (state: State): UIState => ({\n  ...state.ui,\n  wasMouseDragged: false,\n});\n\nconst mouseUpCanvas = (state: State): UIState => ({\n  ...state.ui,\n  isMouseDownNode: false,\n  isMouseDownControlPoint: false,\n  wasMouseReleasedOverNode: false,\n});\n\nconst startAddingNode = (state: State): UIState => ({\n  ...state.ui,\n  isAddingNode: true,\n});\n\nconst addNode = (state: State): UIState => ({\n  ...state.ui,\n  isAddingNode: false,\n  wasMouseReleasedOverNode: true,\n});\n\nconst mouseMoveCanvas = (state: State, pos: Vector): UIState => ({\n  ...state.ui,\n  mousePos: pos,\n  wasMouseDragged: true,\n});\n","import _ from 'lodash';\nimport uuid from 'uuid/v4';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport { Transient, currentLatest } from './auxiliary';\nimport { State } from './state';\nimport Vector, { SerializableVector } from '../tools/Vector';\nimport { mod2Include } from '../tools/auxiliary';\nimport { isMultiselect, isMouseDownNode, wasMouseReleasedOverNode } from './UI';\nimport { isInEditMode } from './Mode';\n\n// A node represents a machine state in the TM formalism. Each node is\n// draggable, and may come in several different varieties (it may be the start\n// node, or an accepting/final node).\n\nexport interface NodeState extends Transient<NodeInfo> {}\n\n// The \"selected\" and \"offsets\" properties are used to store information about\n// selected nodes immediately before and during a move. The \"startNode\"\n// corresponds to the start state in the TM formalism.\nexport interface NodeInfo {\n  byId: { [key: string]: Node };\n  selected: string[];\n  offsets: { [key: string]: Vector };\n  startNode: null | string;\n}\n\nexport interface Node {\n  id: string;\n  pos: SerializableVector;\n  isFinal: boolean;\n}\n\nexport const initNodeState: NodeState = {\n  wip: null,\n  committed: {\n    byId: {},\n    selected: [],\n    offsets: {},\n    startNode: null,\n  },\n};\n\n// Return an array containing all nodes in existence.\nexport const allNodes = (state: State): Node[] => (\n  Object.values(currentLatest(state.entities.nodes).byId)\n);\n\n// Return the node with the given ID, if one exists.\nexport const nodeById = (state: State, id: string): Node => {\n  const node = allNodes(state).find(n => n.id === id);\n  if (!node) {\n    throw new Error(`No Node with ID \"${id}\"`);\n  }\n  return node;\n};\n\n// Check if the given node is currently selected.\nexport const isNodeSelected = (state: State, id: string): boolean => (\n  currentLatest(state.entities.nodes).selected.includes(id)\n);\n\n// Check if the given node is final (\"accepting\").\nexport const isNodeFinal = (state: State, id: string): boolean => (\n  currentLatest(state.entities.nodes).byId[id].isFinal\n);\n\n// Return an array containing the IDs of all selected nodes.\nexport const selectedNodes = (state: State): string[] => (\n  currentLatest(state.entities.nodes).selected\n);\n\n// Test if the given node is the start node.\nexport const isStartNode = (state: State, id: string): boolean => {\n  const { startNode } = currentLatest(state.entities.nodes);\n  return (startNode !== null) && startNode === id;\n};\n\n// Test if a node has been distinguished as the start state.\nexport const hasStartNode = (state: State): boolean => (\n  currentLatest(state.entities.nodes).startNode !== null\n);\n\nexport const startNode = (state: State): string => {\n  const start = currentLatest(state.entities.nodes).startNode;\n  if (start === null) {\n    throw new Error('No start node has been distinguished.');\n  }\n  return start;\n};\n\nexport const nodesReducer = (state: State, action: Action): NodeState => {\n  if (isInEditMode(state)) {\n    switch (action.type) {\n      // These operations affect the non-positional attributes of a node.\n      case A.ADD_NODE:\n        return addNode(state, action.payload.pos);\n      case A.ADD_ARROW:\n        return addArrow(state, action.payload.start, action.payload.end);\n      case A.DELETE_ENTITIES:\n        return deleteEntities(state, action.payload.nodes);\n      case A.MAKE_SELECTED_START_NODE:\n        return makeStartNode(state);\n      case A.TOGGLE_SELECTED_FINAL_NODES:\n        return toggleFinalNodes(state);\n      case A.SELECT_ALL_NODES:\n        return selectAllNodes(state);\n\n      // These operations deal with movement.\n      case A.MOUSE_DOWN_NODE:\n        return mouseDownNode(state, action.payload.id);\n      case A.MOUSE_UP_NODE:\n        return mouseUpNode(state);\n      case A.MOUSE_DOWN_CANVAS:\n        return mouseDownCanvas(state, action.payload.pos);\n      case A.MOUSE_UP_CANVAS:\n        return mouseUpCanvas(state);\n      case A.MOUSE_MOVE_CANVAS:\n        return mouseMoveCanvas(state, action.payload.pos);\n      default:\n        return state.entities.nodes;\n    }\n  }\n  else {\n    return state.entities.nodes;\n  }\n};\n\n// When a new node is added, we revert to the last committed state, and\n// incorporate a fresh, non-final, mnemonic-free node.\nconst addNode = (state: State, pos: Vector): NodeState => {\n  const id = uuid();\n  const node = { id, pos, mnemonic: '', isFinal: false };\n  return {\n    wip: null,\n    committed: _.mergeWith({}, state.entities.nodes.committed, {\n      byId: {\n        [id]: node,\n      },\n    // We unselect all currently selected nodes, and select the new node:\n    }, (_1, _2, key) => key === 'selected' ? [id] : undefined),\n  };\n};\n\n// Whenever an arrow is added between two distinct nodes, we deselect the nodes.\n// This seems to be a nicer experience than keeping the nodes selected.\nconst addArrow = (state: State, start: string, end: string): NodeState => ({\n  wip: null,\n  committed: {\n    ...state.entities.nodes.committed,\n    selected: start !== end\n      ? []\n      : state.entities.nodes.committed.selected,\n  },\n});\n\nconst deleteEntities = (state: State, ids: string[]): NodeState => {\n  const { committed } = state.entities.nodes;\n  return {\n    wip: null,\n    committed: {\n      ...committed,\n      byId: _.omit(committed.byId, ids),\n      selected: [],\n      startNode: committed.startNode && ids.includes(committed.startNode)\n        ? null\n        : committed.startNode,\n    },\n  };\n};\n\nconst makeStartNode = (state: State): NodeState => ({\n  wip: null,\n  committed: _.merge({}, state.entities.nodes.committed, {\n    startNode: state.entities.nodes.committed.selected[0],\n  }),\n});\n\n// Toggling the \"final\" state of a set of nodes works like this: if ANY of the\n// selected nodes is currently a final node, we change all of the nodes to be\n// NON-final. Otherwise, we change all of them to be final. This correctly\n// subsumes the expected behavior for a single node as well.\nconst toggleFinalNodes = (state: State): NodeState => {\n  const selected = selectedNodes(state).map(id => nodeById(state, id));\n  const atLeastOneFinal = selected.some(node => node.isFinal);\n  const updated = selected.reduce((acc, x) => ({\n    ...acc,\n    [x.id]: { ...x, isFinal: !atLeastOneFinal },\n  }), {});\n\n  return {\n    wip: null,\n    committed: _.merge({}, state.entities.nodes.committed, {\n      byId: {\n        ...updated,\n      },\n    }),\n  };\n};\n\nconst selectAllNodes = (state: State): NodeState => ({\n  wip: null,\n  committed: {\n    ...state.entities.nodes.committed,\n    selected: Object.keys(state.entities.nodes.committed.byId),\n  },\n});\n\n// When the user presses the mouse over a node, we update the selection as\n// follows: if we are in \"multiselect\" mode, we add the node to the current\n// selection if it is not a member, and remove it if it is; otherwise, if the\n// current selection includes the node, we keep the current selection, and if it\n// doesn't, we throw out the current selection in favor of the clicked node.\n// This may seem complicated, or contrived, but it results in a fairly intuitive\n// behavior.\nconst mouseDownNode = (state: State, id: string): NodeState => {\n  const { nodes } = state.entities;\n  const { selected } = nodes.committed;\n  return {\n    wip: null,\n    committed: {\n      ...nodes.committed,\n      selected: isMultiselect(state)\n        ? mod2Include(id, selected)\n        : selected.includes(id) ? selected : [id],\n    },\n  };\n};\n\n// When the user releases the mouse over a Node, we replace the committed state\n// with the wip state (to account for any movement that may have occurred). We\n// also clear any offsets that may have been computed in preparation for a move.\nconst mouseUpNode = (state: State): NodeState => ({\n  wip: null,\n  committed: {\n    ...currentLatest(state.entities.nodes),\n    offsets: {},\n  },\n});\n\n// If the user has pressed the mouse over a node, this press is also received by\n// the canvas. In this case, we prepare for any movement by computing offsets\n// for each of the selected nodes.\nconst mouseDownCanvas = (state: State, mousePos: Vector): NodeState => {\n  if (!isMouseDownNode(state)) return state.entities.nodes;\n\n  const { nodes } = state.entities;\n  const offsets = nodes.committed.selected.reduce((acc, nodeId) => {\n    const node = nodes.committed.byId[nodeId];\n    return {\n      ...acc,\n      [nodeId]: Vector.from(node.pos).minus(mousePos),\n    };\n  }, {});\n\n  return {\n    ...nodes,\n    wip: {\n      ...nodes.committed,\n      offsets,\n    },\n  };\n};\n\n// When the mouse is released over the canvas, we deselect any selected nodes as\n// long as we are node in multiselect mode, and revert to the last committed\n// state. When selecting multiple nodes, it is easy to miss a node and click the\n// canvas instead; in order to avoid an irritating deselection of all currently\n// selected nodes, we simply keep what we have so far in this case.\nconst mouseUpCanvas = (state: State): NodeState => (\n  wasMouseReleasedOverNode(state)\n  ? state.entities.nodes\n  : {\n    wip: null,\n    committed: {\n      ...state.entities.nodes.committed,\n      selected: isMultiselect(state) ? state.entities.nodes.committed.selected : [],\n    },\n  }\n);\n\n// If the mouse is moved while it is down over a node, we update all of the\n// selected nodes in the WIP state using the offsets computed when the mouse was\n// initially pressed down.\nconst mouseMoveCanvas = (state: State, mousePos: Vector): NodeState => {\n  const { nodes } = state.entities;\n\n  if (!isMouseDownNode(state) || !nodes.wip) return nodes;\n\n  // We computed each offset as the difference between the node's position and\n  // the mouse position (i.e. offset = node - mouse). Thus, to compute the new\n  // node position, we add the mouse position and the offset:\n  const moved = Object.keys(nodes.wip.offsets).reduce((acc, id) => {\n    const node = nodes.wip!.byId[id];\n    const updatedPos = mousePos.plus(nodes.wip!.offsets[id]);\n    return {\n      ...acc,\n      [id]: { ...node, pos: updatedPos },\n    };\n  }, {});\n\n  return _.merge({}, nodes, {\n    wip: {\n      byId: {\n        ...moved,\n      },\n    },\n  });\n};\n","import _ from 'lodash';\nimport { State } from './state';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport { isInEditMode } from './Mode';\n\n// An arrow represents one or more transitions between two states in the\n// machine. Therefore, we can describe them using the IDs of their start and end\n// nodes (along with their own unique ID). For the most part, arrows are\n// passive: they are drawn entirely according to the positions of their start\n// and end nodes, along with their control point.\n\nexport interface ArrowState {\n  byId: { [key: string]: Arrow };\n}\n\nexport interface Arrow {\n  id: string;\n  start: string;\n  end: string;\n}\n\nexport const initArrowState: ArrowState = {\n  byId: {},\n};\n\n// Return an array containing all arrows in existence.\nexport const allArrows = (state: State): Arrow[] => (\n  Object.values(state.entities.arrows.byId)\n);\n\n// Return the arrow with the given ID.\nexport const arrowById = (state: State, id: string): Arrow => {\n  const arrow = state.entities.arrows.byId[id];\n  if (!arrow) {\n    throw new Error(`No Arrow with ID \"${id}\"`);\n  }\n  return arrow;\n};\n\n// Return an array containing all arrows associated with the given node (i.e.\n// arrows that either start or end at the node).\nexport const arrowsForNode = (state: State, nodeId: string): Arrow[] => (\n  allArrows(state).filter(arrow => arrow.start === nodeId || arrow.end === nodeId)\n);\n\n// If an arrow exists joining the two given nodes, return it; otherwise return\n// null.\nexport const arrowForEndpoints = (state: State, startId: string, endId: string): null | Arrow => {\n  const arrow = allArrows(state).find(a => a.start === startId && a.end === endId);\n  return arrow || null;\n};\n\n// Return an array containing all arrows starting at the given node.\nexport const arrowsForStart = (state: State, nodeId: string): Arrow[] => (\n  allArrows(state).filter(arrow => arrow.start === nodeId)\n);\n\nexport const arrowsReducer = (state: State, action: Action): ArrowState => {\n  if (isInEditMode(state)) {\n    switch (action.type) {\n      case A.ADD_ARROW:\n        return addArrow(state, action.payload.start, action.payload.end, action.payload.id);\n      case A.DELETE_ENTITIES:\n        return deleteEntities(state, action.payload.arrows);\n      default:\n        return state.entities.arrows;\n    }\n  }\n  else {\n    return state.entities.arrows;\n  }\n};\n\nconst addArrow = (state: State, start: string, end: string, id: string): ArrowState => (\n  _.merge({}, state.entities.arrows, {\n    byId: {\n      [id]: { start, end, id },\n    },\n  })\n);\n\nconst deleteEntities = (state: State, ids: string[]): ArrowState => ({\n  ...state.entities.arrows,\n  byId: _.omit(state.entities.arrows.byId, ids)\n});\n","import _ from 'lodash';\nimport uuid from 'uuid/v4';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport { Transient, currentLatest } from './auxiliary';\nimport { arrowById } from './Arrow';\nimport { nodeById, selectedNodes } from './Node';\nimport { isMouseDownNode, isMouseDownControlPoint } from './UI';\nimport { State } from './state';\nimport Vector, { SerializableVector } from '../tools/Vector';\nimport { xOr } from '../tools/auxiliary';\nimport { isInEditMode } from './Mode';\n\n// A control point is a draggable handle associated with a particular arrow. It\n// is used to control the curve of the arrow in order to create aesthetically\n// pleasing machine layouts. Despite (or more likely, because of) the fact that\n// control points exist purely for display purposes, their management involves\n// quite a bit of computation. This is mainly due to the fact that they are\n// draggable, and also that each time a node is moved, all of the control points\n// associated with the arrows connected to the node are moved as well.\n\nexport interface ControlPointState extends Transient<ControlPointInfo> {}\n\n// A few of these items require explanation: the \"fullOffsets\" and \"halfOffsets\"\n// properties are populated when a *NODE* is moved: it turns out that when a\n// node is moved, it is quite desirable to have any control points associated\n// with arrows connected to the node move as well, and in a particular way.\nexport interface ControlPointInfo {\n  byId: { [key: string]: ControlPoint };\n  selected: null | string;\n  selectedOffset: null | SerializableVector;\n  fullOffsets: { [key: string]: SerializableVector };\n  halfOffsets: { [key: string]: FixedOffset };\n}\n\nexport interface ControlPoint {\n  id: string;\n  arrow: string;\n  pos: SerializableVector;\n}\n\n// Suppose we move a node away from another node, and imagine that both of these\n// nodes are connected with an arrow. How should the control point for that\n// arrow move in order to maintain the arrow's overall \"shape\"? We have chosen\n// to move the control point as if it were \"fixed\" in a sense to the line\n// connecting the two endpoint nodes. This requires keeping track of the\n// position of the non-moving node, the position of the moving node, the\n// distance between the control point and one of the endpoints, and the\n// perpendicular distance between the line connecting the nodes and the control\n// point. The calculations for generating and restoring these offsets is spelled\n// out below.\nexport interface FixedOffset {\n  fixedPos: Vector;\n  movingOffset: Vector;\n  fractionAlong: number;\n  perpLength: number;\n}\n\nexport const initControlPointState: ControlPointState = {\n  wip: null,\n  committed: {\n    byId: {},\n    selected: null,\n    selectedOffset: null,\n    fullOffsets: {},\n    halfOffsets: {},\n  },\n};\n\n// Return an array containing all control points.\nexport const allControlPoints = (state: State): ControlPoint[] => (\n  Object.values(currentLatest(state.entities.controlPoints).byId)\n);\n\n// Return the control point for the given arrow, if one exists.\nexport const controlPointForArrow = (state: State, arrowId: string): ControlPoint => {\n  const cp = allControlPoints(state).find(({ arrow }) => arrow === arrowId);\n  if (!cp) {\n    throw new Error(`No ControlPoint associated with Arrow having ID \"${arrowId}\"`);\n  }\n  return cp;\n};\n\nexport const controlPointsReducer = (state: State, action: Action): ControlPointState => {\n  if (isInEditMode(state)) {\n    switch (action.type) {\n      case A.ADD_ARROW:\n        return addArrow(state, action.payload.start, action.payload.end, action.payload.id);\n      case A.DELETE_ENTITIES:\n        return deleteEntities(state, action.payload.controlPoints);\n      case A.MOUSE_DOWN_CONTROL_POINT:\n        return mouseDownControlPoint(state, action.payload.id);\n      case A.MOUSE_UP_CONTROL_POINT:\n        return mouseUpControlPoint(state);\n      case A.MOUSE_DOWN_CANVAS:\n        return mouseDownCanvas(state, action.payload.pos);\n      case A.MOUSE_MOVE_CANVAS:\n        return mouseMoveCanvas(state, action.payload.pos);\n      case A.MOUSE_UP_CANVAS:\n      case A.MOUSE_UP_NODE:\n        return mouseUpNodeOrCanvas(state);\n      default:\n        return state.entities.controlPoints;\n    }\n  }\n  else {\n    return state.entities.controlPoints;\n  }\n};\n\n// Whenever we add a new arrow, we also add a new control point for it. The\n// position of the control point is determined by the position of the arrow's\n// start and end nodes, and whether the transition is a self-loop or not.\nconst addArrow = (state: State, start: string, end: string, arrow: string): ControlPointState => {\n  const id = uuid();\n  const startPos = Vector.from(nodeById(state, start).pos);\n  const endPos = start === end ? startPos : Vector.from(nodeById(state, end).pos);\n\n  const constructStandardPos = (start: Vector, end: Vector): Vector => {\n    const diff = end.minus(start);\n    // We offset the control point ever so slightly from the line joining the\n    // endpoints; this forces the transition details into a better position. In\n    // the event that both endpoints are on top of each other (this is\n    // incredibly rare if not impossible), we add the control point a certain\n    // vertical distance away.\n    const perp = diff.magnitude() !== 0\n      ? diff.perp().normalize().scale(-1)\n      : new Vector(0, -1);\n    return diff.scale(1 / 2).plus(perp).plus(start);\n  };\n\n  const controlPos = start === end\n  ? startPos.minus(new Vector(0, 90))\n  : constructStandardPos(startPos, endPos);\n\n  return {\n    wip: null,\n    committed: _.merge({}, state.entities.controlPoints.committed, {\n      byId: {\n        [id]: { id, arrow, pos: controlPos },\n      }\n    }),\n  };\n};\n\nconst deleteEntities = (state: State, ids: string[]): ControlPointState => ({\n  wip: null,\n  committed: {\n    ...state.entities.controlPoints.committed,\n    byId: _.omit(state.entities.controlPoints.committed.byId, ids),\n  },\n});\n\n// When the user presses the mouse over a control point, we revert to the last\n// committed state and record the control point as the current selection. We do\n// NOT calculate an offset here, since we need the cursor's position relative to\n// the containing (SVG) element in order to do so.\nconst mouseDownControlPoint = (state: State, id: string): ControlPointState => ({\n  ...state.entities.controlPoints,\n  wip: null,\n  committed: {\n    ...state.entities.controlPoints.committed,\n    selected: id,\n  },\n});\n\n// When the mouse is released over a control point, we COMMIT the wip state, and\n// remove any selection and offset that might have been created before a move.\nconst mouseUpControlPoint = (state: State): ControlPointState => ({\n  wip: null,\n  committed: {\n    ...currentLatest(state.entities.controlPoints),\n    selected: null,\n    selectedOffset: null,\n  },\n});\n\n// Here's where things start to get a little tricky: if a mouse press has been\n// received by the canvas, we check if the cursor is currently down over a\n// control point or a node. If it is down over a control point, we compute the\n// current offset in preparation for a move; if it is down over a node, we\n// compute the required offsetS in preparation for the node being moved.\nconst mouseDownCanvas = (state: State, mousePos: Vector): ControlPointState => {\n  if (isMouseDownControlPoint(state)) return prepForDirectMove(state, mousePos);\n  else if (isMouseDownNode(state)) return prepForIndirectMove(state, mousePos);\n  else return state.entities.controlPoints;\n};\n\n// In order to prepare for a control point to be moved, we compute its offset\n// from the cursor position. We also copy the current committed state into the\n// WIP state at this point, since we update the WIP state throughout the move.\nconst prepForDirectMove = (state: State, mousePos: Vector): ControlPointState => {\n  const controlPoints = state.entities.controlPoints.committed;\n  if (!controlPoints.selected) {\n    return state.entities.controlPoints;\n  }\n  const controlPoint = controlPoints.byId[controlPoints.selected];\n  const selectedOffset = Vector.from(controlPoint.pos).minus(mousePos);\n  return {\n    ...state.entities.controlPoints,\n    wip: _.merge({}, controlPoints, {\n      selectedOffset,\n    }),\n  };\n};\n\n// Before a node is moved, we compute some information about any control points\n// that are associated with any arrows connected to the node. This information\n// includes offsets of 2 varieties: \"full\" and \"half\". A full offset is simply a\n// difference between the current mouse position and a control point. We compute\n// a full offset whenever all nodes associated with a control point are\n// selected, since the control point will simply get translated along with the\n// cursor in this case. Computing a half offset is more involved. In this case,\n// we calculate the position of the control point relative to the node that is\n// moving.\nconst prepForIndirectMove = (state: State, mousePos: Vector): ControlPointState => {\n  const controlPoints = state.entities.controlPoints.committed;\n  const selected = selectedNodes(state);\n\n  // A control point is fully affected if both of the nodes associated with its\n  // arrow are selected.\n  const fullyAffected = Object.values(controlPoints.byId).filter(controlPoint => {\n    const arrow = arrowById(state, controlPoint.arrow);\n    return selected.includes(arrow.start) && selected.includes(arrow.end);\n  });\n\n  const fullOffsets = fullyAffected.reduce((acc, cp) => ({\n    ...acc,\n    [cp.id]: new Vector(cp.pos.x - mousePos.x, cp.pos.y - mousePos.y),\n  }), {});\n\n  // A control point is half affected if exactly one of the nodes associated\n  // with its arrow is selected.\n  const halfOffsets = Object.values(controlPoints.byId).reduce((acc, p) => {\n    const arrow = arrowById(state, p.arrow);\n    const includesStart = selected.includes(arrow.start);\n    const includesEnd = selected.includes(arrow.end);\n    if (!xOr(includesStart, includesEnd)) {\n      return acc;\n    }\n\n    const fixedPos = Vector.from(nodeById(state, includesEnd ? arrow.start : arrow.end).pos);\n    const movingPos = Vector.from(nodeById(state, includesStart ? arrow.start : arrow.end).pos);\n    const movingOffset = movingPos.minus(mousePos);\n    const diff = fixedPos.minus(movingPos);\n    const toCP = Vector.from(p.pos).minus(movingPos);\n    const cpShadow = toCP.project(diff);\n    const fractionAlong = cpShadow.magnitude() / diff.magnitude();\n    const perp = toCP.minus(cpShadow);\n    const perpSign = perp.dot(cpShadow.perp()) > 0 ? 1 : -1;\n    const perpLength = perpSign * perp.magnitude();\n\n    return {\n      ...acc,\n      [p.id]: { fixedPos, movingOffset, fractionAlong, perpLength },\n    };\n  }, {});\n\n  // Just as in a direct move, we move the committed state into the WIP state in\n  // preparation for movement.\n  return {\n    ...state.entities.controlPoints,\n    wip: {\n      ...controlPoints,\n      fullOffsets,\n      halfOffsets,\n    },\n  };\n};\n\n// Just as we needed to handle two cases when the mouse is pressed over the\n// canvas, so too must we manage two cases when the mouse is moved. In this\n// case, we distinguish between a \"direct\" move -- when the user is moving the\n// control point by dragging it, and an \"indirect\" move -- when the control\n// point is moved as a result of a node moving.\nconst mouseMoveCanvas = (state: State, mousePos: Vector): ControlPointState => {\n  if (isMouseDownControlPoint(state)) return moveDirect(state, mousePos);\n  else if (isMouseDownNode(state)) return moveIndirect(state, mousePos);\n  else return state.entities.controlPoints;\n};\n\n// To perform a direct move, we simply add the computed offset to the current\n// cursor position, and use this as the new position for the selected control\n// point. This is only slightly complicated by the need to check that the\n// \"selected\" and \"offset\" properties must be non-null.\nconst moveDirect = (state: State, mousePos: Vector): ControlPointState => {\n  const { controlPoints } = state.entities;\n\n  if (!controlPoints.wip || !controlPoints.wip.selected || !controlPoints.wip.selectedOffset) {\n    return controlPoints;\n  }\n\n  const controlPoint = controlPoints.wip.byId[controlPoints.wip.selected];\n  const updatedPos = mousePos.plus(Vector.from(controlPoints.wip.selectedOffset));\n\n  return {\n    ...controlPoints,\n    wip: _.merge({}, controlPoints.wip, {\n      byId: {\n        [controlPoint.id]: { ...controlPoint, pos: updatedPos },\n      },\n    }),\n  };\n};\n\n// To perform an indirect move, we essentially reverse the process of computing\n// the full and half offsets in order to update the positions of the affected\n// control points in the WIP state.\nconst moveIndirect = (state: State, mousePos: Vector): ControlPointState => {\n  const { controlPoints } = state.entities;\n\n  if (!controlPoints.wip) {\n    return controlPoints;\n  }\n\n  const fullMoved = Object.keys(controlPoints.wip.fullOffsets).reduce((acc, id) => {\n    const controlPoint = controlPoints.wip!.byId[id];\n    const updatedPos = mousePos.plus(Vector.from(controlPoints.wip!.fullOffsets[id]));\n    return {\n      ...acc,\n      [id]: { ...controlPoint, pos: updatedPos },\n    };\n  }, {});\n\n  const halfMoved = Object.keys(controlPoints.wip.halfOffsets).reduce((acc, id) => {\n    const controlPoint = controlPoints.wip!.byId[id];\n    const { fixedPos, movingOffset, fractionAlong, perpLength } = controlPoints.wip!.halfOffsets[id];\n    const newPos = mousePos.plus(movingOffset);\n    const diff = fixedPos.minus(newPos);\n    const alongDiff = diff.scale(fractionAlong).plus(newPos);\n    // If the start and end points are the same, we simply place the control\n    // point a certain vertical distance away from them.\n    const updatedPos = diff.magnitude() !== 0\n      ? diff.perp().normalize().scale(perpLength).plus(alongDiff)\n      : new Vector(0, -80).plus(alongDiff);\n\n    return {\n      ...acc,\n      [id]: { ...controlPoint, pos: updatedPos },\n    };\n  }, {});\n\n  return {\n    ...controlPoints,\n    wip: _.merge({}, controlPoints.wip, {\n      byId: {\n        ...fullMoved,\n        ...halfMoved,\n      },\n    }),\n  };\n};\n\n// When the mouse is released, we commit the wip state and remove all offsets\n// that might have been created before a move.\nconst mouseUpNodeOrCanvas = (state: State): ControlPointState => ({\n  ...state.entities.controlPoints,\n  wip: null,\n  committed: {\n    ...currentLatest(state.entities.controlPoints),\n    selected: null,\n    selectedOffset: null,\n    fullOffsets: {},\n    halfOffsets: {},\n  },\n});\n","import { State } from './state';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport { tapeEntries, TapeDirection, TapeDirections } from './Tape';\nimport { startNode, isStartNode } from './Node';\n\nexport interface SimState {\n  hasStarted: boolean;\n  initialTapeEntries: null | string[];\n  currentNode: null | string;\n  activeTapeCell: number;\n  isTapeWriting: boolean;\n  glowingNode: null | string;\n  fadeInNode: null | string;\n  fadeOutNode: null | string;\n  glowingArrow: null | string;\n  glowingControlPoint: null | string;\n  glowingTransitionDetail: null | string;\n  intervalDivisor: number;\n}\n\nexport const initSimState: SimState = {\n  hasStarted: false,\n  initialTapeEntries: null,\n  currentNode: null,\n  activeTapeCell: 0,\n  isTapeWriting: false,\n  glowingNode: null,\n  fadeInNode: null,\n  fadeOutNode: null,\n  glowingArrow: null,\n  glowingControlPoint: null,\n  glowingTransitionDetail: null,\n  intervalDivisor: 4,\n};\n\nexport const MIN_SIM_INTERVAL = 4000;\nexport const MAX_SIM_DIVISOR = 15;\n\nexport const isTapeWriting = (state: State): boolean => state.sim.isTapeWriting;\n\nexport const initialTapeEntries = (state: State): null | string[] => state.sim.initialTapeEntries;\n\nexport const currentNode = (state: State): string => {\n  if (state.sim.currentNode) {\n    return state.sim.currentNode;\n  }\n  return startNode(state);\n};\n\nexport const isNodeCurrent = (state: State, id: string): boolean => {\n  if (state.sim.currentNode) {\n    return state.sim.currentNode === id;\n  }\n  return isStartNode(state, id);\n};\n\nexport const activeTapeCell = (state: State): number => state.sim.activeTapeCell;\n\nexport const isNodeGlowing = (state: State, id: string): boolean => state.sim.glowingNode === id;\n\nexport const isNodeFadingIn = (state: State, id: string): boolean => state.sim.fadeInNode === id;\n\nexport const isNodeFadingOut = (state: State, id: string): boolean => state.sim.fadeOutNode === id;\n\nexport const isArrowGlowing = (state: State, id: string): boolean => state.sim.glowingArrow === id;\n\nexport const isControlPointGlowing = (state: State, id: string): boolean => state.sim.glowingControlPoint === id;\n\nexport const glowingTransitionDetail = (state: State): null | string => state.sim.glowingTransitionDetail;\n\nexport const simInterval = (state: State): number => (\n  Math.floor(MIN_SIM_INTERVAL / state.sim.intervalDivisor)\n);\n\nexport const simIntervalDivisor = (state: State): number => state.sim.intervalDivisor;\n\nexport const simReducer = (state: State, action: Action): SimState => {\n  switch (action.type) {\n    case A.STEP_SIM:\n      return stepSim(state);\n    case A.PLAY_SIM:\n      return playSim(state);\n    case A.RESET_SIM:\n      return resetSim(state);\n    case A.SET_SIM_INTERVAL_DIVISOR:\n      return setSimIntervalDivisor(state, action.payload.divisor);\n    case A.SET_CURRENT_NODE:\n      return setCurrentNode(state, action.payload.node);\n    case A.SET_TAPE_WRITING_STATUS:\n      return setTapeWritingStatus(state, action.payload.isWriting);\n    case A.MOVE_TAPE:\n      return moveTape(state, action.payload.direction);\n    case A.SET_GLOWING_NODE:\n      return setGlowingNode(state, action.payload.node);\n    case A.SET_FADE_IN_NODE:\n      return setFadeInNode(state, action.payload.node);\n    case A.SET_FADE_OUT_NODE:\n      return setFadeOutNode(state, action.payload.node);\n    case A.SET_GLOWING_ARROW:\n      return setGlowingArrow(state, action.payload.arrow);\n    case A.SET_GLOWING_CONTROL_POINT:\n      return setGlowingControlPoint(state, action.payload.controlPoint);\n    case A.SET_GLOWING_TRANSITION_DETAIL:\n      return setGlowingTransitionDetail(state, action.payload.transitionDetail);\n    default:\n      return state.sim;\n  }\n};\n\nconst stepSim = (state: State): SimState => ({\n  ...state.sim,\n  hasStarted: true,\n  initialTapeEntries: state.sim.hasStarted\n    ? state.sim.initialTapeEntries\n    : tapeEntries(state),\n});\n\nconst playSim = (state: State): SimState => ({\n  ...state.sim,\n  hasStarted: true,\n  initialTapeEntries: state.sim.hasStarted\n    ? state.sim.initialTapeEntries\n    : tapeEntries(state),\n});\n\nconst resetSim = (state: State): SimState => ({\n  ...state.sim,\n  hasStarted: false,\n  initialTapeEntries: null,\n  currentNode: null,\n  activeTapeCell: 0,\n  isTapeWriting: false,\n  glowingNode: null,\n  fadeInNode: null,\n  fadeOutNode: null,\n  glowingArrow: null,\n  glowingControlPoint: null,\n  glowingTransitionDetail: null,\n});\n\nconst setSimIntervalDivisor = (state: State, divisor: number): SimState => ({\n  ...state.sim,\n  intervalDivisor: divisor,\n});\n\nconst setCurrentNode = (state: State, node: null | string): SimState => ({\n  ...state.sim,\n  currentNode: node,\n});\n\nconst setTapeWritingStatus = (state: State, isWriting: boolean): SimState => ({\n  ...state.sim,\n  isTapeWriting: isWriting,\n});\n\nconst moveTape = (state: State, direction: TapeDirection): SimState => ({\n  ...state.sim,\n  activeTapeCell: direction === TapeDirections.R\n    ? Math.max(0, state.sim.activeTapeCell - 1)\n    : state.sim.activeTapeCell + 1,\n});\n\nconst setGlowingNode = (state: State, node: null | string): SimState => ({\n  ...state.sim,\n  glowingNode: node,\n});\n\nconst setFadeInNode = (state: State, node: null | string): SimState => ({\n  ...state.sim,\n  fadeInNode: node,\n});\n\nconst setFadeOutNode = (state: State, node: null | string): SimState => ({\n  ...state.sim,\n  fadeOutNode: node,\n});\n\nconst setGlowingArrow = (state: State, arrow: null | string): SimState => ({\n  ...state.sim,\n  glowingArrow: arrow,\n});\n\nconst setGlowingControlPoint = (state: State, controlPoint: null | string): SimState => ({\n  ...state.sim,\n  glowingControlPoint: controlPoint,\n});\n\nconst setGlowingTransitionDetail = (state: State, transitionDetail: null | string): SimState => ({\n  ...state.sim,\n  glowingTransitionDetail: transitionDetail,\n});\n","import _ from 'lodash';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport { State } from './state';\nimport { repeat } from '../tools/auxiliary';\nimport { activeTapeCell, initialTapeEntries } from './Sim';\n\nexport interface TapeState {\n  entries: string[];\n  scrollLeft: number;\n  focused: number | null;\n}\n\nexport const CELL_WIDTH = 36;\nexport const VISIBLE_CELL_COUNT = 20;\n\nexport const initTapeState: TapeState = {\n  entries: repeat('', VISIBLE_CELL_COUNT),\n  scrollLeft: 0,\n  focused: null,\n};\n\nexport type TapeDirection = 'L' | 'R';\nexport const TapeDirections: { [key: string]: TapeDirection } = {\n  L: 'L',\n  R: 'R',\n};\n\n// Return an array containing all of the tape entries, along with entries\n// containing empty values for nonexistent intermediate entries.\nexport const tapeEntries = (state: State): string[] => state.entities.tape.entries;\n\nexport const focusedTapeCell = (state: State): null | number => state.entities.tape.focused;\n\nexport const currentReadSymbol = (state: State): string => {\n  const activeCell = activeTapeCell(state);\n  return state.entities.tape.entries[activeCell];\n};\n\nexport const tapeReducer = (state: State, action: Action): TapeState => {\n  switch (action.type) {\n    case A.CHANGE_TAPE_CELL:\n      return changeTapeCell(state, action.payload.pos, action.payload.value);\n    case A.UPDATE_SCROLL_LEFT:\n      return updateScrollLeft(state, action.payload.scrollLeft);\n    case A.FOCUS_TAPE_CELL:\n      return focusTapeCell(state, action.payload.pos);\n    case A.CLEAR_TAPE:\n      return clearTape(state);\n    case A.WRITE_TAPE_SYMBOL:\n      return writeTapeSymbol(state, action.payload.symbol);\n    case A.RESET_SIM:\n      return resetSim(state);\n    default:\n      return state.entities.tape;\n  }\n};\n\nconst changeTapeCell = (state: State, pos: number, value: string): TapeState => ({\n  ...state.entities.tape,\n  entries: _.update(_.clone(state.entities.tape.entries), pos, _ => value),\n  focused: value.length > 0 && state.entities.tape.focused !== null\n    ? state.entities.tape.focused + 1\n    : state.entities.tape.focused,\n});\n\nconst focusTapeCell = (state: State, pos: number): TapeState => ({\n  ...state.entities.tape,\n  focused: pos,\n});\n\nconst clearTape = (state: State): TapeState => initTapeState;\n\nconst updateScrollLeft = (state: State, scrollLeft: number): TapeState => ({\n  ...state.entities.tape,\n  entries: updateBlocks(state.entities.tape.entries, scrollLeft),\n  scrollLeft,\n});\n\nconst updateBlocks = (entries: string[], leftPos: number): string[] => {\n  const BLOCK_SIZE = 20;\n  const cellDiff = entries.length - Math.floor(leftPos / CELL_WIDTH);\n  // If there is less than a block between the current scroll position and the\n  // end of the tape, we add a new empty block.\n  if (cellDiff < BLOCK_SIZE) {\n    return [...entries, ...repeat('', BLOCK_SIZE)];\n  }\n  // If there is an EMPTY block at the end of the tape, and there are at least 2\n  // blocks between the current scroll position and the end, we remove the empty\n  // block.\n  else if (cellDiff > 2 * BLOCK_SIZE && entries.slice(-BLOCK_SIZE).every(val => val.length === 0)) {\n    return entries.slice(0, -BLOCK_SIZE);\n  }\n  return entries;\n};\n\nconst writeTapeSymbol = (state: State, symbol: string): TapeState => {\n  const { tape } = state.entities;\n  const active = activeTapeCell(state);\n  return {\n    ...tape,\n    entries: _.set(_.clone(tape.entries), active, symbol),\n  };\n};\n\nconst resetSim = (state: State): TapeState => {\n  const initialEntries = initialTapeEntries(state);\n  return {\n    ...state.entities.tape,\n    entries: initialEntries || state.entities.tape.entries,\n  };\n};\n","import _ from 'lodash';\nimport uuid from 'uuid/v4';\nimport { State } from './state';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport { isInEditMode } from './Mode';\nimport { arrowById } from './Arrow';\nimport { TapeDirection, TapeDirections } from './Tape';\n\n// A transition detail provides the information that is missing in an arrow: an\n// arrow indicates the start and end states for a number of transitions; a\n// transition detail supplies the read symbol, write symbol, and tape direction\n// for a particular transition. Thus, a transition consists of an arrow along\n// with a transition detail.\n\nexport interface TransitionDetailState {\n  byId: { [key: string]: TransitionDetail };\n  focused: null | string;\n}\n\nexport interface TransitionDetail {\n  id: string;\n  arrow: string;\n  read: string;\n  write: string;\n  move: TapeDirection;\n  isDuplicate: boolean;\n}\n\nexport const initTransitionDetailState: TransitionDetailState = {\n  byId: {},\n  focused: null,\n};\n\n// Return an array containing all transition details.\nexport const allTransitionDetails = (state: State): TransitionDetail[] => (\n  Object.values(state.entities.transitionDetails.byId)\n);\n\n// Return an object associating each Arrow ID with a list of its\n// TransitionDetails.\nexport const allGroupedTransitionDetails = (state: State): { [key: string]: TransitionDetail[] } => (\n  _.groupBy(allTransitionDetails(state), detail => detail.arrow)\n);\n\n// Return an array of transition details associated with the given arrow.\nexport const transitionDetailsForArrow = (state: State, arrow: string): TransitionDetail[] => (\n  allGroupedTransitionDetails(state)[arrow]\n);\n\nexport const transitionDetailsByStart = (state: State): { [key: string]: TransitionDetail[] } => (\n  _.groupBy(allTransitionDetails(state), detail => arrowById(state, detail.arrow).start)\n);\n\n// Return an array of IDs of transition details that share \"read\" symbols with\n// at least one other detail.\nexport const duplicateTransitionDetails = (state: State): string[] => {\n  const byStart = Object.values(transitionDetailsByStart(state));\n  const byReadSym = byStart.map(ds => Object.values(_.groupBy(ds, detail => detail.read)));\n  const duplicates = byReadSym.map(ds => ds.filter(group => group.length > 1)); \n  const flattened = _.flattenDeep(duplicates) as TransitionDetail[];\n  return flattened.map(detail => detail.id);\n};\n\n// Return the currently focused transition detail\nexport const focusedDetail = (state: State): null | string => state.entities.transitionDetails.focused;\n\nexport const transitionDetailsReducer = (state: State, action: Action): TransitionDetailState => {\n  if (isInEditMode(state)) {\n    switch (action.type) {\n      case A.ADD_TRANSITION_DETAIL:\n        return addTransitionDetail(state, action.payload.arrow);\n      case A.ADD_ARROW:\n        return addArrow(state, action.payload.id);\n      case A.CHANGE_TRANSITION_DETAIL:\n        return changeTransitionDetail(state, action.payload.detail);\n      case A.DELETE_TRANSITION_DETAIL:\n        return deleteTransitionDetail(state, action.payload.id);\n      case A.DELETE_ENTITIES:\n        return deleteEntities(state, action.payload.transitionDetails);\n      case A.FOCUS_TRANSITION_DETAIL:\n        return focusTransitionDetail(state, action.payload.id);\n      case A.BLUR_TRANSITION_DETAIL:\n        return blurTransitionDetail(state);\n      case A.MARK_DUPLICATE_TRANSITIONS:\n        return markDuplicateTransitions(state, action.payload.ids);\n      default:\n        return state.entities.transitionDetails;\n    }\n  }\n  else {\n    return state.entities.transitionDetails;\n  }\n};\n\nconst addTransitionDetail = (state: State, arrow: string): TransitionDetailState => {\n  const id = uuid();\n  const detail = { id, arrow, read: '', write: '', move: TapeDirections.L, isFocused: false };\n  return _.merge({}, state.entities.transitionDetails, {\n    byId: {\n      [id]: detail,\n    },\n    focused: id,\n  });\n};\n\n// Whenever we add a new arrow, we also add a fresh transition detail.\nconst addArrow = (state: State, arrow: string): TransitionDetailState => (\n  addTransitionDetail(state, arrow)\n);\n\nconst changeTransitionDetail = (state: State, detail: TransitionDetail): TransitionDetailState => (\n  _.merge({}, state.entities.transitionDetails, {\n    byId: {\n      [detail.id]: detail,\n    },\n  })\n);\n\nconst deleteTransitionDetail = (state: State, id: string): TransitionDetailState => {\n  const { transitionDetails } = state.entities;\n  return {\n    ...transitionDetails,\n    byId: _.omit(transitionDetails.byId, id),\n  };\n};\n\nconst deleteEntities = (state: State, ids: string[]): TransitionDetailState => ({\n  ...state.entities.transitionDetails,\n  byId: _.omit(state.entities.transitionDetails.byId, ids),\n});\n\nconst focusTransitionDetail = (state: State, id: string): TransitionDetailState => ({\n  ...state.entities.transitionDetails,\n  focused: id,\n});\n\nconst blurTransitionDetail = (state: State): TransitionDetailState => ({\n  ...state.entities.transitionDetails,\n  focused: null,\n});\n\nconst markDuplicateTransitions = (state: State, ids: string[]): TransitionDetailState => ({\n  ...state.entities.transitionDetails,\n  byId: _.mapValues(state.entities.transitionDetails.byId, detail => ({\n    ...detail,\n    isDuplicate: ids.includes(detail.id),\n  })),\n});\n","import { Action } from './actions';\nimport * as A from './actions';\nimport { State } from './state';\nimport { isInEditMode } from './Mode';\nimport { wasMouseDragged } from './UI';\nimport { getSnapshot, revertToSnapshot } from './auxiliary';\n\nexport interface UndoRedoState {\n  actions: ActionRecord[];\n  redoable: ActionRecord[];\n}\n\nexport interface ActionRecord {\n  value: any;\n  description?: string;\n}\n\nexport const initUndoRedoState: UndoRedoState = {\n  actions: [],\n  redoable: [],\n};\n\nexport const undoRedoReducer = (state: State, action: Action): UndoRedoState => {\n  if (isInEditMode(state)) {\n    switch (action.type) {\n      case A.MOUSE_UP_NODE:\n        return mouseUpNode(state);\n      case A.MOUSE_UP_CONTROL_POINT:\n        return mouseUpControlPoint(state);\n      case A.ADD_NODE:\n        return addRecord(state, 'add node');\n      case A.MAKE_SELECTED_START_NODE:\n        return addRecord(state, 'change initial state');\n      case A.TOGGLE_SELECTED_FINAL_NODES:\n        return addRecord(state, 'toggle \"final\" status for selected states');\n      case A.ADD_ARROW:\n        return addRecord(state, 'add new transition');\n      case A.ADD_TRANSITION_DETAIL:\n        return addRecord(state, 'add new transition');\n      case A.DELETE_ENTITIES:\n        return addRecord(state, 'delete entities');\n      case A.CHANGE_TRANSITION_DETAIL:\n        return addRecord(state, 'change transition');\n      case A.CHANGE_TAPE_CELL:\n        return addRecord(state, 'change tape cell');\n      case A.CLEAR_TAPE:\n        return addRecord(state, 'clear tape');\n      default:\n        return state.undoRedo;\n    }\n  }\n  else {\n    return state.undoRedo;\n  }\n};\n\n// We need to be a little careful before adding an action record when the mouse\n// is released over a node (or control point), since the user may not have\n// actually MOVED the node at all, but instead simply selected it. Thus, we\n// first check if the mouse was dragged before adding the record.\nconst mouseUpNode = (state: State): UndoRedoState => {\n  if (wasMouseDragged(state)) return addRecord(state, 'move node');\n  else return state.undoRedo;\n};\n\nconst mouseUpControlPoint = (state: State): UndoRedoState => {\n  if (wasMouseDragged(state)) return addRecord(state, 'move control point');\n  else return state.undoRedo;\n};\n\nexport const undo = (state: State): State => {\n  if (state.undoRedo.actions.length === 0) return state;\n  const [record, ...rest] = state.undoRedo.actions;\n  // Save current value for redo:\n  const redoValue = getSnapshot(state);\n  const redoRecord = { ...record, value: redoValue };\n  const updated = revertToSnapshot(state, record.value);\n  return {\n    ...updated,\n    undoRedo: {\n      ...state.undoRedo,\n      actions: rest,\n      redoable: [redoRecord, ...state.undoRedo.redoable],\n    },\n  };\n};\n\nexport const redo = (state: State): State => {\n  if (state.undoRedo.redoable.length === 0) return state;\n  const [record, ...rest] = state.undoRedo.redoable;\n  // Save current value for undo:\n  const undoValue = getSnapshot(state);\n  const undoRecord = { ...record, value: undoValue };\n  const updated = revertToSnapshot(state, record.value);\n  return {\n    ...updated,\n    undoRedo: {\n      ...state.undoRedo,\n      actions: [undoRecord, ...state.undoRedo.actions],\n      redoable: rest,\n    },\n  };\n};\n\nconst MAX_UNDOS = 32;\n\nexport const addRecord = (state: State, description?: string): UndoRedoState => {\n  const record = { description, value: getSnapshot(state) };\n  return {\n    // In order to prevent excessive memory usage, we limit the number of undos.\n    // Each time a record is added, we make sure that the array of actions\n    // contains only the N most recent records, and then add the new one.\n    actions: [record, ...state.undoRedo.actions.slice(0, MAX_UNDOS)],\n    // Each time we add a record to the undo stack, we clear the redo stack.\n    redoable: [],\n  };\n};\n","import { State } from './state';\nimport { Action } from './actions';\nimport * as A from './actions';\n\nexport interface MessageState {\n  show: boolean;\n  title: null | string;\n  content: null | string | JSX.Element;\n}\n\nexport const initMessageState: MessageState = {\n  show: false,\n  title: null,\n  content: null,\n};\n\nexport const showMessage = (state: State): boolean => state.message.show;\n\nexport const messageTitle = (state: State): null | string => state.message.title;\n\nexport const messageContent = (state: State): null | string | JSX.Element => state.message.content;\n\nexport const messageReducer = (state: State, action: Action): MessageState => {\n  switch (action.type) {\n    case A.DISPLAY_MESSAGE:\n      return displayMessage(state, action.payload.title, action.payload.content);\n    case A.DISMISS_MESSAGE:\n      return dismissMessage(state);\n    default:\n      return state.message;\n  }\n};\n\nconst displayMessage = (state: State, title: string, content?: string | JSX.Element): MessageState => ({\n  ...state.message,\n  show: true,\n  title,\n  content: content !== undefined ? content : null,\n});\n\nconst dismissMessage = (state: State): MessageState => ({\n  ...state.message,\n  show: false,\n  title: null,\n  content: null,\n});\n","import { State } from './state';\nimport { Action } from './actions';\nimport * as A from './actions';\n\nexport interface MetaDataState {\n  name: string;\n}\n\nexport const initMetaDataState: MetaDataState = {\n  name: 'Untitled',\n};\n\nexport const machineName = (state: State): string => state.entities.metaData.name;\n\nexport const metaDataReducer = (state: State, action: Action): MetaDataState => {\n  switch (action.type) {\n    case A.CHANGE_MACHINE_NAME:\n      return changeMachineName(state, action.payload.name);\n    default:\n       return state.entities.metaData;\n  }\n};\n\nconst changeMachineName = (state: State, name: string): MetaDataState => ({\n  ...state.entities.metaData,\n  name,\n});\n","import { NodeState, initNodeState } from './Node';\nimport { ArrowState, initArrowState } from './Arrow';\nimport { ControlPointState, initControlPointState } from './ControlPoint';\nimport { TransitionDetailState, initTransitionDetailState } from './TransitionDetail';\nimport { TapeState, initTapeState } from './Tape';\nimport { UIState, initUIState } from './UI';\nimport { UndoRedoState, initUndoRedoState } from './UndoRedo';\nimport { MessageState, initMessageState } from './Message';\nimport { ModeState, initModeState } from './Mode';\nimport { SimState, initSimState } from './Sim';\nimport { MetaDataState, initMetaDataState } from './MetaData';\n\n// The application state consists of a number of \"entities\" (objects -- in the\n// general sense -- that are displayed and interacted with), along with some UI\n// info. The UI info is generally useful for a number of the entities.\n\nexport interface State {\n  entities: {\n    nodes: NodeState;\n    arrows: ArrowState;\n    controlPoints: ControlPointState;\n    transitionDetails: TransitionDetailState;\n    tape: TapeState;\n    metaData: MetaDataState;\n  }\n  ui: UIState;\n  undoRedo: UndoRedoState;\n  message: MessageState;\n  mode: ModeState;\n  sim: SimState;\n}\n\nexport const initState: State = {\n  entities: {\n    nodes: initNodeState,\n    arrows: initArrowState,\n    controlPoints: initControlPointState,\n    transitionDetails: initTransitionDetailState,\n    tape: initTapeState,\n    metaData: initMetaDataState,\n  },\n  ui: initUIState,\n  undoRedo: initUndoRedoState,\n  message: initMessageState,\n  mode: initModeState,\n  sim: initSimState,\n};\n","import { Action } from './actions'\nimport * as A from './actions';\nimport { State, initState } from './state';\nimport { nodesReducer } from './Node';\nimport { arrowsReducer } from './Arrow';\nimport { controlPointsReducer } from './ControlPoint';\nimport { transitionDetailsReducer } from './TransitionDetail';\nimport { tapeReducer } from './Tape';\nimport { uiReducer } from './UI';\nimport { undoRedoReducer, undo, redo, addRecord } from './UndoRedo';\nimport { messageReducer } from './Message';\nimport { modeReducer } from './Mode';\nimport { simReducer, initSimState } from './Sim';\nimport { metaDataReducer } from './MetaData';\nimport { getSnapshot, revertToSnapshot } from './auxiliary';\n\nconst reducer = (state: State=initState, action: Action): State => {\n  switch (action.type) {\n    case A.UNDO:\n      return undo(state);\n    case A.REDO:\n      return redo(state);\n    case A.INSTALL_SNAPSHOT:\n      return installSnapshot(state, action.payload.snapshot, action.payload.undoable);\n    case A.NEW_MACHINE:\n      return newMachine(state);\n    default:\n      return {\n        ...state,\n        entities: {\n          ...state.entities,\n          nodes: nodesReducer(state, action),\n          arrows: arrowsReducer(state, action),\n          controlPoints: controlPointsReducer(state, action),\n          transitionDetails: transitionDetailsReducer(state, action),\n          tape: tapeReducer(state, action),\n          metaData: metaDataReducer(state, action),\n        },\n        ui: uiReducer(state, action),\n        undoRedo: undoRedoReducer(state, action),\n        message: messageReducer(state, action),\n        mode: modeReducer(state, action),\n        sim: simReducer(state, action),\n      };\n  }\n};\n\n// We manually add action records for these actions since they affect the entire\n// state (the entities, at least).\nconst installSnapshot = (state: State, snapshot: any, undoable: boolean): State => ({\n  ...revertToSnapshot(state, snapshot),\n  undoRedo: undoable\n    ? addRecord(state, 'install entity snapshot')\n    : state.undoRedo,\n  sim: initSimState,\n});\n\nconst newMachine = (state: State): State => {\n  const freshSnapshot = getSnapshot(initState);\n  return {\n    ...revertToSnapshot(state, freshSnapshot),\n    undoRedo: addRecord(state, 'create new machine'),\n    sim: initSimState,\n  };\n};\n\nexport default reducer;\n","import { Middleware } from 'redux';\nimport { Action } from '../actions';\nimport * as A from '../actions';\nimport { State } from '../state';\nimport { isInEditMode } from '../Mode';\nimport { selectedNodes } from '../Node';\n\n// Each key may be \"bound\" to an alternative redux action, such that when the\n// user presses it, the action is dispatched.\nconst keyBindings: { [key: string]: KeyHandler } = {\n  'a': (st, e) => {\n    if (e.ctrlKey && isInEditMode(st)) {\n      return A.selectAllNodes();\n    }\n  },\n  'k': (st, e) => {\n    if (e.ctrlKey && isInEditMode(st)) {\n      return A.deleteSelectedNodes();\n    }\n  },\n  ' ': (st, e) => {\n    if (e.ctrlKey && isInEditMode(st)) {\n      e.preventDefault();\n      return A.startAddingNode();\n    }\n  },\n  't': (st, e) => {\n    const multipleSelected = selectedNodes(st).length > 0;\n    if (multipleSelected && e.ctrlKey && isInEditMode(st)) {\n      e.preventDefault();\n      return A.addTransitionBetweenSelected();\n    }\n  },\n  'f': (st, e) => {\n    if (selectedNodes(st).length > 0 && e.ctrlKey && isInEditMode(st)) {\n      return A.toggleSelectedFinalNodes();\n    }\n  },\n  'i': (st, e) => {\n    if (selectedNodes(st).length === 1 && e.ctrlKey && isInEditMode(st)) {\n      return A.makeSelectedStartNode();\n    }\n  },\n  'z': (st, e) => {\n    if ((e.ctrlKey || e.metaKey) && isInEditMode(st)) {\n      return A.undo();\n    }\n  },\n  'y': (st, e) => {\n    if ((e.ctrlKey || e.metaKey) && isInEditMode(st)) {\n      e.preventDefault();\n      return A.redo();\n    }\n  },\n  's': (_, e) => {\n    if (e.ctrlKey || e.metaKey) {\n      e.preventDefault();\n      return A.saveSnapshot();\n    }\n  },\n};\n\ntype KeyHandler = (state: State, event: React.KeyboardEvent) => undefined | Action;\n\nexport const keyboardShortcuts: Middleware = api => next => action => {\n  if (action.type !== A.KEY_DOWN) return next(action);\n\n  const state = api.getState();\n  const { key, event } = action.payload;\n\n  const keyHandler = keyBindings[key];\n  if (!keyHandler) return next(action);\n\n  const altAction = keyHandler(state, event);\n  if (!altAction) return next(action);\n\n  next(action);\n  return next(altAction);\n};\n","import React from 'react';\nimport './ErrorReport.css';\n\nexport interface ErrorReportProps {\n  whatsWrong: string;\n  howToFix: string | JSX.Element;\n}\n\nclass ErrorReport extends React.Component<ErrorReportProps> {\n  render() {\n    return (\n      <div className=\"error-report\">\n        <div className=\"error-report__section\">\n          <span className=\"error-report__title\">What's wrong:&ensp;</span>\n          <span className=\"error-report__content\">{this.props.whatsWrong}</span>\n        </div>\n        <div className=\"error-report__section\">\n          <span className=\"error-report__title\">How to fix it:&ensp;</span>\n          <span className=\"error-report__content\">{this.props.howToFix}</span>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default ErrorReport;\n","import React from 'react';\nimport ErrorReport from './ErrorReport';\nimport step0 from './fix-start-0.png';\nimport step1 from './fix-start-1.png';\nimport './ErrorReport.css';\n\nconst problem = 'In order for the machine to start, a state must be '\n              + 'distinguished as the initial or start state. You have '\n              + 'not yet identified any state as such.';\n\nconst fix = (\n  <ol>\n    <li>\n      Select one of your machine states\n    </li>\n    <img src={step0} alt=\"a selected state\" />\n    <li>\n      Click the indicated button to distinguish the selected state as the machine's start state\n    </li>\n    <img src={step1} alt=\"the button for distinguishing a state as the initial state\" />\n  </ol>\n);\n\nexport default (\n  <ErrorReport whatsWrong={problem} howToFix={fix} />\n);\n","import React from 'react';\nimport ErrorReport from './ErrorReport';\nimport nondet0 from './nondet-0.png';\nimport nondet1 from './nondet-1.png';\nimport './ErrorReport.css';\n\nconst problem = 'At the moment, you have 2 or more transitions from the same '\n              + 'state with the same read symbol. Such nondeterministic behavior '\n              + 'is not supported.';\n\nconst fix = (\n  <div>\n    <span>\n      For each transition whose read symbol is marked red\n    </span>\n    <img src={nondet0} alt=\"a nondeterministic transition\" />\n    <span>\n      Modify or remove the associated transitions so that all transitions for each\n      state have distinct read symbols\n    </span>\n    <img src={nondet1} alt=\"the nondeterminism resolved\" />\n  </div>\n);\n\nexport default (\n  <ErrorReport whatsWrong={problem} howToFix={fix} />\n);\n","import React from 'react';\nimport _ from 'lodash';\nimport './HaltReport.css';\n\nexport interface HaltReportProps {\n  accepted: boolean;\n  initTapeEntries: string[];\n  finalTapeEntries: string[];\n}\n\nclass HaltReport extends React.Component<HaltReportProps> {\n  render() {\n    const { accepted: wasSuccess } = this.props;\n    return (\n      <div className=\"halt-report\">\n        <div className=\"halt-report__title\">\n          The machine has&nbsp;\n          <span className={`halt-report__result halt-report__result--${wasSuccess ? 'accepted' : 'rejected'}`}>\n            {wasSuccess ? 'accepted' : 'rejected'}\n          </span>\n          &nbsp;the input string\n          <span className=\"halt-report__tape-contents\">\n            {this.formatTapeEntries(this.props.initTapeEntries)}\n          </span>\n          It left the string\n          <span className=\"halt-report__tape-contents\">\n            {this.formatTapeEntries(this.props.finalTapeEntries)}\n          </span>\n          on the tape.\n        </div>\n      </div>\n    );\n  }\n\n  private formatTapeEntries(entries: string[]): JSX.Element {\n    const reversed = _.reverse(_.clone(entries));\n    const trimmed = _.reverse(_.dropWhile(reversed, x => x.length === 0));\n    const withExplicitNulls = trimmed.map(x => x.length === 0 ? '' : x);\n    const withPadding = [...withExplicitNulls, '', '', ''];\n    return (\n      <>\n        {withPadding.map((s, i) => (\n          <span key={i} className={`halt-report__${s === '' ? 'null-' : ''}tape-entry`}>\n            {s}\n          </span>\n        ))}\n      </>\n    );\n  }\n}\n\nexport default HaltReport;\n","import React from 'react';\nimport HaltReport from './HaltReport';\n\nexport default (initTapeEntries: string[], finalTapeEntries: string[]) => (\n  <HaltReport accepted={true}\n              initTapeEntries={initTapeEntries}\n              finalTapeEntries={finalTapeEntries} />\n);\n","import React from 'react';\nimport HaltReport from './HaltReport';\n\nexport default (initTapeEntries: string[], finalTapeEntries: string[]) => (\n  <HaltReport accepted={false}\n              initTapeEntries={initTapeEntries}\n              finalTapeEntries={finalTapeEntries} />\n);\n","import { delay, put } from 'redux-saga/effects';\nimport * as A from '../actions';\n\nexport default function* autoSave() {\n  const FIVE_SECONDS = 5 * 1000;\n  while (true) {\n    yield delay(FIVE_SECONDS);\n    yield put(A.saveSnapshot());\n  }\n}\n","import _ from 'lodash';\nimport { channel, Channel } from 'redux-saga';\nimport { takeEvery, take, fork, select, put, call, cancel, cancelled, delay } from 'redux-saga/effects';\nimport * as A from '../actions';\nimport { State } from '../state';\nimport { Modes } from '../Mode';\nimport { currentNode, simInterval } from '../Sim';\nimport { isNodeFinal } from '../Node';\nimport { TapeDirection, currentReadSymbol } from '../Tape';\nimport { arrowsForStart } from '../Arrow';\nimport { transitionDetailsForArrow } from '../TransitionDetail';\nimport { controlPointForArrow } from '../ControlPoint';\n\nfunction* play(singleStep: boolean) {\n  const completedChan = yield call(channel);\n  const playTask = yield fork(playSim, singleStep, completedChan);\n  const stopAction = yield take([A.PAUSE_SIM, A.RESET_RUNNING_SIM, A.HALT_ACCEPT, A.HALT_REJECT]);\n  yield cancel(playTask);\n  if (stopAction.type === A.RESET_RUNNING_SIM) {\n    // If the reset button has been clicked, we wait until we've completed all\n    // required state changes atomically, and then reset the simulation.\n    yield take(completedChan);\n    yield put(A.resetSim());\n  }\n}\n\nfunction* playSim(singleStep: boolean, completedChan: Channel<any>) {\n  try {\n    yield put(A.switchMode(Modes.SIM));\n    if (singleStep) {\n      yield call(makeStep, completedChan);\n    } else {\n      while (true) {\n        yield call(makeStep, completedChan);\n      }\n    }\n  } finally {\n    yield put(A.switchMode(Modes.EDIT));\n  }\n}\n\nfunction* makeStep(completedChan: Channel<any>) {\n  const current = yield select(currentNode);\n  const readSym = yield select(currentReadSymbol);\n\n  // Determine the next arrow, control point, transition detail, write symbol,\n  // tape direction, and node, if available; if no transitions are available, we\n  // halt the machine.\n  const transitionInfo = yield select(availableTransitionInfo, current, readSym);\n  if (!transitionInfo) {\n    const isFinal = yield select(state => isNodeFinal(state, current));\n    if (isFinal) {\n      yield put(A.haltAccept());\n    } else {\n      yield put(A.haltReject());\n    }\n    return;\n  }\n\n  const {\n    nodeId, controlPointId, arrowId, transitionDetailId, writeSymbol, tapeDirection\n  } = transitionInfo;\n\n  const interval = yield select(simInterval);\n\n  yield fork(nodeStep, interval, current, nodeId);\n  yield fork(tapeStep, interval, writeSymbol, tapeDirection, completedChan);\n  yield fork(arrowStep, interval, arrowId);\n  yield fork(transitionDetailStep, interval, transitionDetailId);\n  yield fork(controlPointStep, interval, controlPointId);\n}\n\nconst availableTransitionInfo = (state: State, currentNode: string, readSym: string): null | TransitionInfo => {\n  const outgoingArrows = arrowsForStart(state, currentNode);\n  const details = _.flatten(outgoingArrows.map(arrow => transitionDetailsForArrow(state, arrow.id)));\n  const detail = details.find(detail => detail.read === readSym);\n\n  if (!detail) {\n    return null;\n  }\n\n  const arrow = outgoingArrows.find(arrow => arrow.id === detail.arrow);\n  if (!arrow) {\n    throw new Error(`Inconsistency in state: transition detail references nonexistent arrow \"${detail.arrow}\"`);\n  }\n\n  const controlPoint = controlPointForArrow(state, arrow.id);\n\n  return {\n    nodeId: arrow.end,\n    arrowId: arrow.id,\n    controlPointId: controlPoint.id,\n    transitionDetailId: detail.id,\n    writeSymbol: detail.write,\n    tapeDirection: detail.move,\n  };\n};\n\ninterface TransitionInfo {\n  nodeId: string;\n  arrowId: string;\n  controlPointId: string;\n  transitionDetailId: string;\n  writeSymbol: string;\n  tapeDirection: TapeDirection;\n}\n\nfunction* nodeStep(interval: number, current: string, next: string) {\n  // We change this flag to `true` after updating the current node to avoid\n  // duplicating this state change in the `finally` block below in the event\n  // that the user pauses the simulation.\n  let hasUpdatedCurrent = false;\n  try {\n    // Glow the current node for a short period\n    yield put(A.setGlowingNode(current));\n    yield delay(interval / 8);\n\n    // Fade the current node out\n    yield put(A.setFadeOutNode(current));\n    yield put(A.setGlowingNode(null));\n    yield delay(interval / 4);\n    yield put(A.setFadeOutNode(null));\n    yield delay(interval / 4);\n\n    // Set the next node as current and fade it in\n    yield put(A.setCurrentNode(next));\n    hasUpdatedCurrent = true;\n    yield put(A.setFadeInNode(next));\n    yield delay(interval / 4);\n    yield put(A.setFadeInNode(null));\n    yield put(A.setGlowingNode(next));\n    yield delay(interval / 8);\n  } finally {\n    if (yield cancelled()) {\n      if (!hasUpdatedCurrent) yield put(A.setCurrentNode(next));\n    }\n  }\n}\n\nfunction* tapeStep(interval: number, writeSymbol: string, direction: TapeDirection, completedChan: Channel<any>) {\n  // As in the case of `nodeStep` above, we use these flags to avoid duplicating\n  // state changes in the event of a simulation pause.\n  let hasWrittenSymbol = false;\n  let hasMovedTape = false;\n  try {\n    yield delay(interval / 4);\n    \n    // \"Erase\" current tape symbol\n    yield put(A.setTapeWritingStatus(true));\n    yield delay(interval / 4);\n    \n    // Write new tape symbol\n    yield put(A.writeTapeSymbol(writeSymbol));\n    hasWrittenSymbol = true;\n    yield delay(interval / 4);\n    yield put(A.setTapeWritingStatus(false));\n    \n    // Move the tape\n    yield put(A.moveTape(direction));\n    hasMovedTape = true;\n  } finally {\n    if (yield cancelled()) {\n      if (!hasWrittenSymbol) yield put(A.writeTapeSymbol(writeSymbol));\n      if (!hasMovedTape) yield put(A.moveTape(direction));\n      yield put(completedChan, true);\n    }\n  }\n}\n\nfunction* arrowStep(interval: number, arrowId: string) {\n  yield delay(interval / 8);\n  yield put(A.setGlowingArrow(arrowId));\n  yield delay(3 * interval / 4);\n  yield put(A.setGlowingArrow(null));\n}\n\nfunction* transitionDetailStep(interval: number, transitionDetailId: string) {\n  yield delay(interval / 4);\n  yield put(A.setGlowingTransitionDetail(transitionDetailId));\n  yield delay(interval / 2);\n  yield put(A.setGlowingTransitionDetail(null));\n}\n\nfunction* controlPointStep(interval: number, controlPointId: string) {\n  yield delay(interval / 4);\n  yield put(A.setGlowingControlPoint(controlPointId));\n  yield delay(interval / 2);\n  yield put(A.setGlowingControlPoint(null));\n}\n\nexport default function* sim() {\n  yield takeEvery(A.STEP_SIM, play, true);\n  yield takeEvery(A.PLAY_SIM, play, false);\n}\n","import { all } from 'redux-saga/effects';\nimport autoSave from './autoSave';\nimport sim from './sim';\n\nexport default function* main() {\n  yield all([\n    autoSave(),\n    sim(),\n  ]);\n}\n","import { createStore, applyMiddleware } from 'redux';\nimport createSagaMiddleware from 'redux-saga';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport reducer from './reducer';\nimport * as M from './middleware';\nimport mainSaga from './sagas';\n\nconst sagaMiddleware = createSagaMiddleware();\n\nconst store = createStore(\n  reducer,\n  composeWithDevTools(applyMiddleware(\n    M.keyboardShortcuts,\n    M.addTransition,\n    M.deleteTransitionDetail,\n    M.deleteNode,\n    M.validateTransitionDetails,\n    M.validatePreSim,\n    sagaMiddleware,\n    M.halt,\n    M.loadSnapshot,\n    M.saveSnapshot,\n    M.download,\n    M.upload,\n  )),\n);\n\nsagaMiddleware.run(mainSaga);\n\nexport default store;\n","import uuid from 'uuid/v4';\nimport { Middleware } from 'redux';\nimport * as A from '../actions';\nimport { selectedNodes } from '../Node';\nimport { arrowForEndpoints } from '../Arrow';\n\n// When we add a new transition, we need to check if there is already an arrow\n// between its two endpoints. If so, we simply add an additional detail to this\n// arrow; if not we need to construct a new arrow and control point, and then\n// add the detail to that.\nexport const addTransition: Middleware = api => next => action => {\n  if (action.type !== A.ADD_TRANSITION_BETWEEN_SELECTED) return next(action);\n\n  const state = api.getState();\n  const nodes = selectedNodes(state);\n  const start = nodes[0];\n  const end = nodes[1] || nodes[0];\n  const existingArrow = arrowForEndpoints(state, start, end);\n\n  if (existingArrow) {\n    return next(A.addTransitionDetail(existingArrow.id));\n  } else {\n    const arrowId = uuid();\n    return next(A.addArrow(start, end, arrowId));\n  }\n};\n","import { Middleware } from 'redux';\nimport * as A from '../actions';\nimport { transitionDetailsForArrow } from '../TransitionDetail';\nimport { controlPointForArrow } from '../ControlPoint';\n\n// When a transition detail is deleted, we need to check if it was the last one\n// for its associated arrow. If it is, we need to also delete the arrow its\n// control point.\nexport const deleteTransitionDetail: Middleware = api => next => action => {\n  if (action.type !== A.DELETE_TRANSITION_DETAIL) return next(action);\n\n  const { id, arrow } = action.payload;\n  const state = api.getState();\n  const remainingDetails = transitionDetailsForArrow(state, arrow).filter(detail => detail.id !== id);\n\n  if (remainingDetails.length > 0) return next(action);\n\n  const controlPointId = controlPointForArrow(state, arrow).id;\n  return next(A.deleteEntities([], [arrow], [controlPointId], [id]));\n};\n","import _ from 'lodash';\nimport { Middleware } from 'redux';\nimport * as A from '../actions';\nimport { transitionDetailsForArrow } from '../TransitionDetail';\nimport { controlPointForArrow } from '../ControlPoint';\nimport { selectedNodes } from '../Node';\nimport { arrowsForNode } from '../Arrow';\n\n// When we delete a node, we need to remove anything that was \"attached\" to it:\n// any arrows, and control points and transition details associated with them.\nexport const deleteNode: Middleware = api => next => action => {\n  if (action.type !== A.DELETE_SELECTED_NODES) return next(action);\n\n  const state = api.getState();\n  const nodeIds = selectedNodes(state);\n  const arrows = _.flatten(nodeIds.map(id => arrowsForNode(state, id)));\n  const arrowIds = _.uniq(_.flatten(arrows.map(({ id }) => id)));\n  const controlPointIds = arrowIds.map(id => controlPointForArrow(state, id)).map(({ id }) => id);\n  const transitionDetails = _.flatten(arrowIds.map(id => transitionDetailsForArrow(state, id)));\n  const transitionDetailIds = transitionDetails.map(({ id }) => id);\n\n  return next(A.deleteEntities(nodeIds, arrowIds, controlPointIds, transitionDetailIds));\n};\n","import { Middleware } from 'redux';\nimport * as A from '../actions';\nimport { duplicateTransitionDetails } from '../TransitionDetail';\n\n// Each time the user modifies or adds a transition detail, we find all\n// transition details that share an arrow and have the same read symbol. These\n// represent nondeterministic transitions and should be marked as errors.\nexport const validateTransitionDetails: Middleware = api => next => action => {\n  const validateOn = [\n    A.ADD_TRANSITION_DETAIL,\n    A.CHANGE_TRANSITION_DETAIL,\n    A.DELETE_TRANSITION_DETAIL,\n    A.DELETE_ENTITIES,\n    A.ADD_ARROW,\n  ];\n  if (!validateOn.includes(action.type)) return next(action);\n\n  next(action);\n  const duplicates = duplicateTransitionDetails(api.getState());\n  return next(A.markDuplicateTransitions(duplicates));\n};\n","import { Middleware } from 'redux';\nimport * as A from '../actions';\nimport { hasStartNode } from '../Node';\nimport { duplicateTransitionDetails } from '../TransitionDetail';\nimport MissingStartState from '../../ErrorReport/MissingStartState';\nimport NondeterministicTransition from '../../ErrorReport/NondeterministicTransition';\n\nexport const validatePreSim: Middleware = api => next => action => {\n  if (![A.STEP_SIM, A.PLAY_SIM].includes(action.type)) return next(action);\n\n  const state = api.getState();\n  if (!hasStartNode(state)) {\n    return next(A.displayMessage('Missing start state', MissingStartState));\n  }\n  else if (duplicateTransitionDetails(state).length > 0) {\n    return next(A.displayMessage('Nondeterministic transitions', NondeterministicTransition));\n  }\n\n  return next(action);\n};\n","import { Middleware } from 'redux';\nimport * as A from '../actions';\nimport accept from '../../HaltReport/Accept';\nimport reject from '../../HaltReport/Reject';\nimport { tapeEntries } from '../Tape';\nimport { initialTapeEntries } from '../Sim';\n\nexport const halt: Middleware = api => next => action => {\n  if (![A.HALT_ACCEPT, A.HALT_REJECT].includes(action.type)) return next(action);\n\n  const state = api.getState();\n  const initTapeEntries = initialTapeEntries(state) || [];\n  const finalTapeEntries = tapeEntries(state);\n\n  next(A.resetSim());\n\n  const contentProducer = action.type === A.HALT_ACCEPT ? accept : reject;\n  return next(A.displayMessage('Machine Halted', contentProducer(initTapeEntries, finalTapeEntries)));\n};\n","import { Middleware } from 'redux';\nimport * as A from '../actions';\nimport { getSnapshot } from '../auxiliary';\n\nexport const loadSnapshot: Middleware = _ => next => action => {\n  if (action.type !== A.LOAD_SNAPSHOT) return next(action);\n  try {\n    const saved = localStorage.getItem('machine');\n    if (!saved) return;\n    const snapshot = JSON.parse(saved);\n    next(A.installSnapshot(snapshot, false));\n  } catch(_) {\n    localStorage.clearItem('machine');\n  }\n};\n\nexport const saveSnapshot: Middleware = api => next => action => {\n  if (action.type !== A.SAVE_SNAPSHOT) return next(action);\n  const state = api.getState();\n  const snapshot = getSnapshot(state);\n  try {\n    localStorage.setItem('machine', JSON.stringify(snapshot));\n  } catch(_) {\n    return;\n  }\n};\n","import { Middleware } from 'redux';\nimport * as A from '../actions';\nimport { getSnapshot } from '../auxiliary';\nimport { machineName } from '../MetaData';\n\n// In order to download a machine, we simply encode a snapshot of the current\n// state as JSON, create a dummy link \"pointing\" to this string, and click it.\nexport const download: Middleware = api => next => action => {\n  if (action.type !== A.DOWNLOAD_MACHINE) return next(action);\n\n  const state = api.getState();\n  const snapshot = getSnapshot(state);\n  const machineString = JSON.stringify(snapshot, null, '  ');\n  const dataURI = `data:application/json;charset=utf-8,${encodeURIComponent(machineString)}`;\n  const name = machineName(state);\n  const filenameCandidate = name.toLowerCase().split(' ').join('-');\n  const filename = filenameCandidate.length > 0 ? filenameCandidate : 'untitled-machine';\n\n  const linkElt = document.createElement('a');\n  linkElt.setAttribute('href', dataURI);\n  linkElt.setAttribute('download', filename);\n  linkElt.click();\n};\n\n// Uploading a machine involves a process similar to the download process above.\nexport const upload: Middleware = _ => next => action => {\n  if (action.type !== A.UPLOAD_MACHINE) return next(action);\n\n  async function installMachine(this: any) {\n    uploadElt.removeEventListener('change', installMachine);\n    try {\n      const machineString = await this.files[0].text();\n      const machine = JSON.parse(machineString);\n      return next(A.installSnapshot(machine, true));\n    } catch (_) {\n      return next(A.displayMessage(\n        'Upload Error',\n        'We were unable to upload your machine. '\n      + 'Please verify that you have selected a valid machine file.'\n      ));\n    }\n  };\n\n  const uploadElt = document.createElement('input');\n  uploadElt.type = 'file';\n  uploadElt.accept = '.json,.JSON';\n  uploadElt.addEventListener('change', installMachine);\n  uploadElt.click();\n};\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport classNames from 'classnames';\nimport { State } from '../state-mgmt/state';\nimport { Arrow as ArrowDetails } from '../state-mgmt/Arrow';\nimport { controlPointForArrow } from '../state-mgmt/ControlPoint';\nimport { nodeById } from '../state-mgmt/Node';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport { isArrowGlowing, simInterval } from '../state-mgmt/Sim';\nimport Vector from '../tools/Vector';\nimport './Arrow.css';\n\n// An arrow represents one or more transitions between machine states (which are\n// represented by nodes). We render an arrow as a curved line between nodes,\n// using the arrow's control points to construct this curve. There are two cases\n// we need to consider: (1) if the arrow represents a self-transition, we render\n// it using a cubic bezier curve, (2) if the arrow represents a standard\n// transition, we use a quadratic curve.\n\nexport interface ArrowProps {\n  details: ArrowDetails;\n  start: Vector;\n  end: Vector;\n  control: Vector;\n  isSelfLoop: boolean;\n  isEditable: boolean;\n  isGlowing: boolean;\n  simInterval: number;\n}\n\nclass Arrow extends React.Component<ArrowProps> {\n  // We need to know the arrow's length in order to animate the \"glow\" effect\n  // correctly. This ref allows us to compute the referenced SVG path's length.\n  private arrowRef: React.RefObject<SVGPathElement> = React.createRef();\n\n  render() {\n    const className = classNames('arrow', {\n      'arrow--editable': this.props.isEditable,\n    });\n\n    const pathString = this.props.isSelfLoop\n      ? this.computeCubicPathString()\n      : this.computeQuadraticPathString();\n    return (\n      <g>\n        <path className={className} d={pathString} ref={this.arrowRef} />\n        {this.renderGlow(pathString)}\n      </g>\n    );\n  }\n\n  private computeQuadraticPathString() {\n    // We need to distinguish between two types of \"control point\": the USER\n    // control point, which is represented by an arrowhead that the user can\n    // drag around, and the BEZIER control point, which is determined by the\n    // position of the user control point and in turn determines the shape of\n    // the arrow's curve. The main task here is to derive the BEZIER control\n    // point from the USER control point. To do so, we first find the midpoint\n    // between the nodes. We then construct the vector pointing from this\n    // midpoint to the USER control point, and scale it by 2. The bezier control\n    // point is described by the sum of this vector and the midpoint vector. I\n    // discovered this via experimentation, but it works like a charm.\n    const { start, end, control} = this.props;\n    const mid = start.plus(end.minus(start).scale(1 / 2));\n    const bezierControl= mid.plus(control.minus(mid).scale(2));\n    return `M ${start.x} ${start.y} Q ${bezierControl.x} ${bezierControl.y} ${end.x} ${end.y}`;\n  }\n\n  private computeCubicPathString() {\n    // To construct the bezier control pointS in this case, we first construct\n    // the vector pointing from the node to the USER control point and scale it\n    // by 4 / 3 (as above, I discovered this experimentally, and it appears to\n    // work perfectly although I don't know why). We then move a specified\n    // distance (`separation`) perpendicular to this vector in either direction.\n    // This separation distance determines how wide the loop is.\n    const { start, control } = this.props;\n    const v1 = control.minus(start).scale(4 / 3);\n    const separation = 65;\n    // If the control point is on top of its associated node, we place the\n    // bezier control points horizontally to the left and right.\n    const v2 = v1.magnitude() !== 0\n      ? v1.perp().normalize().scale(separation)\n      : new Vector(separation, 0);\n    const ctrl1 = start.plus(v1).minus(v2);\n    const ctrl2 = start.plus(v1).plus(v2);\n    return `M ${start.x} ${start.y} C ${ctrl1.x} ${ctrl1.y} ${ctrl2.x} ${ctrl2.y} ${start.x} ${start.y}`;\n  }\n\n  private renderGlow(pathString: string) {\n    if (this.props.isEditable || !this.props.isGlowing) return null;\n    // We provide a conservative fallback value in the rare (impossible?) event\n    // that the arrow's ref is not available.\n    const length = this.arrowRef.current ? this.arrowRef.current.getTotalLength() : 500;\n    return (\n      <path className=\"arrow__glow\"\n            d={pathString}\n            style={{\n              strokeDasharray: length,\n              strokeDashoffset: length,\n              animationDuration: `${3 * this.props.simInterval / 4}ms`,\n            }} />\n    );\n  }\n}\n\nconst mapStateToProps = (state: State, ownProps: any) => {\n  const start = nodeById(state, ownProps.details.start);\n  const end = nodeById(state, ownProps.details.end);\n  const controlPoint = controlPointForArrow(state, ownProps.details.id);\n  return {\n    start: Vector.from(start.pos),\n    end: Vector.from(end.pos),\n    control: Vector.from(controlPoint.pos),\n    isSelfLoop: start.id === end.id,\n    isEditable: isInEditMode(state),\n    isGlowing: isArrowGlowing(state, ownProps.details.id),\n    simInterval: simInterval(state),\n  };\n};\n\nexport default connect(\n  mapStateToProps,\n)(Arrow);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport classNames from 'classnames';\nimport { State } from '../state-mgmt/state';\nimport * as A from '../state-mgmt/actions';\nimport { Node as NodeDetails, isNodeSelected, isStartNode } from '../state-mgmt/Node';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport { isNodeGlowing, isNodeCurrent, isNodeFadingIn, isNodeFadingOut, simInterval } from '../state-mgmt/Sim';\nimport Vector from '../tools/Vector';\nimport './Node.css';\n\n// A node represents a machine state in the TM formalization. We render nodes as\n// circles (with additional embellishments if they are also start or accepting\n// nodes). Additionally, a node may be given a \"mnemonic\" -- a 0-4 character\n// string -- to clarify its purpose.\n\nexport interface NodeProps {\n  details: NodeDetails;\n  isSelected: boolean;\n  isStart: boolean;\n  isEditable: boolean;\n  isCurrent: boolean;\n  isGlowing: boolean;\n  isFadingIn: boolean;\n  isFadingOut: boolean;\n  simInterval: number;\n  mouseDown: () => void;\n  mouseUp: () => void;\n}\n\nexport const NODE_RADIUS = 21;\n\nclass Node extends React.Component<NodeProps> {\n  render() {\n    const className = classNames('node', {\n      'node--selected': this.props.isSelected,\n      'node--final': this.props.details.isFinal,\n      'node--start': this.props.isStart,\n      'node--editable': this.props.isEditable,\n      'node--glowing': !this.props.isEditable && this.props.isGlowing,\n      'node--fading-in': !this.props.isEditable && this.props.isFadingIn,\n      'node--fading-out': !this.props.isEditable && this.props.isFadingOut,\n    });\n\n    const pos = Vector.from(this.props.details.pos);\n\n    const MARKER_WIDTH = 12;\n    const MARKER_HEIGHT = 18;\n\n    return (\n      <div className=\"node__container\">\n        {this.props.isCurrent && this.props.isEditable &&\n          <div className=\"node__current-marker\"\n               style={{\n                 position: 'absolute',\n                 left: pos.x - MARKER_WIDTH / 2,\n                 top: pos.y - NODE_RADIUS - MARKER_HEIGHT - 2,\n               }} />\n        }\n        <div className={className}\n             onMouseDown={this.handleMouseDown}\n             onMouseUp={this.handleMouseUp}\n             style={{\n               position: 'absolute',\n               left: pos.x - NODE_RADIUS,\n               top: pos.y - NODE_RADIUS,\n               animationDuration: `${this.props.simInterval / 4}ms`,\n             }} />\n      </div>\n    );\n  }\n\n  private handleMouseDown = (e: React.MouseEvent) => {\n    this.props.mouseDown();\n  };\n\n  private handleMouseUp = (e: React.MouseEvent) => {\n    this.props.mouseUp();\n  };\n}\n\nconst mapStateToProps = (state: State, ownProps: any) => ({\n  isSelected: isNodeSelected(state, ownProps.details.id),\n  isStart: isStartNode(state, ownProps.details.id),\n  isEditable: isInEditMode(state),\n  isCurrent: isNodeCurrent(state, ownProps.details.id),\n  isGlowing: isNodeGlowing(state, ownProps.details.id),\n  isFadingIn: isNodeFadingIn(state, ownProps.details.id),\n  isFadingOut: isNodeFadingOut(state, ownProps.details.id),\n  simInterval: simInterval(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch, ownProps: any) => ({\n  mouseDown: () => dispatch(A.mouseDownNode(ownProps.details.id)),\n  mouseUp: () => dispatch(A.mouseUpNode()),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(Node);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport classNames from 'classnames';\nimport * as A from '../state-mgmt/actions';\nimport { State } from '../state-mgmt/state';\nimport { arrowById } from '../state-mgmt/Arrow';\nimport { nodeById } from '../state-mgmt/Node';\nimport { ControlPoint as ControlPointDetails } from '../state-mgmt/ControlPoint';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport { isControlPointGlowing } from '../state-mgmt/Sim';\nimport Vector from '../tools/Vector';\nimport './ControlPoint.css';\n\n// A control point is a draggable handle that the user can position to alter the\n// curve of an arrow. Control points are essential in being able to layout a\n// machine in an aesthetically pleasing way. As for arrows, there are 2 cases to\n// consider here: (1) the control point is for a self-transition, and (2) it is\n// for a standard transition. In both cases, we render the control point as an\n// arrowhead pointing in the direction of the transition that its arrow\n// represents.\n\nexport interface ControlPointProps {\n  details: ControlPointDetails;\n  start: Vector;\n  end: Vector;\n  isSelfLoop: boolean;\n  isEditable: boolean;\n  isGlowing: boolean;\n  mouseDown: () => void;\n  mouseUp: () => void;\n}\n\nconst ARROW_LENGTH = 18;\n\nclass ControlPoint extends React.Component<ControlPointProps> {\n  render() {\n    const className = classNames('control-point', {\n      'control-point--editable': this.props.isEditable,\n      'control-point--glowing': !this.props.isEditable && this.props.isGlowing,\n    });\n\n    const pathString = this.props.isSelfLoop\n    ? this.computeCubicString()\n    : this.computeQuadraticPathString();\n    return <path className={className}\n                 d={pathString}\n                 onMouseDown={this.handleMouseDown}\n                 onMouseUp={this.handleMouseUp} />;\n  }\n\n  // In the quadratic (i.e. standard transition) case, we render the control\n  // point as an arrowhead that is parallel to the line segment connecting the\n  // two nodes that its arrow joins.\n  private computeQuadraticPathString() {\n    const { start, end } = this.props;\n    const pos = Vector.from(this.props.details.pos);\n    const diff = end.minus(start);\n    // If the two endpoints are on top of each other, we simply create a\n    // horizontal arrow.\n    const v1 = diff.magnitude() !== 0\n      ? diff.normalize().scale(ARROW_LENGTH)\n      : new Vector(ARROW_LENGTH, 0);\n    const v2 = v1.perp().scale(1 / 3);\n    const p1 = pos.minus(v1).plus(v2);\n    const p2 = pos.minus(v1).minus(v2);\n    return `M ${p1.x} ${p1.y} L ${pos.x} ${pos.y} L ${p2.x} ${p2.y}`;\n  }\n\n  // For a self-transition, we render the control point as an arrowhead that is\n  // perpendicular to the line connecting it to the node that its arrow\n  // connects.\n  private computeCubicString() {\n    const { start } = this.props;\n    const pos = Vector.from(this.props.details.pos);\n    const diff = pos.minus(start);\n    // If the control point is on top of its associated node, we simply create a\n    // horizontal arrow.\n    const v1 = diff.magnitude() !== 0\n      ? diff.normalize()\n      : new Vector(0, 1);\n    const v2 = v1.perp().scale(ARROW_LENGTH);\n    const tip = pos.plus(v2.scale(1 / 3));\n    const p1 = tip.minus(v2).plus(v1.scale(ARROW_LENGTH / 3));\n    const p2 = tip.minus(v2).minus(v1.scale(ARROW_LENGTH / 3));\n    return `M ${p1.x} ${p1.y} L ${tip.x} ${tip.y} L ${p2.x} ${p2.y}`;\n  }\n\n  private handleMouseDown = (e: React.MouseEvent) => {\n    this.props.mouseDown();\n  };\n\n  private handleMouseUp = (e: React.MouseEvent) => {\n    this.props.mouseUp();\n  };\n}\n\nconst mapStateToProps = (state: State, ownProps: any) => {\n  const arrow = arrowById(state, ownProps.details.arrow);\n  const start = nodeById(state, arrow.start);\n  const end = nodeById(state, arrow.end);\n  return {\n    start: Vector.from(start.pos),\n    end: Vector.from(end.pos),\n    isSelfLoop: start.id === end.id,\n    isEditable: isInEditMode(state),\n    isGlowing: isControlPointGlowing(state, ownProps.details.id),\n  };\n};\n\nconst mapDispatchToProps = (dispatch: Dispatch, ownProps: any) => ({\n  mouseDown: () => dispatch(A.mouseDownControlPoint(ownProps.details.id)),\n  mouseUp: () => dispatch(A.mouseUpControlPoint()),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(ControlPoint);\n","import React from 'react';\nimport classNames from 'classnames';\nimport { TransitionDetail as TransitionDetailInfo } from '../state-mgmt/TransitionDetail';\nimport { TapeDirection, TapeDirections } from '../state-mgmt/Tape';\nimport './TransitionDetail.css';\n\n// Each transition consists of a pair of (not necessarily distinct) states, and\n// 3 pieces of information detailing (1) what tape symbol must be read in order\n// to take the transition, (2) what tape symbol will be written if the\n// transition is taken, and (3) in which direction the tape head should move. A\n// transition detail represents these three pieces of information; together with\n// an arrow it represents a full transition.\n\nexport interface TransitionDetailProps {\n  detail: TransitionDetailInfo;\n  isFocused: boolean;\n  isEditable: boolean;\n  isGlowing: boolean;\n  onFocus?: () => void;\n  onBlur?: () => void;\n  onChange?: (value: TransitionDetailInfo) => void;\n  onDelete?: () => void;\n}\n\nclass TransitionDetail extends React.Component<TransitionDetailProps> {\n  private readRef: React.RefObject<HTMLInputElement> = React.createRef();\n\n  render() {\n    const { read, write, move } = this.props.detail;\n\n    const className = classNames('transition-detail', {\n      'transition-detail--glowing': !this.props.isEditable && this.props.isGlowing,\n    });\n\n    const inputClassName = classNames('transition-detail__input', {\n      'transition-detail__input--focus': this.props.isFocused,\n      'transition-detail__input--editable': this.props.isEditable,\n    });\n\n    // We create a special className for the read input in order to distinguish\n    // inputs in an \"error\" state.\n    const readInputClassName = classNames(inputClassName, {\n      'transition-detail__input--error': this.props.detail.isDuplicate,\n    })\n\n    const selectorClassName = classNames('transition-detail__selector', {\n      'transition-detail__selector--focus': this.props.isFocused,\n      'transition-detail__selector--editable': this.props.isEditable,\n    });\n\n    const deleteButtonClassName = classNames('transition-detail__delete-button', {\n      'transition-detail__delete-button--hidden': !this.props.isEditable,\n    });\n\n    return (\n      <div className={className}>\n        <input className={readInputClassName}\n               ref={this.readRef}\n               disabled={!this.props.isEditable}\n               value={read}\n               placeholder=\"\"\n               onChange={this.handleInputChange('read')}\n               onFocus={this.handleFocus}\n               onBlur={this.handleBlur}\n               type=\"text\"\n               maxLength={1} />\n        <span className=\"transition-detail__separator\">&#47;</span>\n        <input className={inputClassName}\n               disabled={!this.props.isEditable}\n               value={write}\n               placeholder=\"\"\n               onChange={this.handleInputChange('write')}\n               onFocus={this.handleFocus}\n               onBlur={this.handleBlur}\n               type=\"text\"\n               maxLength={1} />\n        <select className={selectorClassName}\n                disabled={!this.props.isEditable}\n                value={move}\n                onChange={this.handleSelectChange}>\n          <option value={TapeDirections.L} onMouseDown={this.selectLeft}></option>\n          <option value={TapeDirections.R} onMouseDown={this.selectRight}></option>\n        </select>\n        <button className={deleteButtonClassName}\n                onClick={this.handleDeleteClick}>\n        </button>\n      </div>\n    );\n  }\n\n  // In the meantime, whenever a transition detail is created, it is immediately\n  // focused. This (slight) hack ensures that the browser focus remains\n  // synchronized.\n  componentDidMount() {\n    if (this.props.isFocused) this.focus();\n  }\n\n  private focus() {\n    if (this.readRef.current) this.readRef.current.focus();\n  }\n\n  private handleInputChange(property: 'read' | 'write') {\n    return (e: React.ChangeEvent<HTMLInputElement>) => {\n      if (!this.props.onChange) return;\n      // We do not allow spaces, since they appear idential to the empty string\n      // and therefore result in a lot of confusion.\n      else if (e.target.value === ' ') return;\n      this.props.onChange({\n        ...this.props.detail,\n        [property]: e.target.value,\n      });\n    };\n  }\n\n  private handleSelectChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    if (!this.props.onChange) return;\n    this.changeDirection(e.target.value as TapeDirection);\n  };\n\n  // The following two methods are a dirty hack for getting the select to update\n  // with Firefox. For some reason, Firefox is not reporting the correct value\n  // when it fires the \"change\" event. This seems to do the trick, though.\n  private selectLeft = () => {\n    this.changeDirection(TapeDirections.L);\n  };\n\n  private selectRight = () => {\n    this.changeDirection(TapeDirections.R);\n  };\n\n  private changeDirection(direction: TapeDirection) {\n    if (!this.props.onChange) return;\n    this.props.onChange({\n      ...this.props.detail,\n      move: direction,\n    });\n  }\n\n  private handleFocus = () => {\n    if (this.props.onFocus) this.props.onFocus();\n  };\n\n  private handleBlur = () => {\n    if (this.props.onBlur) this.props.onBlur();\n  };\n\n  private handleDeleteClick = () => {\n    if (this.props.onDelete) this.props.onDelete();\n  };\n}\n\nexport default TransitionDetail;\n","import React from 'react';\nimport classNames from 'classnames';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport * as A from '../state-mgmt/actions';\nimport { State } from '../state-mgmt/state';\nimport { TransitionDetail as TransitionDetailInfo, focusedDetail } from '../state-mgmt/TransitionDetail';\nimport { arrowById } from '../state-mgmt/Arrow';\nimport { nodeById } from '../state-mgmt/Node';\nimport { controlPointForArrow } from '../state-mgmt/ControlPoint';\nimport Vector from '../tools/Vector';\nimport TransitionDetail from '../TransitionDetail/TransitionDetail';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport { glowingTransitionDetail } from '../state-mgmt/Sim';\nimport './TransitionDetails.css';\n\n// A single arrow between nodes can represent any number of transitions. In\n// order to display transitions in a compact manner, we group all transition\n// details for a certain arrow together in a \"Transition Details\" component. The\n// details (read/write/move) for each transition are rendered one on top of the\n// other, along with a button for adding new transitions. The main difficulty\n// here is in displaying the details in an aesthetically pleasing way: we want\n// them not to overlap with their associated arrow. To accomplish this, we\n// compute a \"stance\" for the details based on the orientation and curve of\n// their associated arrow -- either top-left, top-right, bottom-left, or\n// bottom-right. We then transform the details via CSS accordingly.\n\nexport interface TransitionDetailsProps {\n  arrowId: string;\n  details: TransitionDetailInfo[];\n  start: Vector;\n  end: Vector;\n  control: Vector;\n  isSelfLoop: boolean;\n  focusedDetail: null | string;\n  isEditable: boolean;\n  glowingDetail: null | string;\n  changeDetail: (detail: TransitionDetailInfo) => void;\n  deleteDetail: (id: string, arrow: string) => void;\n  addDetail: (arrow: string) => void;\n  focusDetail: (id: string) => void;\n  blurDetail: (id: string) => void;\n}\n\nclass TransitionDetails extends React.Component<TransitionDetailsProps> {\n  render() {\n    const { details, control } = this.props;\n    const stance = this.computeStance();\n    const className = classNames(\n      'transition-details',\n      `transition-details--${stance}`,\n    );\n\n    return (\n      <div className={className}\n           style={{\n             // We initially anchor the component at its arrow's control point,\n             // and then use CSS transforms to move it according to its computed\n             // stance.\n             position: 'absolute',\n             left: control.x,\n             top: control.y,\n           }}>\n        {this.props.isEditable && !this.isTopStance(stance) && this.renderAddDetailButton()}\n        {details.map(detail => (\n          <TransitionDetail key={detail.id}\n                            detail={detail}\n                            isFocused={this.props.focusedDetail === detail.id}\n                            isEditable={this.props.isEditable}\n                            isGlowing={this.props.glowingDetail === detail.id}\n                            onChange={this.handleDetailChange}\n                            onDelete={this.handleDetailDelete(detail.id, detail.arrow)}\n                            onFocus={this.handleDetailFocus(detail.id)}\n                            onBlur={this.handleDetailBlur(detail.id)} />\n        ))}\n        {this.props.isEditable && this.isTopStance(stance) && this.renderAddDetailButton()}\n      </div>\n    );\n  }\n\n  private handleDetailChange = (detail: TransitionDetailInfo) => {\n    this.props.changeDetail(detail);\n  };\n\n  private handleDetailDelete(id: string, arrow: string) {\n    return () => this.props.deleteDetail(id, arrow);\n  }\n\n  private handleDetailFocus(id: string) {\n    return () => this.props.focusDetail(id);\n  }\n\n  private handleDetailBlur(id: string) {\n    return () => this.props.blurDetail(id);\n  }\n\n  private handleAddDetailButton(arrow: string) {\n    return () => this.props.addDetail(arrow);\n  };\n\n  // As is often the case here, there are two possibilities to consider: (1) the\n  // details are associated with a self-loop, or (2) with a standard arrow.\n  private computeStance() {\n    if (this.props.isSelfLoop) {\n      return this.computeSelfLoopStance();\n    } else {\n      return this.computeStandardStance();\n    }\n  }\n\n  // In the self-loop case, we simply use the angle between the associated node\n  // and the control point.\n  private computeSelfLoopStance() {\n    const { start, control } = this.props;\n    const theta = control.minus(start).angle();\n    return this.computeClassNameFromAngle(theta);\n  }\n\n  // In the case of the standard stance, we use the angle of the line segment\n  // that passes through the control point perpendicular to the line joining the\n  // two nodes associated with the arrow in question. This seems to work quite\n  // well in keeping the details away from their associated arrow.\n  private computeStandardStance() {\n    const { start, end, control } = this.props;\n    const v1 = control.minus(start);\n    const v2 = v1.project(end.minus(start));\n    const angle = v1.minus(v2).angle();\n    return this.computeClassNameFromAngle(angle);\n  }\n\n  // Here we compute a stance from a given angle. The only tricky thing here is\n  // that the Y-axis is flipped (as is customary). Thus, any intuition about\n  // where the top of the box should go needs to be applied to the bottom, and\n  // vice-versa.\n  private computeClassNameFromAngle(angle: number) {\n    // 1st quadrant\n    if (0 < angle && angle <= Math.PI / 2) return 'top-left';\n    // 2nd quadrant\n    else if (Math.PI / 2 < angle && angle <= Math.PI) return 'top-right';\n    // 3rd quadrant\n    else if (-Math.PI / 2 > angle && angle >= -Math.PI) return 'bottom-right';\n    // 4th quadrant\n    else return 'bottom-left';\n  }\n\n  // In order to keep the details as close to their associated control point as\n  // possible, we render the \"add new\" button away from the control point: if\n  // the computed stance puts the details on top of the control point, we place\n  // the button on top of the details, and vice versa (see the \"render\" method).\n  private isTopStance(anchor: string) {\n    return /^top/.test(anchor);\n  }\n\n  private renderAddDetailButton() {\n    return (\n      <button className=\"transition-details__add-button\"\n              onClick={this.handleAddDetailButton(this.props.arrowId)}>\n        add new\n      </button>\n    );\n  }\n}\n\nconst mapStateToProps = (state: State, ownProps: any) => {\n  const arrow = arrowById(state, ownProps.arrowId);\n  const start = nodeById(state, arrow.start);\n  const end = nodeById(state, arrow.end);\n  const control = controlPointForArrow(state, arrow.id);\n  return {\n    start: Vector.from(start.pos),\n    end: Vector.from(end.pos),\n    control: Vector.from(control.pos),\n    isSelfLoop: start.id === end.id,\n    focusedDetail: focusedDetail(state),\n    isEditable: isInEditMode(state),\n    glowingDetail: glowingTransitionDetail(state),\n  };\n};\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  changeDetail: (detail: TransitionDetailInfo) => dispatch(A.changeTransitionDetail(detail)),\n  deleteDetail: (id: string, arrow: string) => dispatch(A.deleteTransitionDetail(id, arrow)),\n  addDetail: (arrow: string) => dispatch(A.addTransitionDetail(arrow)),\n  focusDetail: (id: string) => dispatch(A.focusTransitionDetail(id)),\n  blurDetail: (id: string) => dispatch(A.blurTransitionDetail(id)),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(TransitionDetails);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport * as A from '../state-mgmt/actions';\nimport { State } from '../state-mgmt/state';\nimport { isAddingNode, mousePos } from '../state-mgmt/UI';\nimport { NODE_RADIUS } from '../Node/Node';\nimport Vector from '../tools/Vector';\nimport './ShadowNode.css';\n\n// When the user is in the process of adding a new node, we render a \"shadow\n// node\" underneath the cursor to indicate the change in state. This node looks\n// much like a real node but lacks all of the functionality.\n\nexport interface ShadowNodeProps {\n  isVisible: boolean;\n  pos: Vector;\n  add: (pos: Vector) => void;\n}\n\nclass ShadowNode extends React.Component<ShadowNodeProps> {\n  render() {\n    const { isVisible, pos } = this.props;\n    return (isVisible &&\n      <div className=\"shadow-node\"\n           onMouseUp={this.handleMouseUp}\n           style={{\n             position: 'absolute',\n             left: pos.x - NODE_RADIUS,\n             top: pos.y - NODE_RADIUS - 2,\n           }}/>\n    );\n  }\n\n  private handleMouseUp = (e: React.MouseEvent) => {\n    this.props.add(this.props.pos);\n  };\n}\n\nconst mapStateToProps = (state: State) => ({\n  isVisible: isAddingNode(state),\n  pos: mousePos(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  add: (pos: Vector) => dispatch(A.addNode(pos)),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(ShadowNode);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport * as A from '../state-mgmt/actions';\nimport { State } from '../state-mgmt/state';\nimport{ Arrow as ArrowDetails, allArrows } from '../state-mgmt/Arrow';\nimport { Node as NodeDetails, allNodes } from '../state-mgmt/Node';\nimport { ControlPoint as ControlPointDetails, allControlPoints } from '../state-mgmt/ControlPoint';\nimport { TransitionDetail, allGroupedTransitionDetails } from '../state-mgmt/TransitionDetail';\nimport Arrow from '../Arrow/Arrow';\nimport Node from '../Node/Node';\nimport ControlPoint from '../ControlPoint/ControlPoint';\nimport TransitionDetails from '../TransitionDetails/TransitionDetails';\nimport ShadowNode from '../ShadowNode/ShadowNode';\nimport Vector from '../tools/Vector';\nimport './Canvas.css';\n\n// The canvas is the editing surface for the machine. It is responsible for\n// rendering all nodes, arrows, control points, and transition details.\n\nexport interface CanvasProps {\n  arrows: ArrowDetails[];\n  nodes: NodeDetails[];\n  controlPoints: ControlPointDetails[];\n  transitionDetails: { [key: string]: TransitionDetail[] };\n  mouseDown: (pos: Vector) => void;\n  mouseUp: () => void;\n  mouseMove: (pos: Vector) => void;\n}\n\nclass Canvas extends React.Component<CanvasProps> {\n  render() {\n    const { arrows, nodes, controlPoints, transitionDetails } = this.props;\n    // This configuration probably warrants an explanation. Some of the machine\n    // components (e.g. arrows, control points) need to be rendered in an SVG\n    // context. However, we cannot render the nodes and transition details\n    // inside of one (strictly speaking, we could use \"foreignObject\" elements,\n    // but this proved to be far more complicated). Therefore, we render an SVG\n    // element inside of a containing div, and render the HTML elements inside\n    // of the latter.\n    return (\n      <div className=\"canvas\"\n             onMouseDown={this.handleMouseDown}\n             onMouseUp={this.handleMouseUp}\n             onMouseMove={this.handleMouseMove}>\n        <svg xmlns=\"http://www.w3.org/2000/svg\"\n             width=\"100%\"\n             height=\"100%\">\n          {arrows.map(details => <Arrow key={details.id} details={details} />)}\n          {controlPoints.map(details => <ControlPoint key={details.id} details={details} />)}\n        </svg>\n        {nodes.map(details => <Node key={details.id} details={details} />)}\n        {Object.keys(transitionDetails).map(arrowId => (\n          <TransitionDetails key={arrowId} arrowId={arrowId} details={transitionDetails[arrowId]} />\n        ))}\n        <ShadowNode />\n      </div>\n    );\n  }\n\n  private handleMouseDown = (e: React.MouseEvent) => {\n    this.props.mouseDown(this.computeMousePos(e));\n  };\n\n  private handleMouseUp = () => {\n    this.props.mouseUp();\n  };\n\n  // We call \"preventDefault\" on the event in order to prevent the annoying text\n  // highlighting behavior that occurs when the user drags entities around on\n  // the screen.\n  private handleMouseMove = (e: React.MouseEvent) => {\n    e.preventDefault();\n    this.props.mouseMove(this.computeMousePos(e));\n  };\n\n  // Here we compute the position of the mouse relative to the canvas itself\n  // (rather than the browser client, or some other frame of reference).\n  private computeMousePos(e: React.MouseEvent) {\n    const { left, top } = e.currentTarget.getBoundingClientRect();\n    const { clientX, clientY } = e;\n    return new Vector(clientX - left, clientY - top);\n  };\n}\n\nconst mapStateToProps = (state: State) => ({\n  arrows: allArrows(state),\n  nodes: allNodes(state),\n  controlPoints: allControlPoints(state),\n  transitionDetails: allGroupedTransitionDetails(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  mouseDown: (pos: Vector) => dispatch(A.mouseDownCanvas(pos)),\n  mouseUp: () => dispatch(A.mouseUpCanvas()),\n  mouseMove: (pos: Vector) => dispatch(A.mouseMoveCanvas(pos)),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(Canvas);\n","import { State } from './state';\nimport { selectedNodes } from './Node';\n\n// Produces a list of all button types which should be displayed given the\n// current state.\nexport const whichButtonTypes = (state: State): EditButtonType[] => {\n  const selectedCount = selectedNodes(state).length;\n  switch (selectedCount) {\n    case 0: return [\n      EditButtonTypes.ADD_STATE,\n    ];\n    case 1: return [\n      EditButtonTypes.ADD_STATE,\n      EditButtonTypes.REMOVE_STATE,\n      EditButtonTypes.ADD_SELF_TRANSITION,\n      EditButtonTypes.MAKE_START,\n      EditButtonTypes.TOGGLE_ACCEPTING,\n    ];\n    case 2: return [\n      EditButtonTypes.ADD_STATE,\n      EditButtonTypes.REMOVE_TWO_STATES,\n      EditButtonTypes.ADD_TRANSITION,\n      EditButtonTypes.TOGGLE_TWO_ACCEPTING,\n    ];\n    default: return [\n      EditButtonTypes.ADD_STATE,\n      EditButtonTypes.REMOVE_MANY_STATES,\n      EditButtonTypes.TOGGLE_MANY_ACCEPTING,\n    ];\n  }\n};\n\nexport type EditButtonType = 'ADD_STATE'\n                           | 'REMOVE_STATE'\n                           | 'REMOVE_TWO_STATES'\n                           | 'REMOVE_MANY_STATES'\n                           | 'ADD_SELF_TRANSITION'\n                           | 'ADD_TRANSITION'\n                           | 'MAKE_START'\n                           | 'UNMAKE_START'\n                           | 'TOGGLE_ACCEPTING'\n                           | 'TOGGLE_TWO_ACCEPTING'\n                           | 'TOGGLE_MANY_ACCEPTING';\n\nexport const EditButtonTypes: { [key: string]: EditButtonType } = {\n  ADD_STATE: 'ADD_STATE',\n  REMOVE_STATE: 'REMOVE_STATE',\n  REMOVE_TWO_STATES: 'REMOVE_TWO_STATES',\n  REMOVE_MANY_STATES: 'REMOVE_MANY_STATES',\n  ADD_SELF_TRANSITION: 'ADD_SELF_TRANSITION',\n  ADD_TRANSITION: 'ADD_TRANSITION',\n  MAKE_START: 'MAKE_START',\n  UNMAKE_START: 'UNMAKE_START',\n  TOGGLE_ACCEPTING: 'TOGGLE_ACCEPTING',\n  TOGGLE_TWO_ACCEPTING: 'TOGGLE_TWO_ACCEPTING',\n  TOGGLE_MANY_ACCEPTING: 'TOGGLE_MANY_ACCEPTING',\n};\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport { State } from '../state-mgmt/state';\nimport *  as A from '../state-mgmt/actions';\nimport { whichButtonTypes, EditButtonType, EditButtonTypes } from '../state-mgmt/EditControls';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport './EditControls.css';\n\nexport interface EditControlsProps {\n  inEditMode: boolean;\n  buttonTypes: EditButtonType[];\n  undo: () => void;\n  redo: () => void;\n  addState: () => void;\n  removeStates: () => void;\n  addTransition: () => void;\n  makeStart: () => void;\n  toggleFinal: () => void;\n}\n\nclass EditControls extends React.Component<EditControlsProps> {\n  render() {\n    return (\n      <div className=\"edit-controls\">\n        <div className=\"edit-controls__undo-redo-buttons\">\n          <button className=\"edit-controls__button edit-controls__undo-button\"\n                  title=\"undo\"\n                  onClick={this.handleUndoButtonClick} />\n          <button className=\"edit-controls__button edit-controls__redo-button\"\n                  title=\"redo\"\n                  onClick={this.handleRedoButtonClick} />\n        </div>\n\n        {this.props.inEditMode && this.props.buttonTypes.map(type => {\n          const config = this.buttonConfig[type];\n          return config && (\n            <button className={`edit-controls__button edit-controls__${config.className}-button`}\n                    title={config.title}\n                    key={type}\n                    onClick={config.action} />\n          );\n        })}\n      </div>\n    );\n  }\n\n  private handleUndoButtonClick = () => {\n    this.props.undo();\n  };\n\n  private handleRedoButtonClick = () => {\n    this.props.redo();\n  };\n\n  private buttonConfig: { [key: string]: { action: () => void, className: string, title: string } } = {\n    [EditButtonTypes.ADD_STATE]: {\n      action: () => this.props.addState(),\n      className: 'add-state',\n      title: 'add new state',\n    },\n    [EditButtonTypes.REMOVE_STATE]: {\n      action: () => this.props.removeStates(),\n      className: 'remove-state',\n      title: 'remove state',\n    },\n    [EditButtonTypes.REMOVE_TWO_STATES]: {\n      action: () => this.props.removeStates(),\n      className: 'remove-two-states',\n      title: 'remove states',\n    },\n    [EditButtonTypes.REMOVE_MANY_STATES]: {\n      action: () => this.props.removeStates(),\n      className: 'remove-many-states',\n      title: 'remove states',\n    },\n    [EditButtonTypes.ADD_SELF_TRANSITION]: {\n      action: () => this.props.addTransition(),\n      className: 'add-self-transition',\n      title: 'add self transition',\n    },\n    [EditButtonTypes.ADD_TRANSITION]: {\n      action: () => this.props.addTransition(),\n      className: 'add-transition',\n      title: 'add transition',\n    },\n    [EditButtonTypes.MAKE_START]: {\n      action: () => this.props.makeStart(),\n      className: 'make-start',\n      title: 'distinguish as initial state',\n    },\n    [EditButtonTypes.TOGGLE_ACCEPTING]: {\n      action: () => this.props.toggleFinal(),\n      className: 'toggle-accepting',\n      title: 'toggle state\\'s status as final'\n    },\n    [EditButtonTypes.TOGGLE_TWO_ACCEPTING]: {\n      action: () => this.props.toggleFinal(),\n      className: 'toggle-two-accepting',\n      title: 'toggle states\\' statuses as final',\n    },\n    [EditButtonTypes.TOGGLE_MANY_ACCEPTING]: {\n      action: () => this.props.toggleFinal(),\n      className: 'toggle-many-accepting',\n      title: 'toggle states\\' statuses as final',\n    },\n  };\n}\n\nconst mapStateToProps = (state: State) => ({\n  inEditMode: isInEditMode(state),\n  buttonTypes: whichButtonTypes(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  undo: () => dispatch(A.undo()),\n  redo: () => dispatch(A.redo()),\n  addState: () => dispatch(A.startAddingNode()),\n  removeStates: () => dispatch(A.deleteSelectedNodes()),\n  addTransition: () => dispatch(A.addTransitionBetweenSelected()),\n  makeStart: () => dispatch(A.makeSelectedStartNode()),\n  toggleFinal: () => dispatch(A.toggleSelectedFinalNodes()),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(EditControls);\n","import copy1 from './copy-(single-symbol).json';\nimport multiply from './multiply-(unary).json';\nimport divBy2 from './divide-by-2-(unary).json';\n\nexport default [\n  divBy2,\n  copy1,\n  multiply,\n];\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport * as A from '../state-mgmt/actions';\nimport snapshots from './examples/snapshots';\nimport './AppControls.css';\n\nexport interface AppControlsProps {\n  newMachine: () => void;\n  download: () => void;\n  upload: () => void;\n  loadExample: (snapshot: any) => void;\n}\n\nclass AppControls extends React.Component<AppControlsProps> {\n  render() {\n    return (\n      <div className=\"app-controls\">\n        <div className=\"app-controls__buttons\">\n          <button className=\"app-controls__button app-controls__new-button\"\n                  title=\"new empty machine\"\n                  onClick={this.handleNewClick} />\n          <button className=\"app-controls__button app-controls__download-button\"\n                  title=\"download machine (JSON)\"\n                  onClick={this.handleDownloadClick} />\n          <button className=\"app-controls__button app-controls__upload-button\"\n                  title=\"upload machine (JSON)\"\n                  onClick={this.handleUploadClick} />\n        </div>\n\n        <select className=\"app-controls__selector\"\n                value=\"default\"\n                onChange={this.handleExampleSelection}>\n          <option value=\"default\" disabled key=\"default\">Examples</option>\n          {snapshots.map(s => (\n            <option key={s.metaData.name} value={s.metaData.name}>{s.metaData.name}</option>\n          ))}\n        </select>\n\n        <a className=\"app-controls__link\"\n           href={`${process.env.PUBLIC_URL}/tutorial.html`}\n           target=\"_blank\"\n           rel=\"noopener noreferrer\">\n          Tutorial\n        </a>\n        <a className=\"app-controls__link\"\n           href={`${process.env.PUBLIC_URL}/guide.html`}\n           target=\"_blank\"\n           rel=\"noopener noreferrer\">\n          Guide\n        </a>\n        <a className=\"app-controls__link\"\n           href={`${process.env.PUBLIC_URL}/about.html`}\n           target=\"_blank\"\n           rel=\"noopener noreferrer\">\n          About\n        </a>\n        <a className=\"app-controls__link app-controls__source-link\"\n           href=\"https://github.com/wjlewis/tm\"\n           title=\"view source code\"\n           target=\"_blank\"\n           rel=\"noopener noreferrer\">\n          Source\n        </a>\n        <a className=\"app-controls__link app-controls__bug-link\"\n           href=\"https://github.com/wjlewis/tm/issues\"\n           title=\"report a bug\"\n           target=\"_blank\"\n           rel=\"noopener noreferrer\">\n          Report a bug\n        </a>\n      </div>\n    );\n  }\n\n  private handleNewClick = () => {\n    this.props.newMachine();\n  };\n\n  private handleDownloadClick = () => {\n    this.props.download();\n  };\n\n  private handleUploadClick = () => {\n    this.props.upload();\n  };\n\n  private handleExampleSelection = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    const snapshotName = e.target.value;\n    const snapshot = snapshots.find(s => s.metaData.name === snapshotName);\n    if (snapshot) {\n      this.props.loadExample(snapshot);\n    }\n  };\n}\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  newMachine: () => dispatch(A.newMachine()),\n  download: () => dispatch(A.downloadMachine()),\n  upload: () => dispatch(A.uploadMachine()),\n  loadExample: (snapshot: any) => dispatch(A.installSnapshot(snapshot, true)),\n});\n\nexport default connect(\n  null,\n  mapDispatchToProps,\n)(AppControls);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport classNames from 'classnames';\nimport { State } from '../state-mgmt/state';\nimport * as A from '../state-mgmt/actions';\nimport { tapeEntries, focusedTapeCell, CELL_WIDTH, VISIBLE_CELL_COUNT } from '../state-mgmt/Tape';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport { activeTapeCell, isTapeWriting, simInterval } from '../state-mgmt/Sim';\nimport './Tape.css';\n\nexport interface TapeProps {\n  entries: string[];\n  isEditable: boolean;\n  focusedCell: null | number;\n  activeCell: number;\n  isWriting: boolean;\n  simInterval: number;\n  changeCell: (pos: number, value: string) => void;\n  updateScrollLeft: (scrollLeft: number) => void;\n  focusCell: (pos: number) => void;\n  clear: () => void;\n}\n\nclass Tape extends React.Component<TapeProps> {\n  private tapeRef: React.RefObject<HTMLDivElement> = React.createRef();\n\n  render() {\n    const { isEditable } = this.props;\n\n    const cellClassName = (index: number) => classNames('tape__cell', {\n      'tape__cell--editable': isEditable,\n      'tape__cell--active': !isEditable && index === this.props.activeCell,\n    });\n\n    const leftPaddingWidth = CELL_WIDTH * VISIBLE_CELL_COUNT / 2;\n\n    return (\n      <>\n        {this.renderReadHead()}\n        <div className=\"tape\"\n             ref={this.tapeRef}\n             onScroll={this.handleScroll}\n             style={{ width: `${CELL_WIDTH * VISIBLE_CELL_COUNT}px` }}>\n          <div className=\"tape__cells\">\n            <div className=\"tape__padding-left\" style={{ width: leftPaddingWidth }}>\n            &ensp;this half intentionally left blank\n            </div>\n            {this.props.entries.map((l, i) => (\n              <input key={i}\n                     disabled={!this.props.isEditable}\n                     className={cellClassName(i)}\n                     value={l}\n                     placeholder=\"\"\n                     onChange={this.handleCellChange(i)}\n                     onFocus={this.handleCellFocus(i)}\n                     style={{ width: `${CELL_WIDTH}px` }}\n                     type=\"text\"\n                     maxLength={1} />\n            ))}\n            <div className=\"tape__padding-right\" style={{ width: `${CELL_WIDTH / 2}px` }} />\n          </div>\n        </div>\n        {this.renderFeeders()}\n        {this.renderClearButton()}\n        {this.renderReadWriteOverlay()}\n      </>\n    );\n  }\n\n  componentDidMount() {\n    if (this.tapeRef.current) {\n      this.tapeRef.current.scrollTo(CELL_WIDTH / 2, 0);\n    }\n  }\n\n  componentDidUpdate(oldProps: TapeProps) {\n    if (oldProps.focusedCell !== this.props.focusedCell && this.props.focusedCell !== null) {\n      this.updateFocus();\n    }\n    if (oldProps.activeCell !== this.props.activeCell) {\n      this.centerActive(true);\n    }\n    // If we've just switched into \"sim\" mode, we need to recenter the tape\n    if (oldProps.isEditable !== this.props.isEditable && !this.props.isEditable) {\n      this.centerActive(false);\n    }\n  }\n\n  // After typing a character, we move the focus to the next available cell.\n  // This allows a user to use the tape almost like a normal text input.\n  private updateFocus() {\n    if (this.tapeRef.current) {\n      const cellContainer = this.tapeRef.current.childNodes[0];\n      const cellToFocus = cellContainer.childNodes[this.props.focusedCell as number + 1];\n      if (cellToFocus) (cellToFocus as HTMLInputElement).focus();\n    }\n  }\n\n  private handleCellChange(pos: number) {\n    return (e: React.ChangeEvent<HTMLInputElement>) => {\n      // We don't allow the user to input spaces, since they appear identical to\n      // the empty string and therefore create a lot of confusion.\n      if (e.target.value === ' ') return;\n      this.props.changeCell(pos, e.target.value);\n    };\n  }\n\n  private handleCellFocus(pos: number) {\n    return () => {\n      this.props.focusCell(pos);\n    };\n  }\n\n  private handleScroll = (e: any) => {\n    this.props.updateScrollLeft(e.target.scrollLeft);\n  };\n\n  private handleClearButtonClick = () => {\n    this.props.clear();\n  };\n\n  private centerActive(smooth: boolean) {\n    if (this.tapeRef.current) {\n      // To center the current read/write cell, we scroll to the left according\n      // to the index of the active cell and add half a cell's width to that\n      // (this accounts for the buffer on the lefthand side).\n      const scrollLeft = this.props.activeCell * CELL_WIDTH + CELL_WIDTH / 2;\n      this.tapeRef.current.scrollTo({\n        left: scrollLeft,\n        top: 0,\n        behavior: smooth ? 'smooth' : 'auto',\n      });\n    }\n  }\n\n  // The read head and feeders exist entirely for aesthetic reasons; they are\n  // also unfortunately complicated-looking, due to the fact that they must be\n  // positioned outside of the tape itself. For these reasons, I've relegated\n  // them to these separate definitions.\n  private renderReadHead() {\n    const className = classNames('tape-reader', {\n      'tape-reader--active': !this.props.isEditable,\n    });\n    return (\n      <div className={className}\n           style={{\n             position: 'absolute',\n             left: `calc(50% - ${CELL_WIDTH / 2}px)`,\n           }} />\n    );\n  }\n\n  private renderReadWriteOverlay() {\n    const className = classNames('tape-read-write-overlay', {\n      'tape-read-write-overlay--writing': this.props.isWriting,\n    });\n    return (\n      <div className={className}\n           style={{\n             position: 'absolute',\n             left: `calc(50% - ${CELL_WIDTH / 2}px)`,\n             animationDuration: `${this.props.simInterval / 2}ms`,\n           }} />\n    );\n  }\n\n  private renderClearButton() {\n    return (\n      <button className=\"tape__clear-button\"\n              title=\"clear tape contents\"\n              onClick={this.handleClearButtonClick}\n              style={{\n                position: 'absolute',\n                right: `calc(50% - ${CELL_WIDTH * VISIBLE_CELL_COUNT / 2 + 70}px)`,\n              }} />\n    );\n  }\n\n  private renderFeeders() {\n    const FEEDER_WIDTH = 12;\n    return (\n      <>\n        <div className=\"tape-feed tape-feed__left\"\n             style={{\n               position: 'absolute',\n               left: `calc(50% - ${CELL_WIDTH * VISIBLE_CELL_COUNT / 2 + FEEDER_WIDTH / 2}px)`,\n             }} />\n        <div className=\"tape-feed tape-feed__right\"\n             style={{\n               position: 'absolute',\n               right: `calc(50% - ${CELL_WIDTH * VISIBLE_CELL_COUNT / 2 + FEEDER_WIDTH / 2}px)`,\n             }} />\n      </>\n    );\n  }\n}\n\nconst mapStateToProps = (state: State) => ({\n  entries: tapeEntries(state),\n  isEditable: isInEditMode(state),\n  focusedCell: focusedTapeCell(state),\n  activeCell: activeTapeCell(state),\n  isWriting: isTapeWriting(state),\n  simInterval: simInterval(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  changeCell: (pos: number, value: string) => dispatch(A.changeTapeCell(pos, value)),\n  updateScrollLeft: (scrollLeft: number) => dispatch(A.updateScrollLeft(scrollLeft)),\n  focusCell: (pos: number) => dispatch(A.focusTapeCell(pos)),\n  clear: () => dispatch(A.clearTape()),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(Tape);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport classNames from 'classnames';\nimport { State } from '../state-mgmt/state';\nimport * as A from '../state-mgmt/actions';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport { MAX_SIM_DIVISOR, simIntervalDivisor } from '../state-mgmt/Sim';\nimport './SimControls.css';\n\nexport interface SimControlsProps {\n  isInEditMode: boolean;\n  intervalDivisor: number;\n  reset: () => void;\n  resetRunning: () => void;\n  pause: () => void;\n  step: () => void;\n  play: () => void;\n  setIntervalDivisor: (divisor: number) => void;\n}\n\nclass SimControls extends React.Component<SimControlsProps> {\n  render() {\n    const { isInEditMode } = this.props;\n    const playPauseClassName = classNames(\n      'sim-controls__button', \n      isInEditMode ? 'sim-controls__play-button' : 'sim-controls__pause-button',\n    );\n\n    return (\n      <div className=\"sim-controls\">\n        <button className=\"sim-controls__button sim-controls__reset-button\"\n                title=\"reset simulation\"\n                onClick={this.reset} />\n        <button className={playPauseClassName}\n                title={isInEditMode ? 'play simulation' : 'pause simulation'}\n                onClick={this.togglePlayPause} />\n        <button className=\"sim-controls__button sim-controls__step-button\"\n                title=\"run a single step of the simulation\"\n                disabled={!isInEditMode}\n                onClick={this.step} />\n        <div className=\"sim-controls__speed-control\">\n          <span className=\"sim-controls__speed-control-label\">slow</span>\n          <input type=\"range\"\n                 value={this.props.intervalDivisor}\n                 min={1}\n                 max={MAX_SIM_DIVISOR}\n                 onChange={this.handleSpeedChange} />\n          <span className=\"sim-controls__speed-control-label\">fast</span>\n        </div>\n      </div>\n    );\n  }\n\n  private reset = () => {\n    if (this.props.isInEditMode) {\n      return this.props.reset();\n    } else {\n      return this.props.resetRunning();\n    }\n  };\n\n  private togglePlayPause = () => {\n    if (this.props.isInEditMode) this.props.play();\n    else this.props.pause();\n  };\n\n  private step = () => {\n    this.props.step();\n  };\n\n  private handleSpeedChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    this.props.setIntervalDivisor(Number(e.target.value));\n  };\n}\n\nconst mapStateToProps = (state: State) => ({\n  isInEditMode: isInEditMode(state),\n  intervalDivisor: simIntervalDivisor(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  reset: () => dispatch(A.resetSim()),\n  resetRunning: () => dispatch(A.resetRunningSim()),\n  pause: () => dispatch(A.pauseSim()),\n  step: () => dispatch(A.stepSim()),\n  play: () => dispatch(A.playSim()),\n  setIntervalDivisor: (divisor: number) => dispatch(A.setSimIntervalDivisor(divisor)),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(SimControls);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport { State } from '../state-mgmt/state';\nimport * as A from '../state-mgmt/actions';\nimport { machineName } from '../state-mgmt/MetaData';\nimport './NameInput.css';\n\nexport interface NameInputProps {\n  name: string;\n  changeName: (name: string) => void;\n}\n\nclass NameInput extends React.Component<NameInputProps> {\n  render() {\n    return (\n      <input className=\"name-input\"\n             type=\"text\"\n             value={this.props.name}\n             onChange={this.handleNameChange}\n             placeholder=\"Machine name\" />\n    );\n  }\n\n  private handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    this.props.changeName(e.target.value);\n  };\n}\n\nconst mapStateToProps = (state: State) => ({\n  name: machineName(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  changeName: (name: string) => dispatch(A.changeMachineName(name)),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(NameInput);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport { State } from '../state-mgmt/state';\nimport * as A from '../state-mgmt/actions';\nimport { showMessage, messageTitle, messageContent } from '../state-mgmt/Message';\nimport './Message.css';\n\nexport interface MessageProps {\n  show: boolean;\n  title: null | string;\n  content: null | string | JSX.Element;\n  dismiss: () => void;\n}\n\nclass Message extends React.Component<MessageProps> {\n  render() {\n    return this.props.show && (\n      <div className=\"message__container\" onClick={this.dismiss}>\n        <div className=\"message\" onClick={this.handleMessageClick}>\n          <h1 className=\"message__title\">{this.props.title}</h1>\n          <div className=\"message__content\">{this.props.content}</div>\n          <button className=\"message__dismiss-button\"\n                  onClick={this.dismiss}>\n            Dismiss\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  private handleMessageClick = (e: React.MouseEvent) => {\n    e.stopPropagation();\n  };\n\n  private dismiss = () => {\n    this.props.dismiss();\n  };\n}\n\nconst mapStateToProps = (state: State) => ({\n  show: showMessage(state),\n  title: messageTitle(state),\n  content: messageContent(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  dismiss: () => dispatch(A.dismissMessage()),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(Message);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport * as A from '../state-mgmt/actions';\nimport Canvas from '../Canvas/Canvas';\nimport EditControls from '../EditControls/EditControls';\nimport AppControls from '../AppControls/AppControls';\nimport Tape from '../Tape/Tape';\nimport SimControls from '../SimControls/SimControls';\nimport NameInput from '../NameInput/NameInput';\nimport Message from '../Message/Message';\nimport './App.css';\n\n// The entire app consists of only a few components: a \"canvas\" for displaying\n// the machine state editing UI, the machine's tape, some buttons that perform\n// various editing tasks, and some buttons for starting, pausing, stepping, and\n// resetting the machine.\n\nexport interface AppProps {\n  keyDown: (key: string, event: React.KeyboardEvent) => void;\n  keyUp: (key: string) => void;\n  loadSaved: () => void;\n}\n\nclass App extends React.Component<AppProps> {\n  render() {\n    return (\n      <div className=\"app\">\n        <Canvas />\n        <NameInput />\n        <Tape />\n        <EditControls />\n        <AppControls />\n        <SimControls />\n        <Message />\n      </div>\n    );\n  }\n\n  // We add the keyboard listeners to the document so that the user does not\n  // need to focus any element before keypresses can be recorded.\n  componentDidMount() {\n    document.addEventListener('keydown', this.handleKeyDown as unknown as EventListener);\n    document.addEventListener('keyup', this.handleKeyUp as unknown as EventListener);\n    this.props.loadSaved();\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('keydown', this.handleKeyDown as unknown as EventListener);\n    document.removeEventListener('keyup', this.handleKeyUp as unknown as EventListener);\n  }\n\n  private handleKeyDown = (e: React.KeyboardEvent) => {\n    this.props.keyDown(e.key, e);\n  };\n\n  private handleKeyUp = (e: React.KeyboardEvent) => {\n    this.props.keyUp(e.key);\n  };\n}\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  keyDown: (key: string, event: React.KeyboardEvent) => dispatch(A.keyDown(key, event)),\n  keyUp: (key: string) => dispatch(A.keyUp(key)),\n  loadSaved: () => dispatch(A.loadSnapshot()),\n});\n\nexport default connect(\n  null,\n  mapDispatchToProps,\n)(App);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport store from './state-mgmt/store';\nimport App from './App/App';\nimport './index.css';\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}