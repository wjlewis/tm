{"version":3,"sources":["state-mgmt/actions.ts","state-mgmt/auxiliary.ts","tools/Vector.ts","state-mgmt/Mode.ts","state-mgmt/UI.ts","state-mgmt/Node.ts","tools/auxiliary.ts","state-mgmt/Arrow.ts","state-mgmt/ControlPoint.ts","state-mgmt/TransitionDetail.ts","state-mgmt/Tape.ts","state-mgmt/UndoRedo.ts","state-mgmt/Message.ts","state-mgmt/Sim.ts","state-mgmt/state.ts","state-mgmt/reducer.ts","state-mgmt/middleware/keyboardShortcuts.ts","ErrorReport/ErrorReport.tsx","ErrorReport/MissingStartState.tsx","ErrorReport/NondeterministicTransition.tsx","HaltReport/HaltReport.tsx","HaltReport/Accept.tsx","HaltReport/Reject.tsx","state-mgmt/saga.ts","state-mgmt/store.ts","state-mgmt/middleware/addTransition.ts","state-mgmt/middleware/deleteTransitionDetail.ts","state-mgmt/middleware/deleteNode.ts","state-mgmt/middleware/validateTransitionDetails.ts","state-mgmt/middleware/validatePreSim.ts","state-mgmt/middleware/halt.ts","Arrow/Arrow.tsx","Node/Node.tsx","ControlPoint/ControlPoint.tsx","TransitionDetail/TransitionDetail.tsx","TransitionDetails/TransitionDetails.tsx","ShadowNode/ShadowNode.tsx","Canvas/Canvas.tsx","state-mgmt/EditControls.ts","EditControls/EditControls.tsx","AppControls/AppControls.tsx","Tape/Tape.tsx","SimControls/SimControls.tsx","Message/Message.tsx","App/App.tsx","index.tsx"],"names":["addTransitionDetail","arrow","type","payload","moveTape","direction","writeTapeSymbol","symbol","deleteEntities","nodes","arrows","controlPoints","transitionDetails","displayMessage","title","content","STEP_SIM","PLAY_SIM","PAUSE_SIM","RESET_SIM","setCurrentState","id","setActiveNode","setActiveTransitionDetail","setActiveControlPoint","setActiveArrow","HALT_ACCEPT","haltAccept","HALT_REJECT","haltReject","switchMode","mode","currentLatest","state","wip","committed","Vector","x","y","Math","sqrt","this","len","magnitude","Error","v","plus","scale","factor","atan2","dot","Modes","EDIT","SIM","initModeState","isInEditMode","modeReducer","action","initUIState","mousePos","keysDown","isMouseDownNode","isMouseDownControlPoint","isAddingNode","wasMouseReleasedOverNode","wasMouseDragged","wasMnemonicChanged","ui","isMultiselect","includes","uiReducer","keyDown","key","keyUp","mouseDownNode","mouseUpNode","mouseDownControlPoint","mouseUpControlPoint","mouseDownCanvas","mouseUpCanvas","startAddingNode","addNode","mouseMoveCanvas","pos","changeMnemonic","blurMnemonic","_","uniq","filter","k","allNodes","Object","values","entities","byId","nodeById","node","find","n","isNodeSelected","selected","isNodeFinal","isFinal","selectedNodes","isStartNode","startNode","nodesReducer","makeStartNode","toggleFinalNodes","value","uuid","mnemonic","mergeWith","_1","_2","undefined","ids","omit","merge","map","atLeastOneFinal","some","updated","reduce","acc","xs","offsets","nodeId","minus","moved","keys","updatedPos","allArrows","arrowById","arrowsReducer","addArrow","start","end","allControlPoints","controlPointForArrow","arrowId","cp","controlPointsReducer","mouseUpNodeOrCanvas","startPos","endPos","controlPos","diff","perp","normalize","constructStandardPos","selectedOffset","prepForDirectMove","prepForIndirectMove","fullOffsets","controlPoint","halfOffsets","p","includesStart","includesEnd","fixedPos","movingPos","movingOffset","toCP","cpShadow","project","fractionAlong","perpLength","moveDirect","moveIndirect","fullMoved","halfMoved","newPos","alongDiff","allTransitionDetails","allGroupedTransitionDetails","groupBy","detail","transitionDetailsForArrow","duplicateTransitionDetails","duplicates","transitionDetailsByStart","ds","read","group","length","flattenDeep","focusedDetail","focused","transitionDetailsReducer","changeTransitionDetail","deleteTransitionDetail","focusTransitionDetail","blurTransitionDetail","markDuplicateTransitions","write","move","isFocused","mapValues","isDuplicate","tapeEntries","tape","entries","tapeCenter","center","currentReadSymbol","tapeReducer","setTapeCenter","changeTapeCell","update","clone","set","undoRedoReducer","undoRedo","addRecord","undo","actions","record","rest","redoRecord","getSnapshot","revertToSnapshot","redoable","redo","undoRecord","description","slice","get","snapshot","showMessage","message","show","messageTitle","messageContent","messageReducer","dismissMessage","currentState","sim","isNodeActive","activeNode","isArrowActive","activeArrow","isControlPointActive","activeControlPoint","activeTransitionDetail","simReducer","A","resetSim","initState","reducer","keyBindings","st","e","ctrlKey","preventDefault","metaKey","ErrorReport","className","props","whatsWrong","howToFix","React","Component","HaltReport","wasSuccess","accepted","play","playSim","makeStep","saga","singleStep","fork","playTask","take","cancel","put","select","current","readSymbol","availableTransitionInfo","transitionInfo","interval","delay","endId","controlPointId","transitionDetailId","writeSymbol","tapeDirection","outgoing","arrowsForStart","flatten","takeEvery","sagaMiddleware","createSagaMiddleware","store","createStore","composeWithDevTools","applyMiddleware","api","next","getState","event","keyHandler","altAction","existingArrow","startId","a","arrowForEndpoints","nodeIds","arrowsForNode","arrowIds","controlPointIds","transitionDetailIds","hasStartNode","NondeterministicTransition","MissingStartState","Accept","Reject","run","Arrow","classNames","isEditable","isActive","pathString","isSelfLoop","computeCubicPathString","computeQuadraticPathString","d","control","mid","bezierControl","v1","v2","ctrl1","ctrl2","connect","ownProps","details","Node","handleMouseDown","mouseDown","handleMouseUp","mouseUp","handleInputChange","evt","target","handleInputBlur","isSelected","isStart","mnemonicClassName","mnemonicPos","NODE_RADIUS","onMouseDown","onMouseUp","style","position","left","top","disabled","onChange","onBlur","maxLength","dispatch","ControlPoint","computeCubicString","p1","p2","tip","ARROW_LENGTH","TransitionDetail","readRef","createRef","handleSelectChange","handleFocus","onFocus","handleBlur","handleDeleteClick","onDelete","inputClassName","readInputClassName","selectorClassName","ref","onClick","focus","property","TransitionDetails","handleDetailChange","changeDetail","stance","computeStance","isTopStance","renderAddDetailButton","activeDetail","handleDetailDelete","handleDetailFocus","handleDetailBlur","deleteDetail","focusDetail","blurDetail","addDetail","computeSelfLoopStance","computeStandardStance","theta","angle","computeClassNameFromAngle","PI","anchor","test","handleAddDetailButton","ShadowNode","add","isVisible","Canvas","computeMousePos","handleMouseMove","mouseMove","onMouseMove","xmlns","width","height","currentTarget","getBoundingClientRect","clientX","clientY","whichButtonTypes","EditButtonTypes","ADD_STATE","REMOVE_STATE","ADD_SELF_TRANSITION","MAKE_START","TOGGLE_ACCEPTING","REMOVE_STATES","ADD_TRANSITION","UNMAKE_START","EditControls","addState","removeStates","addTransition","makeStart","toggleFinal","inEditMode","buttonTypes","AppControls","href","rel","Tape","tapeRef","cellClassName","CELL_WIDTH","l","i","handleCellFocus","handleCellChange","recenter","oldProps","index","setCenter","changeCell","smooth","cellGap","CELL_COUNT","scrollTo","behavior","SimControls","reset","togglePlayPause","pause","step","Message","handleMessageClick","stopPropagation","dismiss","App","handleKeyDown","handleKeyUp","document","addEventListener","removeEventListener","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.fe1679ee.chunk.js","sourcesContent":["import Vector from '../tools/Vector';\nimport { TransitionDetail as TransitionDetailInfo } from './TransitionDetail';\nimport { Mode } from './Mode';\n\n// Many actions are specific to a particular part of the state (e.g. to nodes,\n// or arrows), and I've grouped these for easy access. However, a number of\n// actions are more general; these I've placed at the bottom of the file.\n\nexport interface Action {\n  type: string;\n  payload?: any;\n}\n\n// Node actions:\nexport const MOUSE_DOWN_NODE = 'MOUSE_DOWN_NODE';\nexport const mouseDownNode = (id: string): Action => ({\n  type: MOUSE_DOWN_NODE,\n  payload: { id },\n});\n\nexport const MOUSE_UP_NODE = 'MOUSE_UP_NODE';\nexport const mouseUpNode = (): Action => ({\n  type: MOUSE_UP_NODE,\n});\n\n// We have 2 actions related to adding a node instead of one: the first\n// indicates that the user is in the process of adding a node, but has not yet\n// fixed its placement on the screen; the second indicates that the node should\n// be added at a particular location -- where the user has clicked.\nexport const START_ADDING_NODE = 'START_ADDING_NODE';\nexport const startAddingNode = (): Action => ({\n  type: START_ADDING_NODE,\n});\n\nexport const ADD_NODE = 'ADD_NODE';\nexport const addNode = (pos: Vector): Action => ({\n  type: ADD_NODE,\n  payload: { pos },\n});\n\nexport const CHANGE_MNEMONIC = 'CHANGE_MNEMONIC';\nexport const changeMnemonic = (id: string, value: string): Action => ({\n  type: CHANGE_MNEMONIC,\n  payload: { id, value },\n});\n\nexport const BLUR_MNEMONIC = 'BLUR_MNEMONIC';\nexport const blurMnemonic = (): Action => ({\n  type: BLUR_MNEMONIC,\n});\n\nexport const DELETE_SELECTED_NODES = 'DELETE_SELECTED_NODES';\nexport const deleteSelectedNodes = (): Action => ({\n  type: DELETE_SELECTED_NODES,\n});\n\nexport const MAKE_SELECTED_START_NODE = 'MAKE_SELECTED_START_NODE';\nexport const makeSelectedStartNode = (): Action => ({\n  type: MAKE_SELECTED_START_NODE,\n});\n\nexport const TOGGLE_SELECTED_FINAL_NODES = 'TOGGLE_SELECTED_FINAL_NODES';\nexport const toggleSelectedFinalNodes = (): Action => ({\n  type: TOGGLE_SELECTED_FINAL_NODES,\n});\n\n// Arrow actions:\n// We include the arrow's ID as part of the payload because when we create a new\n// arrow, we also create a control point and transition detail for it as well\n// (and these require the arrow's ID).\nexport const ADD_ARROW = 'ADD_ARROW';\nexport const addArrow = (start: string, end: string, id: string): Action => ({\n  type: ADD_ARROW,\n  payload: { start, end, id },\n});\n\n// Control point actions:\nexport const MOUSE_DOWN_CONTROL_POINT = 'MOUSE_DOWN_CONTROL_POINT';\nexport const mouseDownControlPoint = (id: string): Action => ({\n  type: MOUSE_DOWN_CONTROL_POINT,\n  payload: { id },\n});\n\nexport const MOUSE_UP_CONTROL_POINT = 'MOUSE_UP_CONTROL_POINT';\nexport const mouseUpControlPoint = (): Action => ({\n  type: MOUSE_UP_CONTROL_POINT,\n});\n\n// Transition-detail actions:\nexport const CHANGE_TRANSITION_DETAIL = 'CHANGE_TRANSITION_DETAIL';\nexport const changeTransitionDetail = (detail: TransitionDetailInfo): Action => ({\n  type: CHANGE_TRANSITION_DETAIL,\n  payload: { detail },\n});\n\nexport const ADD_TRANSITION_DETAIL = 'ADD_TRANSITION_DETAIL';\nexport const addTransitionDetail = (arrow: string): Action => ({\n  type: ADD_TRANSITION_DETAIL,\n  payload: { arrow },\n});\n\nexport const DELETE_TRANSITION_DETAIL = 'DELETE_TRANSITION_DETAIL';\nexport const deleteTransitionDetail = (id: string, arrow: string): Action => ({\n  type: DELETE_TRANSITION_DETAIL,\n  payload: { id, arrow },\n});\n\nexport const FOCUS_TRANSITION_DETAIL = 'FOCUS_TRANSIITON_DETAIL';\nexport const focusTransitionDetail = (id: string): Action => ({\n  type: FOCUS_TRANSITION_DETAIL,\n  payload: { id },\n});\n\nexport const BLUR_TRANSITION_DETAIL = 'BLUR_TRANSITION_DETAIL';\nexport const blurTransitionDetail = (id: string): Action => ({\n  type: BLUR_TRANSITION_DETAIL,\n  payload: { id },\n});\n\nexport const MARK_DUPLICATE_TRANSITIONS = 'MARK_DUPLICATE_TRANSITIONS';\nexport const markDuplicateTransitions = (ids: string[]): Action => ({\n  type: MARK_DUPLICATE_TRANSITIONS,\n  payload: { ids },\n});\n\n// Tape actions:\nexport const SET_TAPE_CENTER = 'SET_TAPE_CENTER';\nexport const setTapeCenter = (pos: number): Action => ({\n  type: SET_TAPE_CENTER,\n  payload: { pos },\n});\n\nexport const CHANGE_TAPE_CELL = 'CHANGE_TAPE_CELL';\nexport const changeTapeCell = (pos: number, value: string): Action => ({\n  type: CHANGE_TAPE_CELL,\n  payload: { pos, value },\n});\n\nexport const MOVE_TAPE = 'MOVE_TAPE';\nexport const moveTape = (direction: 'L' | 'R'): Action => ({\n  type: MOVE_TAPE,\n  payload: { direction },\n});\n\nexport const WRITE_TAPE_SYMBOL = 'WRITE_TAPE_SYMBOL';\nexport const writeTapeSymbol = (symbol: string): Action => ({\n  type: WRITE_TAPE_SYMBOL,\n  payload: { symbol },\n});\n\n// Canvas and UI actions:\nexport const MOUSE_DOWN_CANVAS = 'MOUSE_DOWN_CANVAS';\nexport const mouseDownCanvas = (pos: Vector): Action => ({\n  type: MOUSE_DOWN_CANVAS,\n  payload: { pos },\n});\n\nexport const MOUSE_UP_CANVAS = 'MOUSE_UP_CANVAS';\nexport const mouseUpCanvas = (): Action => ({\n  type: MOUSE_UP_CANVAS,\n});\n\nexport const MOUSE_MOVE_CANVAS = 'MOUSE_MOVE_CANVAS';\nexport const mouseMoveCanvas = (pos: Vector): Action => ({\n  type: MOUSE_MOVE_CANVAS,\n  payload: { pos },\n});\n\nexport const KEY_DOWN = 'KEY_DOWN';\nexport const keyDown = (key: string, event: React.KeyboardEvent): Action => ({\n  type: KEY_DOWN,\n  payload: { key, event },\n});\n\nexport const KEY_UP = 'KEY_UP';\nexport const keyUp = (key: string): Action => ({\n  type: KEY_UP,\n  payload: { key },\n});\n\n// General actions:\nexport const ADD_TRANSITION_BETWEEN_SELECTED = 'ADD_TRANSITION_BETWEEN_SELECTED';\nexport const addTransitionBetweenSelected = (): Action => ({\n  type: ADD_TRANSITION_BETWEEN_SELECTED,\n});\n\nexport const DELETE_ENTITIES = 'DELETE_ENTITIES';\nexport const deleteEntities = (nodes: string[], arrows: string[], controlPoints: string[], transitionDetails: string[]): Action => ({\n  type: DELETE_ENTITIES,\n  payload: { nodes, arrows, controlPoints, transitionDetails },\n});\n\nexport const UNDO = 'UNDO';\nexport const undo = (): Action => ({\n  type: UNDO,\n});\n\nexport const REDO = 'REDO';\nexport const redo = (): Action => ({\n  type: REDO,\n});\n\nexport const DISPLAY_MESSAGE = 'DISPLAY_MESSAGE';\nexport const displayMessage = (title: string, content?: string | JSX.Element): Action => ({\n  type: DISPLAY_MESSAGE,\n  payload: { title, content },\n});\n\nexport const DISMISS_MESSAGE = 'DISMISS_MESSAGE';\nexport const dismissMessage = (): Action => ({\n  type: DISMISS_MESSAGE,\n});\n\n// Simulation actions:\nexport const STEP_SIM = 'STEP_SIM';\nexport const stepSim = (): Action => ({\n  type: STEP_SIM,\n});\n\nexport const PLAY_SIM = 'PLAY_SIM';\nexport const playSim = (): Action => ({\n  type: PLAY_SIM,\n});\n\nexport const PAUSE_SIM = 'PAUSE_SIM';\nexport const pauseSim = (): Action => ({\n  type: PAUSE_SIM,\n});\n\nexport const RESET_SIM = 'RESET_SIM';\nexport const resetSim = (): Action => ({\n  type: RESET_SIM,\n});\n\nexport const SET_CURRENT_STATE = 'SET_CURRENT_STATE';\nexport const setCurrentState = (id: string): Action => ({\n  type: SET_CURRENT_STATE,\n  payload: { id },\n});\n\nexport const SET_ACTIVE_NODE = 'SET_ACTIVE_NODE';\nexport const setActiveNode = (id: null | string): Action => ({\n  type: SET_ACTIVE_NODE,\n  payload: { id },\n});\n\nexport const SET_ACTIVE_TRANSITION_DETAIL = 'SET_ACTIVE_TRANSITION_DETAIL';\nexport const setActiveTransitionDetail = (id: null | string): Action => ({\n  type: SET_ACTIVE_TRANSITION_DETAIL,\n  payload: { id },\n});\n\nexport const SET_ACTIVE_CONTROL_POINT = 'SET_ACTIVE_CONTROL_POINT';\nexport const setActiveControlPoint = (id: null | string): Action => ({\n  type: SET_ACTIVE_CONTROL_POINT,\n  payload: { id },\n});\n\nexport const SET_ACTIVE_ARROW = 'SET_ACTIVE_ARROW';\nexport const setActiveArrow = (id: null | string): Action => ({\n  type: SET_ACTIVE_ARROW,\n  payload: { id },\n});\n\nexport const HALT_ACCEPT = 'HALT_ACCEPT';\nexport const haltAccept = (): Action => ({\n  type: HALT_ACCEPT,\n});\n\nexport const HALT_REJECT = 'HALT_REJECT';\nexport const haltReject = (): Action => ({\n  type: HALT_REJECT,\n});\n\n// Mode actions:\nexport const SWITCH_MODE = 'SWITCH_MODE';\nexport const switchMode = (mode: Mode): Action => ({\n  type: SWITCH_MODE,\n  payload: { mode },\n});\n","// This file contains state-management functions and type definitions that are\n// general-purpose enough to be useful in a number of places.\n\n// In many cases, we choose to maintain not one but TWO intances of some part of\n// the state. Here is an example illustrating why: suppose we move a node from\n// one position to another. On the one hand, we need the current node position\n// to be maintained in the state so that we can display it properly. On the\n// other hand, we don't want to replace its previous (pre-move) position,\n// because this information is useful for undo/redo purposes. Our solution is to\n// maintain a \"work-in-progress\" (wip) state for these transient changes, and a\n// \"committed\" state that always contains the last meaningful snapshot of the\n// state.\nexport interface Transient<A> {\n  wip: null | A;\n  committed: A;\n}\n\n// The wip state, if it is non-null, is always more up-to-date than the last\n// commit. If the wip state is nonexistent, we simply fall back on the last\n// commit.\nexport const currentLatest = <A>(state: Transient<A>): A => (\n  state.wip || state.committed\n);\n\n// This interface represents any type that has a string ID (e.g. any of the\n// \"entities\" in our application state).\nexport interface IDAble {\n  id: string;\n}\n","// Much of the work in rendering the components in this app can be reduced by\n// expressing positions and operations in vector form. This class provides all\n// the functionality we need in this regard in a self-contained package.\n\nclass Vector {\n  constructor(public x: number, public y: number) {}\n\n  // Return the length of this vector.\n  magnitude() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n  // Return a unit vector that shares this vector's direction\n  normalize() {\n    const len = this.magnitude();\n    if (len === 0) {\n      throw new Error('Cannot normalize 0 vector');\n    }\n    return new Vector(this.x / len, this.y / len);\n  }\n\n  // Return a vector perpendicular to this vector (with the same length). NOTE:\n  // this effectively rotates the vector 90 deg clockwise.\n  perp() {\n    return new Vector(-this.y, this.x);\n  }\n\n  // Return the sum of this vector and the input.\n  plus(v: Vector) {\n    return new Vector(this.x + v.x, this.y + v.y);\n  }\n\n  // Return the difference between this vector and the input.\n  minus(v: Vector) {\n    return this.plus(v.scale(-1));\n  }\n\n  // Scale this vector by the specified amount.\n  scale(factor: number) {\n    return new Vector(factor * this.x, factor * this.y);\n  }\n\n  // Return this vector's angle.\n  angle() {\n    return Math.atan2(this.y, this.x);\n  }\n\n  // Project this vector onto the input vector.\n  project(v: Vector) {\n    return v.scale(this.dot(v) / v.dot(v));\n  }\n\n  // Return the dot product of this vector and the input vector.\n  dot(v: Vector) {\n    return this.x * v.x + this.y * v.y;\n  }\n}\n\nexport default Vector;\n","import { State } from './state';\nimport { Action } from './actions';\nimport * as A from './actions';\n\nexport interface ModeState {\n  mode: Mode;\n}\n\nexport type Mode = 'EDIT' | 'SIM';\n\nexport const Modes: { [key: string]: Mode } = {\n  EDIT: 'EDIT',\n  SIM: 'SIM',\n};\n\nexport const initModeState: ModeState = {\n  mode: Modes.EDIT,\n};\n\n// Test if we are currently in edit mode:\nexport const isInEditMode = (state: State): boolean => state.mode.mode === Modes.EDIT;\n\nexport const modeReducer = (state: State, action: Action): ModeState => {\n  switch (action.type) {\n    case A.SWITCH_MODE:\n      return switchMode(state, action.payload.mode);\n    default:\n      return state.mode;\n  }\n};\n\nconst switchMode = (state: State, mode: Mode): ModeState => ({\n  ...state.mode,\n  mode,\n});\n","import _ from 'lodash';\nimport { State } from './state';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport Vector from '../tools/Vector';\nimport { isInEditMode } from './Mode';\n\n// The UI state is fairly self-explanatory: it consists of miscellaneous tidbits\n// of information regarding where the mouse is, what keys are pressed, etc.\n\nexport interface UIState {\n  mousePos: Vector;\n  keysDown: string[];\n  isMouseDownNode: boolean;\n  isMouseDownControlPoint: boolean;\n  isAddingNode: boolean;\n  wasMouseReleasedOverNode: boolean;\n  wasMouseDragged: boolean;\n  wasMnemonicChanged: boolean;\n}\n\nexport const initUIState: UIState = {\n  mousePos: new Vector(0, 0),\n  keysDown: [],\n  isMouseDownNode: false,\n  isMouseDownControlPoint: false,\n  isAddingNode: false,\n  wasMouseReleasedOverNode: false,\n  wasMouseDragged: false,\n  wasMnemonicChanged: false,\n};\n\n// Return the current mouse position.\nexport const mousePos = (state: State): Vector => state.ui.mousePos;\n\n// Test if we are currently in \"multiselect\" mode.\nexport const isMultiselect = (state: State): boolean => state.ui.keysDown.includes('Shift');\n\n// Test if the mouse is currently pressed over a node.\nexport const isMouseDownNode = (state: State): boolean => state.ui.isMouseDownNode;\n\n// Test if the mouse is current pressed over a control point.\nexport const isMouseDownControlPoint = (state: State): boolean => state.ui.isMouseDownControlPoint;\n\n// Test if we are in the process of adding a node.\nexport const isAddingNode = (state: State): boolean => state.ui.isAddingNode;\n\nexport const wasMouseReleasedOverNode = (state: State): boolean => state.ui.wasMouseReleasedOverNode;\n\nexport const wasMouseDragged = (state: State): boolean => state.ui.wasMouseDragged;\n\nexport const wasMnemonicChanged = (state: State): boolean => state.ui.wasMnemonicChanged;\n\nexport const uiReducer = (state: State, action: Action): UIState => {\n  if (isInEditMode(state)) {\n    switch (action.type) {\n      case A.KEY_DOWN:\n        return keyDown(state, action.payload.key);\n      case A.KEY_UP:\n        return keyUp(state, action.payload.key);\n      case A.MOUSE_DOWN_NODE:\n        return mouseDownNode(state);\n      case A.MOUSE_UP_NODE:\n        return mouseUpNode(state);\n      case A.MOUSE_DOWN_CONTROL_POINT:\n        return mouseDownControlPoint(state);\n      case A.MOUSE_UP_CONTROL_POINT:\n        return mouseUpControlPoint(state);\n      case A.MOUSE_DOWN_CANVAS:\n        return mouseDownCanvas(state);\n      case A.MOUSE_UP_CANVAS:\n        return mouseUpCanvas(state);\n      case A.START_ADDING_NODE:\n        return startAddingNode(state);\n      case A.ADD_NODE:\n        return addNode(state);\n      case A.MOUSE_MOVE_CANVAS:\n        return mouseMoveCanvas(state, action.payload.pos);\n      case A.CHANGE_MNEMONIC:\n        return changeMnemonic(state);\n      case A.BLUR_MNEMONIC:\n        return blurMnemonic(state);\n      default:\n        return state.ui;\n    }\n  }\n  else {\n    return state.ui;\n  }\n};\n\nconst keyDown = (state: State, key: string): UIState => ({\n  ...state.ui,\n  keysDown: _.uniq([...state.ui.keysDown, key]),\n});\n\nconst keyUp = (state: State, key: string): UIState => ({\n  ...state.ui,\n  keysDown: state.ui.keysDown.filter(k => k !== key),\n});\n\nconst mouseDownNode = (state: State): UIState => ({\n  ...state.ui,\n  isMouseDownNode: true,\n});\n\nconst mouseUpNode = (state: State): UIState => ({\n  ...state.ui,\n  isMouseDownNode: false,\n  wasMouseReleasedOverNode: true,\n});\n\nconst mouseDownControlPoint = (state: State): UIState => ({\n  ...state.ui,\n  isMouseDownControlPoint: true,\n});\n\nconst mouseUpControlPoint = (state: State): UIState => ({\n  ...state.ui,\n  isMouseDownControlPoint: false,\n});\n\nconst mouseDownCanvas = (state: State): UIState => ({\n  ...state.ui,\n  wasMouseDragged: false,\n});\n\nconst mouseUpCanvas = (state: State): UIState => ({\n  ...state.ui,\n  isMouseDownNode: false,\n  isMouseDownControlPoint: false,\n  wasMouseReleasedOverNode: false,\n});\n\nconst startAddingNode = (state: State): UIState => ({\n  ...state.ui,\n  isAddingNode: true,\n});\n\nconst addNode = (state: State): UIState => ({\n  ...state.ui,\n  isAddingNode: false,\n  wasMouseReleasedOverNode: true,\n});\n\nconst mouseMoveCanvas = (state: State, pos: Vector): UIState => ({\n  ...state.ui,\n  mousePos: pos,\n  wasMouseDragged: true,\n});\n\nconst changeMnemonic = (state: State): UIState => ({\n  ...state.ui,\n  wasMnemonicChanged: true,\n});\n\nconst blurMnemonic = (state: State): UIState => ({\n  ...state.ui,\n  wasMnemonicChanged: false,\n});\n","import _ from 'lodash';\nimport uuid from 'uuid/v4';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport { Transient, currentLatest } from './auxiliary';\nimport { State } from './state';\nimport Vector from '../tools/Vector';\nimport { mod2Include } from '../tools/auxiliary';\nimport { isMultiselect, isMouseDownNode, wasMouseReleasedOverNode } from './UI';\nimport { isInEditMode } from './Mode';\n\n// A node represents a machine state in the TM formalism. Each node is\n// draggable, and may come in several different varieties (it may be the start\n// node, or an accepting/final node).\n\nexport interface NodeState extends Transient<NodeInfo> {}\n\n// The \"selected\" and \"offsets\" properties are used to store information about\n// selected nodes immediately before and during a move. The \"startNode\"\n// corresponds to the start state in the TM formalism.\nexport interface NodeInfo {\n  byId: { [key: string]: Node };\n  selected: string[];\n  offsets: { [key: string]: Vector };\n  startNode: null | string;\n}\n\nexport interface Node {\n  id: string;\n  mnemonic: string;\n  pos: Vector;\n  isFinal: boolean;\n}\n\nexport const initNodeState: NodeState = {\n  wip: null,\n  committed: {\n    byId: {},\n    selected: [],\n    offsets: {},\n    startNode: null,\n  },\n};\n\n// Return an array containing all nodes in existence.\nexport const allNodes = (state: State): Node[] => (\n  Object.values(currentLatest(state.entities.nodes).byId)\n);\n\n// Return the node with the given ID, if one exists.\nexport const nodeById = (state: State, id: string): Node => {\n  const node = allNodes(state).find(n => n.id === id);\n  if (!node) {\n    throw new Error(`No Node with ID \"${id}\"`);\n  }\n  return node;\n};\n\n// Check if the given node is currently selected.\nexport const isNodeSelected = (state: State, id: string): boolean => (\n  currentLatest(state.entities.nodes).selected.includes(id)\n);\n\n// Check if the given node is final (\"accepting\").\nexport const isNodeFinal = (state: State, id: string): boolean => (\n  currentLatest(state.entities.nodes).byId[id].isFinal\n);\n\n// Return an array containing the IDs of all selected nodes.\nexport const selectedNodes = (state: State): string[] => (\n  currentLatest(state.entities.nodes).selected\n);\n\n// Test if the given node is the start node.\nexport const isStartNode = (state: State, id: string): boolean => {\n  const { startNode } = currentLatest(state.entities.nodes);\n  return (startNode !== null) && startNode === id;\n};\n\n// Test if a node has been distinguished as the start state.\nexport const hasStartNode = (state: State): boolean => (\n  currentLatest(state.entities.nodes).startNode !== null\n);\n\nexport const startNode = (state: State): string => {\n  const start = currentLatest(state.entities.nodes).startNode;\n  if (start === null) {\n    throw new Error('No start node has been distinguished.');\n  }\n  return start;\n};\n\nexport const nodesReducer = (state: State, action: Action): NodeState => {\n  if (isInEditMode(state)) {\n    switch (action.type) {\n      // These operations affect the non-positional attributes of a node.\n      case A.ADD_NODE:\n        return addNode(state, action.payload.pos);\n      case A.DELETE_ENTITIES:\n        return deleteEntities(state, action.payload.nodes);\n      case A.MAKE_SELECTED_START_NODE:\n        return makeStartNode(state);\n      case A.TOGGLE_SELECTED_FINAL_NODES:\n        return toggleFinalNodes(state);\n      case A.CHANGE_MNEMONIC:\n        return changeMnemonic(state, action.payload.id, action.payload.value);\n      case A.BLUR_MNEMONIC:\n        return blurMnemonic(state);\n\n      // These operations deal with movement.\n      case A.MOUSE_DOWN_NODE:\n        return mouseDownNode(state, action.payload.id);\n      case A.MOUSE_UP_NODE:\n        return mouseUpNode(state);\n      case A.MOUSE_DOWN_CANVAS:\n        return mouseDownCanvas(state, action.payload.pos);\n      case A.MOUSE_UP_CANVAS:\n        return mouseUpCanvas(state);\n      case A.MOUSE_MOVE_CANVAS:\n        return mouseMoveCanvas(state, action.payload.pos);\n      default:\n        return state.entities.nodes;\n    }\n  }\n  else {\n    return state.entities.nodes;\n  }\n};\n\n// When a new node is added, we revert to the last committed state, and\n// incorporate a fresh, non-final, mnemonic-free node.\nconst addNode = (state: State, pos: Vector): NodeState => {\n  const id = uuid();\n  const node = { id, pos, mnemonic: '', isFinal: false };\n  return {\n    wip: null,\n    committed: _.mergeWith({}, state.entities.nodes.committed, {\n      byId: {\n        [id]: node,\n      },\n    // We unselect all currently selected nodes, and select the new node:\n    }, (_1, _2, key) => key === 'selected' ? [id] : undefined),\n  };\n};\n\nconst deleteEntities = (state: State, ids: string[]): NodeState => {\n  const { committed } = state.entities.nodes;\n  return {\n    wip: null,\n    committed: {\n      ...committed,\n      byId: _.omit(committed.byId, ids),\n      selected: [],\n      startNode: committed.startNode && ids.includes(committed.startNode)\n        ? null\n        : committed.startNode,\n    },\n  };\n};\n\nconst makeStartNode = (state: State): NodeState => ({\n  wip: null,\n  committed: _.merge({}, state.entities.nodes.committed, {\n    startNode: state.entities.nodes.committed.selected[0],\n  }),\n});\n\n// Toggling the \"final\" state of a set of nodes works like this: if ANY of the\n// selected nodes is currently a final node, we change all of the nodes to be\n// NON-final. Otherwise, we change all of them to be final. This correctly\n// subsumes the expected behavior for a single node as well.\nconst toggleFinalNodes = (state: State): NodeState => {\n  const selected = selectedNodes(state).map(id => nodeById(state, id));\n  const atLeastOneFinal = selected.some(node => node.isFinal);\n  const updated = selected.reduce((acc, x) => ({\n    ...acc,\n    [x.id]: { ...x, isFinal: !atLeastOneFinal },\n  }), {});\n\n  return {\n    wip: null,\n    committed: _.merge({}, state.entities.nodes.committed, {\n      byId: {\n        ...updated,\n      },\n    }),\n  };\n};\n\nconst changeMnemonic = (state: State, id: string, value: string): NodeState => ({\n  ...state.entities.nodes,\n  wip: _.merge({}, currentLatest(state.entities.nodes), {\n    byId: {\n      [id]: { mnemonic: value }\n    },\n  }),\n});\n\nconst blurMnemonic = (state: State): NodeState => ({\n  wip: null,\n  committed: currentLatest(state.entities.nodes),\n});\n\n// When the user presses the mouse over a node, we update the selection as\n// follows: if we are in \"multiselect\" mode, we add the node to the current\n// selection if it is not a member, and remove it if it is; otherwise, if the\n// current selection includes the node, we keep the current selection, and if it\n// doesn't, we throw out the current selection in favor of the clicked node.\n// This may seem complicated, or contrived, but it results in a fairly intuitive\n// behavior.\nconst mouseDownNode = (state: State, id: string): NodeState => {\n  const { nodes } = state.entities;\n  const { selected } = nodes.committed;\n  return {\n    wip: null,\n    committed: {\n      ...nodes.committed,\n      selected: isMultiselect(state)\n        ? mod2Include(id, selected)\n        : selected.includes(id) ? selected : [id],\n    },\n  };\n};\n\n// When the user releases the mouse over a Node, we replace the committed state\n// with the wip state (to account for any movement that may have occurred). We\n// also clear any offsets that may have been computed in preparation for a move.\nconst mouseUpNode = (state: State): NodeState => ({\n  wip: null,\n  committed: {\n    ...currentLatest(state.entities.nodes),\n    offsets: {},\n  },\n});\n\n// If the user has pressed the mouse over a node, this press is also received by\n// the canvas. In this case, we prepare for any movement by computing offsets\n// for each of the selected nodes.\nconst mouseDownCanvas = (state: State, mousePos: Vector): NodeState => {\n  if (!isMouseDownNode(state)) return state.entities.nodes;\n\n  const { nodes } = state.entities;\n  const offsets = nodes.committed.selected.reduce((acc, nodeId) => {\n    const node = nodes.committed.byId[nodeId];\n    return {\n      ...acc,\n      [nodeId]: node.pos.minus(mousePos),\n    };\n  }, {});\n\n  return {\n    ...nodes,\n    wip: {\n      ...nodes.committed,\n      offsets,\n    },\n  };\n};\n\n// When the mouse is released over the canvas, we deselect any selected nodes,\n// and revert to the last committed state. We can be assured that the mouse was\n// NOT released over a node, since we stopped the event from propagating in the\n// node component.\nconst mouseUpCanvas = (state: State): NodeState => (\n  wasMouseReleasedOverNode(state)\n  ? state.entities.nodes\n  : {\n    wip: null,\n    committed: {\n      ...state.entities.nodes.committed,\n      selected: [],\n    },\n  }\n);\n\n// If the mouse is moved while it is down over a node, we update all of the\n// selected nodes in the WIP state using the offsets computed when the mouse was\n// initially pressed down.\nconst mouseMoveCanvas = (state: State, mousePos: Vector): NodeState => {\n  const { nodes } = state.entities;\n\n  if (!isMouseDownNode(state) || !nodes.wip) return nodes;\n\n  // We computed each offset as the difference between the node's position and\n  // the mouse position (i.e. offset = node - mouse). Thus, to compute the new\n  // node position, we add the mouse position and the offset:\n  const moved = Object.keys(nodes.wip.offsets).reduce((acc, id) => {\n    const node = nodes.wip!.byId[id];\n    const updatedPos = mousePos.plus(nodes.wip!.offsets[id]);\n    return {\n      ...acc,\n      [id]: { ...node, pos: updatedPos },\n    };\n  }, {});\n\n  return _.merge({}, nodes, {\n    wip: {\n      byId: {\n        ...moved,\n      },\n    },\n  });\n};\n","// This file contains a number of functions that are useful for performing\n// various tasks, and are general enough not to be included alongside any of\n// their uses.\n\n// If x is a member of the Array, remove it; otherwise, add it.\nexport const mod2Include = <A>(x: A, xs: A[]): A[] => (\n  xs.includes(x) ? xs.filter(y => y !== x) : [...xs, x]\n);\n\n// X xOr Y is true if either X or Y is true, but not both.\nexport const xOr = (x: boolean, y: boolean): boolean => (\n  (x || y) && !(x && y)\n);\n","import _ from 'lodash';\nimport { State } from './state';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport { isInEditMode } from './Mode';\n\n// An arrow represents one or more transitions between two states in the\n// machine. Therefore, we can describe them using the IDs of their start and end\n// nodes (along with their own unique ID). For the most part, arrows are\n// passive: they are drawn entirely according to the positions of their start\n// and end nodes, along with their control point.\n\nexport interface ArrowState {\n  byId: { [key: string]: Arrow };\n}\n\nexport interface Arrow {\n  id: string;\n  start: string;\n  end: string;\n}\n\nexport const initArrowState: ArrowState = {\n  byId: {},\n};\n\n// Return an array containing all arrows in existence.\nexport const allArrows = (state: State): Arrow[] => (\n  Object.values(state.entities.arrows.byId)\n);\n\n// Return the arrow with the given ID.\nexport const arrowById = (state: State, id: string): Arrow => {\n  const arrow = state.entities.arrows.byId[id];\n  if (!arrow) {\n    throw new Error(`No Arrow with ID \"${id}\"`);\n  }\n  return arrow;\n};\n\n// Return an array containing all arrows associated with the given node (i.e.\n// arrows that either start or end at the node).\nexport const arrowsForNode = (state: State, nodeId: string): Arrow[] => (\n  allArrows(state).filter(arrow => arrow.start === nodeId || arrow.end === nodeId)\n);\n\n// If an arrow exists joining the two given nodes, return it; otherwise return\n// null.\nexport const arrowForEndpoints = (state: State, startId: string, endId: string): null | Arrow => {\n  const arrow = allArrows(state).find(a => a.start === startId && a.end === endId);\n  return arrow || null;\n};\n\n// Return an array containing all arrows starting at the given node.\nexport const arrowsForStart = (state: State, nodeId: string): Arrow[] => (\n  allArrows(state).filter(arrow => arrow.start === nodeId)\n);\n\nexport const arrowsReducer = (state: State, action: Action): ArrowState => {\n  if (isInEditMode(state)) {\n    switch (action.type) {\n      case A.ADD_ARROW:\n        return addArrow(state, action.payload.start, action.payload.end, action.payload.id);\n      case A.DELETE_ENTITIES:\n        return deleteEntities(state, action.payload.arrows);\n      default:\n        return state.entities.arrows;\n    }\n  }\n  else {\n    return state.entities.arrows;\n  }\n};\n\nconst addArrow = (state: State, start: string, end: string, id: string): ArrowState => (\n  _.merge({}, state.entities.arrows, {\n    byId: {\n      [id]: { start, end, id },\n    },\n  })\n);\n\nconst deleteEntities = (state: State, ids: string[]): ArrowState => ({\n  ...state.entities.arrows,\n  byId: _.omit(state.entities.arrows.byId, ids)\n});\n","import _ from 'lodash';\nimport uuid from 'uuid/v4';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport { Transient, currentLatest } from './auxiliary';\nimport { arrowById } from './Arrow';\nimport { nodeById, selectedNodes } from './Node';\nimport { isMouseDownNode, isMouseDownControlPoint } from './UI';\nimport { State } from './state';\nimport Vector from '../tools/Vector';\nimport { xOr } from '../tools/auxiliary';\nimport { isInEditMode } from './Mode';\n\n// A control point is a draggable handle associated with a particular arrow. It\n// is used to control the curve of the arrow in order to create aesthetically\n// pleasing machine layouts. Despite (or more likely, because of) the fact that\n// control points exist purely for display purposes, their management involves\n// quite a bit of computation. This is mainly due to the fact that they are\n// draggable, and also that each time a node is moved, all of the control points\n// associated with the arrows connected to the node are moved as well.\n\nexport interface ControlPointState extends Transient<ControlPointInfo> {}\n\n// A few of these items require explanation: the \"fullOffsets\" and \"halfOffsets\"\n// properties are populated when a *NODE* is moved: it turns out that when a\n// node is moved, it is quite desirable to have any control points associated\n// with arrows connected to the node move as well, and in a particular way.\nexport interface ControlPointInfo {\n  byId: { [key: string]: ControlPoint };\n  selected: null | string;\n  selectedOffset: null | Vector;\n  fullOffsets: { [key: string]: Vector };\n  halfOffsets: { [key: string]: FixedOffset };\n}\n\nexport interface ControlPoint {\n  id: string;\n  arrow: string;\n  pos: Vector;\n}\n\n// Suppose we move a node away from another node, and imagine that both of these\n// nodes are connected with an arrow. How should the control point for that\n// arrow move in order to maintain the arrow's overall \"shape\"? We have chosen\n// to move the control point as if it were \"fixed\" in a sense to the line\n// connecting the two endpoint nodes. This requires keeping track of the\n// position of the non-moving node, the position of the moving node, the\n// distance between the control point and one of the endpoints, and the\n// perpendicular distance between the line connecting the nodes and the control\n// point. The calculations for generating and restoring these offsets is spelled\n// out below.\nexport interface FixedOffset {\n  fixedPos: Vector;\n  movingOffset: Vector;\n  fractionAlong: number;\n  perpLength: number;\n}\n\nexport const initControlPointState: ControlPointState = {\n  wip: null,\n  committed: {\n    byId: {},\n    selected: null,\n    selectedOffset: null,\n    fullOffsets: {},\n    halfOffsets: {},\n  },\n};\n\n// Return an array containing all control points.\nexport const allControlPoints = (state: State): ControlPoint[] => (\n  Object.values(currentLatest(state.entities.controlPoints).byId)\n);\n\n// Return the control point for the given arrow, if one exists.\nexport const controlPointForArrow = (state: State, arrowId: string): ControlPoint => {\n  const cp = allControlPoints(state).find(({ arrow }) => arrow === arrowId);\n  if (!cp) {\n    throw new Error(`No ControlPoint associated with Arrow having ID \"${arrowId}\"`);\n  }\n  return cp;\n};\n\nexport const controlPointsReducer = (state: State, action: Action): ControlPointState => {\n  if (isInEditMode(state)) {\n    switch (action.type) {\n      case A.ADD_ARROW:\n        return addArrow(state, action.payload.start, action.payload.end, action.payload.id);\n      case A.DELETE_ENTITIES:\n        return deleteEntities(state, action.payload.controlPoints);\n      case A.MOUSE_DOWN_CONTROL_POINT:\n        return mouseDownControlPoint(state, action.payload.id);\n      case A.MOUSE_UP_CONTROL_POINT:\n        return mouseUpControlPoint(state);\n      case A.MOUSE_DOWN_CANVAS:\n        return mouseDownCanvas(state, action.payload.pos);\n      case A.MOUSE_MOVE_CANVAS:\n        return mouseMoveCanvas(state, action.payload.pos);\n      case A.MOUSE_UP_CANVAS:\n      case A.MOUSE_UP_NODE:\n        return mouseUpNodeOrCanvas(state);\n      default:\n        return state.entities.controlPoints;\n    }\n  }\n  else {\n    return state.entities.controlPoints;\n  }\n};\n\n// Whenever we add a new arrow, we also add a new control point for it. The\n// position of the control point is determined by the position of the arrow's\n// start and end nodes, and whether the transition is a self-loop or not.\nconst addArrow = (state: State, start: string, end: string, arrow: string): ControlPointState => {\n  const id = uuid();\n  const startPos = nodeById(state, start).pos;\n  const endPos = start === end ? startPos : nodeById(state, end).pos;\n\n  const constructStandardPos = (start: Vector, end: Vector): Vector => {\n    const diff = end.minus(start);\n    // We offset the control point ever so slightly from the line joining the\n    // endpoints; this forces the transition details into a better position.\n    const perp = diff.perp().normalize().scale(1);\n    return diff.scale(1 / 2).plus(perp).plus(start);\n  };\n\n  const controlPos = start === end\n  ? startPos.minus(new Vector(0, 120))\n  : constructStandardPos(startPos, endPos);\n\n  return {\n    wip: null,\n    committed: _.merge({}, state.entities.controlPoints.committed, {\n      byId: {\n        [id]: { id, arrow, pos: controlPos },\n      }\n    }),\n  };\n};\n\nconst deleteEntities = (state: State, ids: string[]): ControlPointState => ({\n  wip: null,\n  committed: {\n    ...state.entities.controlPoints.committed,\n    byId: _.omit(state.entities.controlPoints.committed.byId, ids),\n  },\n});\n\n// When the user presses the mouse over a control point, we revert to the last\n// committed state and record the control point as the current selection. We do\n// NOT calculate an offset here, since we need the cursor's position relative to\n// the containing (SVG) element in order to do so.\nconst mouseDownControlPoint = (state: State, id: string): ControlPointState => ({\n  ...state.entities.controlPoints,\n  wip: null,\n  committed: {\n    ...state.entities.controlPoints.committed,\n    selected: id,\n  },\n});\n\n// When the mouse is released over a control point, we COMMIT the wip state, and\n// remove any selection and offset that might have been created before a move.\nconst mouseUpControlPoint = (state: State): ControlPointState => ({\n  wip: null,\n  committed: {\n    ...currentLatest(state.entities.controlPoints),\n    selected: null,\n    selectedOffset: null,\n  },\n});\n\n// Here's where things start to get a little tricky: if a mouse press has been\n// received by the canvas, we check if the cursor is currently down over a\n// control point or a node. If it is down over a control point, we compute the\n// current offset in preparation for a move; if it is down over a node, we\n// compute the required offsetS in preparation for the node being moved.\nconst mouseDownCanvas = (state: State, mousePos: Vector): ControlPointState => {\n  if (isMouseDownControlPoint(state)) return prepForDirectMove(state, mousePos);\n  else if (isMouseDownNode(state)) return prepForIndirectMove(state, mousePos);\n  else return state.entities.controlPoints;\n};\n\n// In order to prepare for a control point to be moved, we compute its offset\n// from the cursor position. We also copy the current committed state into the\n// WIP state at this point, since we update the WIP state throughout the move.\nconst prepForDirectMove = (state: State, mousePos: Vector): ControlPointState => {\n  const controlPoints = state.entities.controlPoints.committed;\n  if (!controlPoints.selected) {\n    return state.entities.controlPoints;\n  }\n  const controlPoint = controlPoints.byId[controlPoints.selected];\n  const selectedOffset = controlPoint.pos.minus(mousePos);\n  return {\n    ...state.entities.controlPoints,\n    wip: _.merge({}, controlPoints, {\n      selectedOffset,\n    }),\n  };\n};\n\n// Before a node is moved, we compute some information about any control points\n// that are associated with any arrows connected to the node. This information\n// includes offsets of 2 varieties: \"full\" and \"half\". A full offset is simply a\n// difference between the current mouse position and a control point. We compute\n// a full offset whenever all nodes associated with a control point are\n// selected, since the control point will simply get translated along with the\n// cursor in this case. Computing a half offset is more involved. In this case,\n// we calculate the position of the control point relative to the node that is\n// moving.\nconst prepForIndirectMove = (state: State, mousePos: Vector): ControlPointState => {\n  const controlPoints = state.entities.controlPoints.committed;\n  const selected = selectedNodes(state);\n\n  // A control point is fully affected if both of the nodes associated with its\n  // arrow are selected.\n  const fullyAffected = Object.values(controlPoints.byId).filter(controlPoint => {\n    const arrow = arrowById(state, controlPoint.arrow);\n    return selected.includes(arrow.start) && selected.includes(arrow.end);\n  });\n\n  const fullOffsets = fullyAffected.reduce((acc, cp) => ({\n    ...acc,\n    [cp.id]: new Vector(cp.pos.x - mousePos.x, cp.pos.y - mousePos.y),\n  }), {});\n\n  // A control point is half affected if exactly one of the nodes associated\n  // with its arrow is selected.\n  const halfOffsets = Object.values(controlPoints.byId).reduce((acc, p) => {\n    const arrow = arrowById(state, p.arrow);\n    const includesStart = selected.includes(arrow.start);\n    const includesEnd = selected.includes(arrow.end);\n    if (!xOr(includesStart, includesEnd)) {\n      return acc;\n    }\n\n    const fixedPos = nodeById(state, includesEnd ? arrow.start : arrow.end).pos;\n    const movingPos = nodeById(state, includesStart ? arrow.start : arrow.end).pos;\n    const movingOffset = movingPos.minus(mousePos);\n    const diff = fixedPos.minus(movingPos);\n    const toCP = p.pos.minus(movingPos);\n    const cpShadow = toCP.project(diff);\n    const fractionAlong = cpShadow.magnitude() / diff.magnitude();\n    const perp = toCP.minus(cpShadow);\n    const perpSign = perp.dot(cpShadow.perp()) > 0 ? 1 : -1;\n    const perpLength = perpSign * perp.magnitude();\n\n    return {\n      ...acc,\n      [p.id]: { fixedPos, movingOffset, fractionAlong, perpLength },\n    };\n  }, {});\n\n  // Just as in a direct move, we move the committed state into the WIP state in\n  // preparation for movement.\n  return {\n    ...state.entities.controlPoints,\n    wip: {\n      ...controlPoints,\n      fullOffsets,\n      halfOffsets,\n    },\n  };\n};\n\n// Just as we needed to handle two cases when the mouse is pressed over the\n// canvas, so too must we manage two cases when the mouse is moved. In this\n// case, we distinguish between a \"direct\" move -- when the user is moving the\n// control point by dragging it, and an \"indirect\" move -- when the control\n// point is moved as a result of a node moving.\nconst mouseMoveCanvas = (state: State, mousePos: Vector): ControlPointState => {\n  if (isMouseDownControlPoint(state)) return moveDirect(state, mousePos);\n  else if (isMouseDownNode(state)) return moveIndirect(state, mousePos);\n  else return state.entities.controlPoints;\n};\n\n// To perform a direct move, we simply add the computed offset to the current\n// cursor position, and use this as the new position for the selected control\n// point. This is only slightly complicated by the need to check that the\n// \"selected\" and \"offset\" properties must be non-null.\nconst moveDirect = (state: State, mousePos: Vector): ControlPointState => {\n  const { controlPoints } = state.entities;\n\n  if (!controlPoints.wip || !controlPoints.wip.selected || !controlPoints.wip.selectedOffset) {\n    return controlPoints;\n  }\n\n  const controlPoint = controlPoints.wip.byId[controlPoints.wip.selected];\n  const updatedPos = mousePos.plus(controlPoints.wip.selectedOffset);\n\n  return {\n    ...controlPoints,\n    wip: _.merge({}, controlPoints.wip, {\n      byId: {\n        [controlPoint.id]: { ...controlPoint, pos: updatedPos },\n      },\n    }),\n  };\n};\n\n// To perform an indirect move, we essentially reverse the process of computing\n// the full and half offsets in order to update the positions of the affected\n// control points in the WIP state.\nconst moveIndirect = (state: State, mousePos: Vector): ControlPointState => {\n  const { controlPoints } = state.entities;\n\n  if (!controlPoints.wip) {\n    return controlPoints;\n  }\n\n  const fullMoved = Object.keys(controlPoints.wip.fullOffsets).reduce((acc, id) => {\n    const controlPoint = controlPoints.wip!.byId[id];\n    const updatedPos = mousePos.plus(controlPoints.wip!.fullOffsets[id]);\n    return {\n      ...acc,\n      [id]: { ...controlPoint, pos: updatedPos },\n    };\n  }, {});\n\n  const halfMoved = Object.keys(controlPoints.wip.halfOffsets).reduce((acc, id) => {\n    const controlPoint = controlPoints.wip!.byId[id];\n    const { fixedPos, movingOffset, fractionAlong, perpLength } = controlPoints.wip!.halfOffsets[id];\n    const newPos = mousePos.plus(movingOffset);\n    const diff = fixedPos.minus(newPos);\n    const alongDiff = diff.scale(fractionAlong).plus(newPos);\n    const updatedPos = diff.perp().normalize().scale(perpLength).plus(alongDiff);\n\n    return {\n      ...acc,\n      [id]: { ...controlPoint, pos: updatedPos },\n    };\n  }, {});\n\n  return {\n    ...controlPoints,\n    wip: _.merge({}, controlPoints.wip, {\n      byId: {\n        ...fullMoved,\n        ...halfMoved,\n      },\n    }),\n  };\n};\n\n// When the mouse is released, we commit the wip state and remove all offsets\n// that might have been created before a move.\nconst mouseUpNodeOrCanvas = (state: State): ControlPointState => ({\n  ...state.entities.controlPoints,\n  wip: null,\n  committed: {\n    ...currentLatest(state.entities.controlPoints),\n    selected: null,\n    selectedOffset: null,\n    fullOffsets: {},\n    halfOffsets: {},\n  },\n});\n","import _ from 'lodash';\nimport uuid from 'uuid/v4';\nimport { State } from './state';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport { isInEditMode } from './Mode';\nimport { arrowById } from './Arrow';\n\n// A transition detail provides the information that is missing in an arrow: an\n// arrow indicates the start and end states for a number of transitions; a\n// transition detail supplies the read symbol, write symbol, and tape direction\n// for a particular transition. Thus, a transition consists of an arrow along\n// with a transition detail.\n\nexport interface TransitionDetailState {\n  byId: { [key: string]: TransitionDetail };\n  focused: null | string;\n}\n\nexport interface TransitionDetail {\n  id: string;\n  arrow: string;\n  read: string;\n  write: string;\n  move: 'L' | 'R';\n  isDuplicate: boolean;\n}\n\nexport const initTransitionDetailState: TransitionDetailState = {\n  byId: {},\n  focused: null,\n};\n\n// Return an array containing all transition details.\nexport const allTransitionDetails = (state: State): TransitionDetail[] => (\n  Object.values(state.entities.transitionDetails.byId)\n);\n\n// Return an object associating each Arrow ID with a list of its\n// TransitionDetails.\nexport const allGroupedTransitionDetails = (state: State): { [key: string]: TransitionDetail[] } => (\n  _.groupBy(allTransitionDetails(state), detail => detail.arrow)\n);\n\n// Return an array of transition details associated with the given arrow.\nexport const transitionDetailsForArrow = (state: State, arrow: string): TransitionDetail[] => (\n  allGroupedTransitionDetails(state)[arrow]\n);\n\nexport const transitionDetailsByStart = (state: State): { [key: string]: TransitionDetail[] } => (\n  _.groupBy(allTransitionDetails(state), detail => arrowById(state, detail.arrow).start)\n);\n\n// Return an array of IDs of transition details that share \"read\" symbols with\n// at least one other detail.\nexport const duplicateTransitionDetails = (state: State): string[] => {\n  const byStart = Object.values(transitionDetailsByStart(state));\n  const byReadSym = byStart.map(ds => Object.values(_.groupBy(ds, detail => detail.read)));\n  const duplicates = byReadSym.map(ds => ds.filter(group => group.length > 1)); \n  const flattened = _.flattenDeep(duplicates) as TransitionDetail[];\n  return flattened.map(detail => detail.id);\n};\n\n// Return the currently focused transition detail\nexport const focusedDetail = (state: State): null | string => state.entities.transitionDetails.focused;\n\nexport const transitionDetailsReducer = (state: State, action: Action): TransitionDetailState => {\n  if (isInEditMode(state)) {\n    switch (action.type) {\n      case A.ADD_TRANSITION_DETAIL:\n        return addTransitionDetail(state, action.payload.arrow);\n      case A.ADD_ARROW:\n        return addArrow(state, action.payload.id);\n      case A.CHANGE_TRANSITION_DETAIL:\n        return changeTransitionDetail(state, action.payload.detail);\n      case A.DELETE_TRANSITION_DETAIL:\n        return deleteTransitionDetail(state, action.payload.id);\n      case A.DELETE_ENTITIES:\n        return deleteEntities(state, action.payload.transitionDetails);\n      case A.FOCUS_TRANSITION_DETAIL:\n        return focusTransitionDetail(state, action.payload.id);\n      case A.BLUR_TRANSITION_DETAIL:\n        return blurTransitionDetail(state);\n      case A.MARK_DUPLICATE_TRANSITIONS:\n        return markDuplicateTransitions(state, action.payload.ids);\n      default:\n        return state.entities.transitionDetails;\n    }\n  }\n  else {\n    return state.entities.transitionDetails;\n  }\n};\n\nconst addTransitionDetail = (state: State, arrow: string): TransitionDetailState => {\n  const id = uuid();\n  const detail = { id, arrow, read: '', write: '', move: 'L', isFocused: false };\n  return _.merge({}, state.entities.transitionDetails, {\n    byId: {\n      [id]: detail,\n    },\n    focused: id,\n  });\n};\n\n// Whenever we add a new arrow, we also add a fresh transition detail.\nconst addArrow = (state: State, arrow: string): TransitionDetailState => (\n  addTransitionDetail(state, arrow)\n);\n\nconst changeTransitionDetail = (state: State, detail: TransitionDetail): TransitionDetailState => (\n  _.merge({}, state.entities.transitionDetails, {\n    byId: {\n      [detail.id]: detail,\n    },\n  })\n);\n\nconst deleteTransitionDetail = (state: State, id: string): TransitionDetailState => {\n  const { transitionDetails } = state.entities;\n  return {\n    ...transitionDetails,\n    byId: _.omit(transitionDetails.byId, id),\n  };\n};\n\nconst deleteEntities = (state: State, ids: string[]): TransitionDetailState => ({\n  ...state.entities.transitionDetails,\n  byId: _.omit(state.entities.transitionDetails.byId, ids),\n});\n\nconst focusTransitionDetail = (state: State, id: string): TransitionDetailState => ({\n  ...state.entities.transitionDetails,\n  focused: id,\n});\n\nconst blurTransitionDetail = (state: State): TransitionDetailState => ({\n  ...state.entities.transitionDetails,\n  focused: null,\n});\n\nconst markDuplicateTransitions = (state: State, ids: string[]): TransitionDetailState => ({\n  ...state.entities.transitionDetails,\n  byId: _.mapValues(state.entities.transitionDetails.byId, detail => ({\n    ...detail,\n    isDuplicate: ids.includes(detail.id),\n  })),\n});\n","import _ from 'lodash';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport { State } from './state';\n\nexport interface TapeState {\n  entries: string[];\n  center: number;\n}\n\nexport const initTapeState: TapeState = {\n  entries: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],\n  center: 15,\n};\n\n// Return an array containing all of the tape entries, along with entries\n// containing empty values for nonexistent intermediate entries.\nexport const tapeEntries = (state: State): string[] => state.entities.tape.entries;\n\nexport const tapeCenter = (state: State): number => state.entities.tape.center;\n\nexport const currentReadSymbol = (state: State): string => {\n  const { tape } = state.entities;\n  return tape.entries[tape.center];\n};\n\nexport const tapeReducer = (state: State, action: Action): TapeState => {\n  switch (action.type) {\n    case A.SET_TAPE_CENTER:\n      return setTapeCenter(state, action.payload.pos);\n    case A.CHANGE_TAPE_CELL:\n      return changeTapeCell(state, action.payload.pos, action.payload.value);\n    case A.MOVE_TAPE:\n      return moveTape(state, action.payload.direction);\n    case A.WRITE_TAPE_SYMBOL:\n      return writeTapeSymbol(state, action.payload.symbol);\n    default:\n      return state.entities.tape;\n  }\n};\n\nconst setTapeCenter = (state: State, pos: number): TapeState => ({\n  ...state.entities.tape,\n  center: pos,\n});\n\nconst changeTapeCell = (state: State, pos: number, value: string): TapeState => ({\n  ...state.entities.tape,\n  entries: _.update(_.clone(state.entities.tape.entries), pos, _ => value),\n});\n\nconst moveTape = (state: State, direction: 'L' | 'R'): TapeState => ({\n  ...state.entities.tape,\n  center: state.entities.tape.center + (direction === 'L' ? +1 : -1),\n});\n\nconst writeTapeSymbol = (state: State, symbol: string): TapeState => {\n  const { tape } = state.entities;\n  return {\n    ...tape,\n    entries: _.set(_.clone(tape.entries), tape.center, symbol),\n  };\n};\n","import _ from 'lodash';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport { State } from './state';\nimport { isInEditMode } from './Mode';\nimport { wasMouseDragged, wasMnemonicChanged } from './UI';\n\nexport interface UndoRedoState {\n  actions: ActionRecord[];\n  redoable: ActionRecord[];\n}\n\nexport interface ActionRecord {\n  value: any;\n  description?: string;\n}\n\nexport const initUndoRedoState: UndoRedoState = {\n  actions: [],\n  redoable: [],\n};\n\nexport const undoRedoReducer = (state: State, action: Action): UndoRedoState => {\n  if (isInEditMode(state)) {\n    switch (action.type) {\n      case A.MOUSE_UP_NODE:\n        return mouseUpNode(state);\n      case A.MOUSE_UP_CONTROL_POINT:\n        return mouseUpControlPoint(state);\n      case A.ADD_NODE:\n        return addRecord(state, 'add node');\n      case A.BLUR_MNEMONIC:\n        return blurMnemonic(state);\n      case A.MAKE_SELECTED_START_NODE:\n        return addRecord(state, 'change initial state');\n      case A.TOGGLE_SELECTED_FINAL_NODES:\n        return addRecord(state, 'toggle \"final\" status for selected states');\n      case A.ADD_ARROW:\n        return addRecord(state, 'add new transition');\n      case A.ADD_TRANSITION_DETAIL:\n        return addRecord(state, 'add new transition');\n      case A.DELETE_ENTITIES:\n        return addRecord(state, 'delete entities');\n      case A.CHANGE_TRANSITION_DETAIL:\n        return addRecord(state, 'change transition');\n      case A.CHANGE_TAPE_CELL:\n        return addRecord(state, 'change tape cell');\n      default:\n        return state.undoRedo;\n    }\n  }\n  else {\n    return state.undoRedo;\n  }\n};\n\n// We need to be a little careful before adding an action record when the mouse\n// is released over a node (or control point), since the user may not have\n// actually MOVED the node at all, but instead simply selected it. Thus, we\n// first check if the mouse was dragged before adding the record.\nconst mouseUpNode = (state: State): UndoRedoState => {\n  if (wasMouseDragged(state)) return addRecord(state, 'move node');\n  else return state.undoRedo;\n};\n\nconst mouseUpControlPoint = (state: State): UndoRedoState => {\n  if (wasMouseDragged(state)) return addRecord(state, 'move control point');\n  else return state.undoRedo;\n};\n\nconst blurMnemonic = (state: State): UndoRedoState => {\n  if (wasMnemonicChanged(state)) return addRecord(state, 'change mnemonic');\n  else return state.undoRedo;\n};\n\nexport const undo = (state: State): State => {\n  if (state.undoRedo.actions.length === 0) return state;\n  const [record, ...rest] = state.undoRedo.actions;\n  // Save current value for redo:\n  const redoValue = getSnapshot(state);\n  const redoRecord = { ...record, value: redoValue };\n  const updated = revertToSnapshot(state, record.value);\n  return {\n    ...updated,\n    undoRedo: {\n      ...state.undoRedo,\n      actions: rest,\n      redoable: [redoRecord, ...state.undoRedo.redoable],\n    },\n  };\n};\n\nexport const redo = (state: State): State => {\n  if (state.undoRedo.redoable.length === 0) return state;\n  const [record, ...rest] = state.undoRedo.redoable;\n  // Save current value for undo:\n  const undoValue = getSnapshot(state);\n  const undoRecord = { ...record, value: undoValue };\n  const updated = revertToSnapshot(state, record.value);\n  return {\n    ...updated,\n    undoRedo: {\n      ...state.undoRedo,\n      actions: [undoRecord, ...state.undoRedo.actions],\n      redoable: rest,\n    },\n  };\n};\n\nconst MAX_UNDOS = 32;\n\nconst addRecord = (state: State, description?: string): UndoRedoState => {\n  const record = { description, value: getSnapshot(state) };\n  return {\n    // In order to prevent excessive memory usage, we limit the number of undos.\n    // Each time a record is added, we make sure that the array of actions\n    // contains only the N most recent records, and then add the new one.\n    actions: [record, ...state.undoRedo.actions.slice(0, MAX_UNDOS)],\n    // Each time we add a record to the undo stack, we clear the redo stack.\n    redoable: [],\n  };\n};\n\n// Each time we add a record to the sequence of actions, we store a \"snapshot\"\n// of the application state. In our case, we store all entities.\nconst getSnapshot = (state: State) => _.get(state, 'entities');\n\n// In order to undo or redo an action, we need to revert the state to the\n// snapshot recorded with the action. This is *relatively* straightforward: we\n// replace the current entities list with the snapshot, overwriting any WIP\n// states to null.\nconst revertToSnapshot = (state: State, snapshot: any): State => {\n  const toplevelIteratee = (value: any) => (\n    _.mapValues(value, (value, key) => (\n      key === 'wip' ? null : value\n    ))\n  );\n\n  return {\n    ...state,\n    entities: _.mapValues(snapshot, toplevelIteratee),\n  } as State;\n};\n","import { State } from './state';\nimport { Action } from './actions';\nimport * as A from './actions';\n\nexport interface MessageState {\n  show: boolean;\n  title: null | string;\n  content: null | string | JSX.Element;\n}\n\nexport const initMessageState: MessageState = {\n  show: false,\n  title: null,\n  content: null,\n};\n\nexport const showMessage = (state: State): boolean => state.message.show;\n\nexport const messageTitle = (state: State): null | string => state.message.title;\n\nexport const messageContent = (state: State): null | string | JSX.Element => state.message.content;\n\nexport const messageReducer = (state: State, action: Action): MessageState => {\n  switch (action.type) {\n    case A.DISPLAY_MESSAGE:\n      return displayMessage(state, action.payload.title, action.payload.content);\n    case A.DISMISS_MESSAGE:\n      return dismissMessage(state);\n    default:\n      return state.message;\n  }\n};\n\nconst displayMessage = (state: State, title: string, content?: string | JSX.Element): MessageState => ({\n  ...state.message,\n  show: true,\n  title,\n  content: content !== undefined ? content : null,\n});\n\nconst dismissMessage = (state: State): MessageState => ({\n  ...state.message,\n  show: false,\n  title: null,\n  content: null,\n});\n","import { State } from './state';\nimport { Action } from './actions';\nimport * as A from './actions';\nimport { startNode } from './Node';\n\nexport interface SimState {\n  currentState: null | string;\n  activeNode: null | string;\n  activeArrow: null | string;\n  activeTransitionDetail: null | string;\n  activeControlPoint: null | string;\n}\n\nexport const initSimState: SimState = {\n  currentState: null,\n  activeNode: null,\n  activeArrow: null,\n  activeTransitionDetail: null,\n  activeControlPoint: null,\n};\n\n// Return the current simulation state.\nexport const currentState = (state: State): string => (\n state.sim.currentState || startNode(state)\n);\n\nexport const isNodeActive = (state: State, id: string): boolean => (\n  state.sim.activeNode === id\n);\n\nexport const isArrowActive = (state: State, id: string): boolean => (\n  state.sim.activeArrow === id\n);\n\nexport const isControlPointActive = (state: State, id: string): boolean => (\n  state.sim.activeControlPoint === id\n);\n\nexport const activeTransitionDetail = (state: State): null | string => (\n  state.sim.activeTransitionDetail\n);\n\nexport const simReducer = (state: State, action: Action): SimState => {\n  switch (action.type) {\n    case A.SET_CURRENT_STATE:\n      return setCurrentState(state, action.payload.id);\n    case A.SET_ACTIVE_NODE:\n      return setActiveNode(state, action.payload.id);\n    case A.SET_ACTIVE_TRANSITION_DETAIL:\n      return setActiveTransitionDetail(state, action.payload.id);\n    case A.SET_ACTIVE_ARROW:\n      return setActiveArrow(state, action.payload.id);\n    case A.SET_ACTIVE_CONTROL_POINT:\n      return setActiveControlPoint(state, action.payload.id);\n    case A.RESET_SIM:\n      return resetSim(state);\n    default:\n      return state.sim;\n  }\n};\n\nconst setCurrentState = (state: State, id: string): SimState => ({\n  ...state.sim,\n  currentState: id,\n});\n\nconst setActiveNode = (state: State, id: null | string): SimState => ({\n  ...state.sim,\n  activeNode: id,\n});\n\nconst setActiveTransitionDetail = (state: State, id: null | string): SimState => ({\n  ...state.sim,\n  activeTransitionDetail: id,\n});\n\nconst setActiveArrow = (state: State, id: null | string): SimState => ({\n  ...state.sim,\n  activeArrow: id,\n});\n\nconst setActiveControlPoint = (state: State, id: null | string): SimState => ({\n  ...state.sim,\n  activeControlPoint: id,\n});\n\nconst resetSim = (state: State): SimState => ({\n  ...state.sim,\n  currentState: null,\n  activeNode: null,\n  activeArrow: null,\n  activeTransitionDetail: null,\n  activeControlPoint: null,\n});\n","import { NodeState, initNodeState } from './Node';\nimport { ArrowState, initArrowState } from './Arrow';\nimport { ControlPointState, initControlPointState } from './ControlPoint';\nimport { TransitionDetailState, initTransitionDetailState } from './TransitionDetail';\nimport { TapeState, initTapeState } from './Tape';\nimport { UIState, initUIState } from './UI';\nimport { UndoRedoState, initUndoRedoState } from './UndoRedo';\nimport { MessageState, initMessageState } from './Message';\nimport { ModeState, initModeState } from './Mode';\nimport { SimState, initSimState } from './Sim';\n\n// The application state consists of a number of \"entities\" (objects -- in the\n// general sense -- that are displayed and interacted with), along with some UI\n// info. The UI info is generally useful for a number of the entities.\n\nexport interface State {\n  entities: {\n    nodes: NodeState;\n    arrows: ArrowState;\n    controlPoints: ControlPointState;\n    transitionDetails: TransitionDetailState;\n    tape: TapeState;\n  }\n  ui: UIState;\n  undoRedo: UndoRedoState;\n  message: MessageState;\n  mode: ModeState;\n  sim: SimState;\n}\n\nexport const initState: State = {\n  entities: {\n    nodes: initNodeState,\n    arrows: initArrowState,\n    controlPoints: initControlPointState,\n    transitionDetails: initTransitionDetailState,\n    tape: initTapeState,\n  },\n  ui: initUIState,\n  undoRedo: initUndoRedoState,\n  message: initMessageState,\n  mode: initModeState,\n  sim: initSimState,\n};\n","import { Action } from './actions'\nimport * as A from './actions';\nimport { State, initState } from './state';\nimport { nodesReducer } from './Node';\nimport { arrowsReducer } from './Arrow';\nimport { controlPointsReducer } from './ControlPoint';\nimport { transitionDetailsReducer } from './TransitionDetail';\nimport { tapeReducer } from './Tape';\nimport { uiReducer } from './UI';\nimport { undoRedoReducer, undo, redo } from './UndoRedo';\nimport { messageReducer } from './Message';\nimport { modeReducer } from './Mode';\nimport { simReducer } from './Sim';\n\nconst reducer = (state: State=initState, action: Action): State => {\n  switch (action.type) {\n    case A.UNDO:\n      return undo(state);\n    case A.REDO:\n      return redo(state);\n    default:\n      return {\n        ...state,\n        entities: {\n          ...state.entities,\n          nodes: nodesReducer(state, action),\n          arrows: arrowsReducer(state, action),\n          controlPoints: controlPointsReducer(state, action),\n          transitionDetails: transitionDetailsReducer(state, action),\n          tape: tapeReducer(state, action),\n        },\n        ui: uiReducer(state, action),\n        undoRedo: undoRedoReducer(state, action),\n        message: messageReducer(state, action),\n        mode: modeReducer(state, action),\n        sim: simReducer(state, action),\n      };\n  }\n};\n\nexport default reducer;\n","import { Middleware } from 'redux';\nimport { Action } from '../actions';\nimport * as A from '../actions';\nimport { State } from '../state';\nimport { selectedNodes } from '../Node';\n\n// Each key may be \"bound\" to an alternative redux action, such that when the\n// user presses it, the action is dispatched.\nconst keyBindings: { [key: string]: KeyHandler } = {\n  'Backspace': st => {\n    if (selectedNodes(st).length > 0) {\n      return A.deleteSelectedNodes();\n    }\n    return null;\n  },\n  'n': (_, e) => {\n    if (e.ctrlKey) {\n      e.preventDefault();\n      return A.startAddingNode();\n    }\n    return null;\n  },\n  't': (st, e) => {\n    const multipleSelected = selectedNodes(st).length > 0;\n    if (multipleSelected && e.ctrlKey) {\n      e.preventDefault();\n      return A.addTransitionBetweenSelected();\n    }\n    else return null;\n  },\n  'z': (_, e) => {\n    if (e.ctrlKey || e.metaKey) return A.undo();\n    return null;\n  },\n  'y': (_, e) => {\n    if (e.ctrlKey || e.metaKey) {\n      e.preventDefault();\n      return A.redo();\n    }\n    return null;\n  },\n};\n\ntype KeyHandler = (state: State, event: React.KeyboardEvent) => null | Action;\n\nexport const keyboardShortcuts: Middleware = api => next => action => {\n  if (action.type !== A.KEY_DOWN) return next(action);\n\n  const state = api.getState();\n  const { key, event } = action.payload;\n\n  const keyHandler = keyBindings[key];\n  if (!keyHandler) return next(action);\n\n  const altAction = keyHandler(state, event);\n  if (!altAction) return next(action);\n\n  next(action);\n  return next(altAction);\n};\n","import React from 'react';\nimport './ErrorReport.css';\n\nexport interface ErrorReportProps {\n  whatsWrong: string;\n  howToFix: string | JSX.Element;\n}\n\nclass ErrorReport extends React.Component<ErrorReportProps> {\n  render() {\n    return (\n      <div className=\"error-report\">\n        <div className=\"error-report__section\">\n          <span className=\"error-report__title\">What's wrong:&ensp;</span>\n          <span className=\"error-report__content\">{this.props.whatsWrong}</span>\n        </div>\n        <div className=\"error-report__section\">\n          <span className=\"error-report__title\">How to fix it:&ensp;</span>\n          <span className=\"error-report__content\">{this.props.howToFix}</span>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default ErrorReport;\n","import React from 'react';\nimport ErrorReport from './ErrorReport';\n\nconst problem = 'In order for the machine to start, a state must be '\n              + 'distinguished as the initial or start state. You have '\n              + 'not yet identified any state as such.';\n\nconst fix = 'Select one of your machine states and click the \"Make Start State\" ' +\n            'button to distinguish it as the initial state.';\n\nexport default (\n  <ErrorReport whatsWrong={problem} howToFix={fix} />\n);\n","import React from 'react';\nimport ErrorReport from './ErrorReport';\n\nconst problem = 'At the moment, you have 2 or more transitions from the same '\n              + 'state with the same read symbol. Such nondeterministic behavior '\n              + 'is not supported.';\n\nconst fix = 'Find all transitions whose read symbols are marked red, and modify '\n          + 'or remove the associated transitions so that all transitions for each '\n          + 'state have distinct read symbols';\n\nexport default (\n  <ErrorReport whatsWrong={problem} howToFix={fix} />\n);\n","import React from 'react';\nimport './HaltReport.css';\n\nexport interface HaltReportProps {\n  accepted: boolean;\n}\n\nclass HaltReport extends React.Component<HaltReportProps> {\n  render() {\n    const { accepted: wasSuccess } = this.props;\n    return (\n      <div className=\"halt-report\">\n        <div className=\"halt-report__title\">\n          The machine has&nbsp;\n          <span className={`halt-report__result halt-report__result--${wasSuccess ? 'accepted' : 'rejected'}`}>\n            {wasSuccess ? 'accepted' : 'rejected'}\n          </span>\n          &nbsp;the input string.\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default HaltReport;\n","import React from 'react';\nimport HaltReport from './HaltReport';\n\nexport default <HaltReport accepted={true} />;\n","import React from 'react';\nimport HaltReport from './HaltReport';\n\nexport default <HaltReport accepted={false} />;\n","import _ from 'lodash';\nimport { takeEvery, take, select, fork, put, cancel, delay } from 'redux-saga/effects';\nimport * as A from './actions';\nimport { State } from './state';\nimport { Modes } from './Mode';\nimport { currentState } from './Sim';\nimport { currentReadSymbol } from './Tape';\nimport { isNodeFinal } from './Node';\nimport { arrowsForStart } from './Arrow';\nimport { transitionDetailsForArrow } from './TransitionDetail';\nimport { controlPointForArrow } from './ControlPoint';\n\nfunction* play(singleStep: boolean) {\n  const playTask = yield fork(playSim, singleStep);\n  yield take([A.PAUSE_SIM, A.RESET_SIM, A.HALT_ACCEPT, A.HALT_REJECT]);\n  yield cancel(playTask);\n}\n\nfunction* playSim(singleStep: boolean) {\n  try {\n    yield put(A.switchMode(Modes.SIM));\n    if (singleStep) {\n      yield makeStep();\n    } else {\n      while (true) {\n        yield makeStep();\n      }\n    }\n  } finally {\n    yield put(A.switchMode(Modes.EDIT));\n  }\n}\n\nfunction* makeStep() {\n  // We first collect the current state and read symbol. These determine which\n  // transition we can take (if one is available).\n  const current = yield select(currentState);\n  const readSymbol = yield select(currentReadSymbol);\n  const transitionInfo = yield select(state => availableTransitionInfo(state, current, readSymbol));\n\n  const interval = 1000;\n\n  yield put(A.setActiveNode(current));\n  yield delay(interval / 4);\n\n  // If there are no available transitions, the machine halts. Whether it\n  // accepts or rejects the input is determined by whether the currents state\n  // has been designated as \"final\" or not.\n  if (transitionInfo === null) {\n    const accept = yield select(state => isNodeFinal(state, current));\n    if (accept) yield put(A.haltAccept());\n    else yield put(A.haltReject());\n  }\n\n  const { endId, arrowId, controlPointId, transitionDetailId, writeSymbol, tapeDirection } = transitionInfo as TransitionInfo;\n\n  yield put(A.setActiveArrow(arrowId));\n  yield put(A.setActiveControlPoint(controlPointId));\n  yield put(A.setActiveTransitionDetail(transitionDetailId));\n  yield put(A.writeTapeSymbol(writeSymbol));\n  yield put(A.moveTape(tapeDirection));\n  yield delay(interval / 4);\n\n  yield put(A.setActiveNode(endId));\n  yield put(A.setCurrentState(endId));\n  yield delay(interval / 4);\n\n  yield put(A.setActiveArrow(null));\n  yield put(A.setActiveControlPoint(null));\n  yield put(A.setActiveTransitionDetail(null));\n  yield delay(interval / 4);\n}\n\ninterface TransitionInfo {\n  endId: string;\n  arrowId: string;\n  controlPointId: string;\n  transitionDetailId: string;\n  writeSymbol: string;\n  tapeDirection: 'L' | 'R';\n}\n\nconst availableTransitionInfo = (state: State, current: string, readSymbol: string): null | TransitionInfo => {\n  const outgoing = arrowsForStart(state, current);\n  const details = _.flatten(outgoing.map(arrow => transitionDetailsForArrow(state, arrow.id)));\n  const detail = details.find(detail => detail.read === readSymbol);\n\n  if (!detail) return null;\n  const arrow = outgoing.find(arrow => arrow.id === detail.arrow);\n  if (!arrow) {\n    throw new Error(`Inconsistency in state: transition detail references nonexistent arrow \"${detail.arrow}\"`);\n  }\n  const controlPoint = controlPointForArrow(state, arrow.id);\n  return {\n    endId: arrow.end,\n    arrowId: arrow.id,\n    controlPointId: controlPoint.id,\n    transitionDetailId: detail.id,\n    writeSymbol: detail.write,\n    tapeDirection: detail.move,\n  };\n};\n\nexport default function* saga() {\n  yield takeEvery(A.STEP_SIM, play, true);\n  yield takeEvery(A.PLAY_SIM, play, false);\n}\n","import { createStore, applyMiddleware } from 'redux';\nimport createSagaMiddleware from 'redux-saga';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport reducer from './reducer';\nimport * as M from './middleware';\nimport saga from './saga';\n\nconst sagaMiddleware = createSagaMiddleware();\n\nconst store = createStore(\n  reducer,\n  composeWithDevTools(applyMiddleware(\n    M.keyboardShortcuts,\n    M.addTransition,\n    M.deleteTransitionDetail,\n    M.deleteNode,\n    M.validateTransitionDetails,\n    M.validatePreSim,\n    sagaMiddleware,\n    M.halt,\n  )),\n);\n\nsagaMiddleware.run(saga);\n\nexport default store;\n","import uuid from 'uuid/v4';\nimport { Middleware } from 'redux';\nimport * as A from '../actions';\nimport { selectedNodes } from '../Node';\nimport { arrowForEndpoints } from '../Arrow';\n\n// When we add a new transition, we need to check if there is already an arrow\n// between its two endpoints. If so, we simply add an additional detail to this\n// arrow; if not we need to construct a new arrow and control point, and then\n// add the detail to that.\nexport const addTransition: Middleware = api => next => action => {\n  if (action.type !== A.ADD_TRANSITION_BETWEEN_SELECTED) return next(action);\n\n  const state = api.getState();\n  const nodes = selectedNodes(state);\n  const start = nodes[0];\n  const end = nodes[1] || nodes[0];\n  const existingArrow = arrowForEndpoints(state, start, end);\n\n  if (existingArrow) {\n    return next(A.addTransitionDetail(existingArrow.id));\n  } else {\n    const arrowId = uuid();\n    return next(A.addArrow(start, end, arrowId));\n  }\n};\n","import { Middleware } from 'redux';\nimport * as A from '../actions';\nimport { transitionDetailsForArrow } from '../TransitionDetail';\nimport { controlPointForArrow } from '../ControlPoint';\n\n// When a transition detail is deleted, we need to check if it was the last one\n// for its associated arrow. If it is, we need to also delete the arrow its\n// control point.\nexport const deleteTransitionDetail: Middleware = api => next => action => {\n  if (action.type !== A.DELETE_TRANSITION_DETAIL) return next(action);\n\n  const { id, arrow } = action.payload;\n  const state = api.getState();\n  const remainingDetails = transitionDetailsForArrow(state, arrow).filter(detail => detail.id !== id);\n\n  if (remainingDetails.length > 0) return next(action);\n\n  const controlPointId = controlPointForArrow(state, arrow).id;\n  return next(A.deleteEntities([], [arrow], [controlPointId], [id]));\n};\n","import _ from 'lodash';\nimport { Middleware } from 'redux';\nimport * as A from '../actions';\nimport { transitionDetailsForArrow } from '../TransitionDetail';\nimport { controlPointForArrow } from '../ControlPoint';\nimport { selectedNodes } from '../Node';\nimport { arrowsForNode } from '../Arrow';\n\n// When we delete a node, we need to remove anything that was \"attached\" to it:\n// any arrows, and control points and transition details associated with them.\nexport const deleteNode: Middleware = api => next => action => {\n  if (action.type !== A.DELETE_SELECTED_NODES) return next(action);\n\n  const state = api.getState();\n  const nodeIds = selectedNodes(state);\n  const arrows = _.flatten(nodeIds.map(id => arrowsForNode(state, id)));\n  const arrowIds = _.uniq(_.flatten(arrows.map(({ id }) => id)));\n  const controlPointIds = arrowIds.map(id => controlPointForArrow(state, id)).map(({ id }) => id);\n  const transitionDetails = _.flatten(arrowIds.map(id => transitionDetailsForArrow(state, id)));\n  const transitionDetailIds = transitionDetails.map(({ id }) => id);\n\n  return next(A.deleteEntities(nodeIds, arrowIds, controlPointIds, transitionDetailIds));\n};\n","import { Middleware } from 'redux';\nimport * as A from '../actions';\nimport { duplicateTransitionDetails } from '../TransitionDetail';\n\n// Each time the user modifies or adds a transition detail, we find all\n// transition details that share an arrow and have the same read symbol. These\n// represent nondeterministic transitions and should be marked as errors.\nexport const validateTransitionDetails: Middleware = api => next => action => {\n  const validateOn = [\n    A.ADD_TRANSITION_DETAIL,\n    A.CHANGE_TRANSITION_DETAIL,\n    A.DELETE_TRANSITION_DETAIL,\n    A.ADD_ARROW,\n  ];\n  if (!validateOn.includes(action.type)) return next(action);\n\n  next(action);\n  const duplicates = duplicateTransitionDetails(api.getState());\n  return next(A.markDuplicateTransitions(duplicates));\n};\n","import { Middleware } from 'redux';\nimport * as A from '../actions';\nimport { hasStartNode } from '../Node';\nimport { duplicateTransitionDetails } from '../TransitionDetail';\nimport MissingStartState from '../../ErrorReport/MissingStartState';\nimport NondeterministicTransition from '../../ErrorReport/NondeterministicTransition';\n\nexport const validatePreSim: Middleware = api => next => action => {\n  if (![A.STEP_SIM, A.PLAY_SIM].includes(action.type)) return next(action);\n\n  const state = api.getState();\n  if (!hasStartNode(state)) {\n    return next(A.displayMessage('Missing start state', MissingStartState));\n  }\n  else if (duplicateTransitionDetails(state).length > 0) {\n    return next(A.displayMessage('Nondeterministic transitions', NondeterministicTransition));\n  }\n\n  return next(action);\n};\n","import { Middleware } from 'redux';\nimport * as A from '../actions';\nimport Accept from '../../HaltReport/Accept';\nimport Reject from '../../HaltReport/Reject';\n\nexport const halt: Middleware = api => next => action => {\n  if (![A.HALT_ACCEPT, A.HALT_REJECT].includes(action.type)) return next(action);\n\n  if (action.type === A.HALT_ACCEPT) {\n    return next(A.displayMessage('Machine Halted', Accept));\n  }\n  else if (action.type === A.HALT_REJECT) {\n    return next(A.displayMessage('Machine Halted', Reject));\n  }\n};\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport classNames from 'classnames';\nimport { State } from '../state-mgmt/state';\nimport { Arrow as ArrowDetails } from '../state-mgmt/Arrow';\nimport { controlPointForArrow } from '../state-mgmt/ControlPoint';\nimport { nodeById } from '../state-mgmt/Node';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport { isArrowActive } from '../state-mgmt/Sim';\nimport Vector from '../tools/Vector';\nimport './Arrow.css';\n\n// An arrow represents one or more transitions between machine states (which are\n// represented by nodes). We render an arrow as a curved line between nodes,\n// using the arrow's control points to construct this curve. There are two cases\n// we need to consider: (1) if the arrow represents a self-transition, we render\n// it using a cubic bezier curve, (2) if the arrow represents a standard\n// transition, we use a quadratic curve.\n\nexport interface ArrowProps {\n  details: ArrowDetails;\n  start: Vector;\n  end: Vector;\n  control: Vector;\n  isSelfLoop: boolean;\n  isEditable: boolean;\n  isActive: boolean;\n}\n\nclass Arrow extends React.Component<ArrowProps> {\n  render() {\n    const className = classNames('arrow', {\n      'arrow--editable': this.props.isEditable,\n      'arrow--active': this.props.isActive,\n    });\n\n    const pathString = this.props.isSelfLoop\n      ? this.computeCubicPathString()\n      : this.computeQuadraticPathString();\n    return <path className={className} d={pathString} />;\n  }\n\n  private computeQuadraticPathString() {\n    // We need to distinguish between two types of \"control point\": the USER\n    // control point, which is represented by an arrowhead that the user can\n    // drag around, and the BEZIER control point, which is determined by the\n    // position of the user control point and in turn determines the shape of\n    // the arrow's curve. The main task here is to derive the BEZIER control\n    // point from the USER control point. To do so, we first find the midpoint\n    // between the nodes. We then construct the vector pointing from this\n    // midpoint to the USER control point, and scale it by 2. The bezier control\n    // point is described by the sum of this vector and the midpoint vector. I\n    // discovered this via experimentation, but it works like a charm.\n    const { start, end, control} = this.props;\n    const mid = start.plus(end.minus(start).scale(1 / 2));\n    const bezierControl= mid.plus(control.minus(mid).scale(2));\n    return `M ${start.x} ${start.y} Q ${bezierControl.x} ${bezierControl.y} ${end.x} ${end.y}`;\n  }\n\n  private computeCubicPathString() {\n    // To construct the bezier control pointS in this case, we first construct\n    // the vector pointing from the node to the USER control point and scale it\n    // by 4 / 3 (as above, I discovered this experimentally, and it appears to\n    // work perfectly although I don't know why). We then move a specified\n    // distance (`separation`) perpendicular to this vector in either direction.\n    // This separation distance determines how wide the loop is.\n    const { start, control } = this.props;\n    const v1 = control.minus(start).scale(4 / 3);\n    const separation = 80;\n    const v2 = v1.perp().normalize().scale(separation);\n    const ctrl1 = start.plus(v1).plus(v2);\n    const ctrl2 = start.plus(v1).minus(v2);\n    return `M ${start.x} ${start.y} C ${ctrl1.x} ${ctrl1.y} ${ctrl2.x} ${ctrl2.y} ${start.x} ${start.y}`;\n  }\n}\n\nconst mapStateToProps = (state: State, ownProps: any) => {\n  const start = nodeById(state, ownProps.details.start);\n  const end = nodeById(state, ownProps.details.end);\n  const controlPoint = controlPointForArrow(state, ownProps.details.id);\n  return {\n    start: start.pos,\n    end: end.pos,\n    control: controlPoint.pos,\n    isSelfLoop: start.id === end.id,\n    isEditable: isInEditMode(state),\n    isActive: isArrowActive(state, ownProps.details.id),\n  };\n};\n\nexport default connect(\n  mapStateToProps,\n)(Arrow);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport classNames from 'classnames';\nimport { State } from '../state-mgmt/state';\nimport * as A from '../state-mgmt/actions';\nimport { Node as NodeDetails, isNodeSelected, isStartNode } from '../state-mgmt/Node';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport { isNodeActive } from '../state-mgmt/Sim';\nimport Vector from '../tools/Vector';\nimport './Node.css';\n\n// A node represents a machine state in the TM formalization. We render nodes as\n// circles (with additional embellishments if they are also start or accepting\n// nodes). Additionally, a node may be given a \"mnemonic\" -- a 0-4 character\n// string -- to clarify its purpose.\n\nexport interface NodeProps {\n  details: NodeDetails;\n  isSelected: boolean;\n  isStart: boolean;\n  isEditable: boolean;\n  isActive: boolean;\n  changeMnemonic: (value: string) => void;\n  blurMnemonic: () => void;\n  mouseDown: () => void;\n  mouseUp: () => void;\n}\n\nexport const NODE_RADIUS = 21;\n\nclass Node extends React.Component<NodeProps> {\n  render() {\n    const { pos, mnemonic } = this.props.details;\n    const className = classNames('node', {\n      'node--selected': this.props.isSelected,\n      'node--final': this.props.details.isFinal,\n      'node--start': this.props.isStart,\n      'node--editable': this.props.isEditable,\n      'node--active': !this.props.isEditable && this.props.isActive,\n    });\n\n    const mnemonicClassName = classNames('node__mnemonic-input', {\n      'node__mnemonic-input--editable': this.props.isEditable,\n    });\n\n    const mnemonicPos = pos.plus(new Vector(-NODE_RADIUS + 2, NODE_RADIUS + 3));\n\n    return (\n      <div className=\"node__container\">\n        <div className={className}\n             onMouseDown={this.handleMouseDown}\n             onMouseUp={this.handleMouseUp}\n             style={{\n               position: 'absolute',\n               left: pos.x - NODE_RADIUS,\n               top: pos.y - NODE_RADIUS,\n             }} />\n        <input className={mnemonicClassName}\n               disabled={!this.props.isEditable}\n               value={mnemonic}\n               onChange={this.handleInputChange}\n               onBlur={this.handleInputBlur}\n               type=\"text\"\n               maxLength={4}\n               style={{\n                 position: 'absolute',\n                 left: mnemonicPos.x,\n                 top: mnemonicPos.y,\n               }}/>\n      </div>\n    );\n  }\n\n  private handleMouseDown = (e: React.MouseEvent) => {\n    this.props.mouseDown();\n  };\n\n  private handleMouseUp = (e: React.MouseEvent) => {\n    this.props.mouseUp();\n  };\n\n  private handleInputChange = (evt: React.ChangeEvent<HTMLInputElement>) => {\n    this.props.changeMnemonic(evt.target.value);\n  };\n\n  private handleInputBlur = () => {\n    this.props.blurMnemonic();\n  };\n}\n\nconst mapStateToProps = (state: State, ownProps: any) => ({\n  isSelected: isNodeSelected(state, ownProps.details.id),\n  isStart: isStartNode(state, ownProps.details.id),\n  isEditable: isInEditMode(state),\n  isActive: isNodeActive(state, ownProps.details.id),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch, ownProps: any) => ({\n  changeMnemonic: (value: string) => dispatch(A.changeMnemonic(ownProps.details.id, value)),\n  blurMnemonic: () => dispatch(A.blurMnemonic()),\n  mouseDown: () => dispatch(A.mouseDownNode(ownProps.details.id)),\n  mouseUp: () => dispatch(A.mouseUpNode()),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(Node);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport classNames from 'classnames';\nimport * as A from '../state-mgmt/actions';\nimport { State } from '../state-mgmt/state';\nimport { arrowById } from '../state-mgmt/Arrow';\nimport { nodeById } from '../state-mgmt/Node';\nimport { ControlPoint as ControlPointDetails } from '../state-mgmt/ControlPoint';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport { isControlPointActive } from '../state-mgmt/Sim';\nimport Vector from '../tools/Vector';\nimport './ControlPoint.css';\n\n// A control point is a draggable handle that the user can position to alter the\n// curve of an arrow. Control points are essential in being able to layout a\n// machine in an aesthetically pleasing way. As for arrows, there are 2 cases to\n// consider here: (1) the control point is for a self-transition, and (2) it is\n// for a standard transition. In both cases, we render the control point as an\n// arrowhead pointing in the direction of the transition that its arrow\n// represents.\n\nexport interface ControlPointProps {\n  details: ControlPointDetails;\n  start: Vector;\n  end: Vector;\n  isSelfLoop: boolean;\n  isEditable: boolean;\n  isActive: boolean;\n  mouseDown: () => void;\n  mouseUp: () => void;\n}\n\nconst ARROW_LENGTH = 18;\n\nclass ControlPoint extends React.Component<ControlPointProps> {\n  render() {\n    const className = classNames('control-point', {\n      'control-point--editable': this.props.isEditable,\n      'control-point--active': this.props.isActive,\n    });\n\n    const pathString = this.props.isSelfLoop\n    ? this.computeCubicString()\n    : this.computeQuadraticPathString();\n    return <path className={className}\n                 d={pathString}\n                 onMouseDown={this.handleMouseDown}\n                 onMouseUp={this.handleMouseUp} />;\n  }\n\n  // In the quadratic (i.e. standard transition) case, we render the control\n  // point as an arrowhead that is parallel to the line segment connecting the\n  // two nodes that its arrow joins.\n  private computeQuadraticPathString() {\n    const { start, end } = this.props;\n    const { pos } = this.props.details;\n    const v1 = end.minus(start).normalize().scale(ARROW_LENGTH);\n    const v2 = v1.perp().scale(1 / 3);\n    const p1 = pos.minus(v1).plus(v2);\n    const p2 = pos.minus(v1).minus(v2);\n    return `M ${p1.x} ${p1.y} L ${pos.x} ${pos.y} L ${p2.x} ${p2.y}`;\n  }\n\n  // For a self-transition, we render the control point as an arrowhead that is\n  // perpendicular to the line connecting it to the node that its arrow\n  // connects.\n  private computeCubicString() {\n    const { start } = this.props;\n    const { pos } = this.props.details;\n    const v1 = pos.minus(start).normalize();\n    const v2 = v1.perp().scale(ARROW_LENGTH);\n    const tip = pos.plus(v2.scale(1 / 2));\n    const p1 = tip.minus(v2).plus(v1.scale(ARROW_LENGTH / 3));\n    const p2 = tip.minus(v2).minus(v1.scale(ARROW_LENGTH / 3));\n    return `M ${p1.x} ${p1.y} L ${tip.x} ${tip.y} L ${p2.x} ${p2.y}`;\n  }\n\n  private handleMouseDown = (e: React.MouseEvent) => {\n    this.props.mouseDown();\n  };\n\n  private handleMouseUp = (e: React.MouseEvent) => {\n    this.props.mouseUp();\n  };\n}\n\nconst mapStateToProps = (state: State, ownProps: any) => {\n  const arrow = arrowById(state, ownProps.details.arrow);\n  const start = nodeById(state, arrow.start);\n  const end = nodeById(state, arrow.end);\n  return {\n    start: start.pos,\n    end: end.pos,\n    isSelfLoop: start.id === end.id,\n    isEditable: isInEditMode(state),\n    isActive: isControlPointActive(state, ownProps.details.id),\n  };\n};\n\nconst mapDispatchToProps = (dispatch: Dispatch, ownProps: any) => ({\n  mouseDown: () => dispatch(A.mouseDownControlPoint(ownProps.details.id)),\n  mouseUp: () => dispatch(A.mouseUpControlPoint()),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(ControlPoint);\n","import React from 'react';\nimport classNames from 'classnames';\nimport { TransitionDetail as TransitionDetailInfo } from '../state-mgmt/TransitionDetail';\nimport './TransitionDetail.css';\n\n// Each transition consists of a pair of (not necessarily distinct) states, and\n// 3 pieces of information detailing (1) what tape symbol must be read in order\n// to take the transition, (2) what tape symbol will be written if the\n// transition is taken, and (3) in which direction the tape head should move. A\n// transition detail represents these three pieces of information; together with\n// an arrow it represents a full transition.\n\nexport interface TransitionDetailProps {\n  detail: TransitionDetailInfo;\n  isFocused: boolean;\n  isEditable: boolean;\n  isActive: boolean;\n  onFocus?: () => void;\n  onBlur?: () => void;\n  onChange?: (value: TransitionDetailInfo) => void;\n  onDelete?: () => void;\n}\n\nclass TransitionDetail extends React.Component<TransitionDetailProps> {\n  private readRef: React.RefObject<HTMLInputElement> = React.createRef();\n\n  render() {\n    const { read, write, move } = this.props.detail;\n\n    const className = classNames('transition-detail', {\n      'transition-detail--active': this.props.isActive,\n    });\n\n    const inputClassName = classNames('transition-detail__input', {\n      'transition-detail__input--focus': this.props.isFocused,\n      'transition-detail__input--editable': this.props.isEditable,\n    });\n\n    // We create a special className for the read input in order to distinguish\n    // inputs in an \"error\" state.\n    const readInputClassName = classNames(inputClassName, {\n      'transition-detail__input--error': this.props.detail.isDuplicate,\n    })\n\n    const selectorClassName = classNames('transition-detail__selector', {\n      'transition-detail__selector--focus': this.props.isFocused,\n      'transition-detail__selector--editable': this.props.isEditable,\n    });\n\n    return (\n      <div className={className}>\n        <input className={readInputClassName}\n               ref={this.readRef}\n               disabled={!this.props.isEditable}\n               value={read}\n               onChange={this.handleInputChange('read')}\n               onFocus={this.handleFocus}\n               onBlur={this.handleBlur}\n               type=\"text\"\n               maxLength={1} />\n        <span className=\"transition-detail__separator\">&#47;</span>\n        <input className={inputClassName}\n               disabled={!this.props.isEditable}\n               value={write}\n               onChange={this.handleInputChange('write')}\n               onFocus={this.handleFocus}\n               onBlur={this.handleBlur}\n               type=\"text\"\n               maxLength={1} />\n        <span className=\"transition-detail__separator\">,</span>\n        <select className={selectorClassName}\n                disabled={!this.props.isEditable}\n                value={move}\n                onChange={this.handleSelectChange}>\n          <option value=\"L\"></option>\n          <option value=\"R\"></option>\n        </select>\n        {this.props.isEditable &&\n          <button className=\"transition-detail__button\"\n                  onClick={this.handleDeleteClick}>\n          </button>\n        }\n      </div>\n    );\n  }\n\n  // In the meantime, whenever a transition detail is created, it is immediately\n  // focused. This (slight) hack ensures that the browser focus remains\n  // synchronized.\n  componentDidMount() {\n    if (this.props.isFocused) this.focus();\n  }\n\n  private focus() {\n    if (this.readRef.current) this.readRef.current.focus();\n  }\n\n  private handleInputChange(property: 'read' | 'write') {\n    return (evt: React.ChangeEvent<HTMLInputElement>) => {\n      if (!this.props.onChange) return;\n      this.props.onChange({\n        ...this.props.detail,\n        [property]: evt.target.value,\n      });\n    };\n  }\n\n  private handleSelectChange = (evt: React.ChangeEvent<HTMLSelectElement>) => {\n    if (!this.props.onChange) return;\n    this.props.onChange({\n      ...this.props.detail,\n      move: evt.target.value as 'L' | 'R',\n    });\n  };\n\n  private handleFocus = () => {\n    if (this.props.onFocus) this.props.onFocus();\n  };\n\n  private handleBlur = () => {\n    if (this.props.onBlur) this.props.onBlur();\n  };\n\n  private handleDeleteClick = () => {\n    if (this.props.onDelete) this.props.onDelete();\n  };\n}\n\nexport default TransitionDetail;\n","import React from 'react';\nimport classNames from 'classnames';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport * as A from '../state-mgmt/actions';\nimport { State } from '../state-mgmt/state';\nimport { TransitionDetail as TransitionDetailInfo, focusedDetail } from '../state-mgmt/TransitionDetail';\nimport { arrowById } from '../state-mgmt/Arrow';\nimport { nodeById } from '../state-mgmt/Node';\nimport { controlPointForArrow } from '../state-mgmt/ControlPoint';\nimport Vector from '../tools/Vector';\nimport TransitionDetail from '../TransitionDetail/TransitionDetail';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport { activeTransitionDetail } from '../state-mgmt/Sim';\nimport './TransitionDetails.css';\n\n// A single arrow between nodes can represent any number of transitions. In\n// order to display transitions in a compact manner, we group all transition\n// details for a certain arrow together in a \"Transition Details\" component. The\n// details (read/write/move) for each transition are rendered one on top of the\n// other, along with a button for adding new transitions. The main difficulty\n// here is in displaying the details in an aesthetically pleasing way: we want\n// them not to overlap with their associated arrow. To accomplish this, we\n// compute a \"stance\" for the details based on the orientation and curve of\n// their associated arrow -- either top-left, top-right, bottom-left, or\n// bottom-right. We then transform the details via CSS accordingly.\n\nexport interface TransitionDetailsProps {\n  arrowId: string;\n  details: TransitionDetailInfo[];\n  start: Vector;\n  end: Vector;\n  control: Vector;\n  isSelfLoop: boolean;\n  focusedDetail: null | string;\n  isEditable: boolean;\n  activeDetail: null | string;\n  changeDetail: (detail: TransitionDetailInfo) => void;\n  deleteDetail: (id: string, arrow: string) => void;\n  addDetail: (arrow: string) => void;\n  focusDetail: (id: string) => void;\n  blurDetail: (id: string) => void;\n}\n\nclass TransitionDetails extends React.Component<TransitionDetailsProps> {\n  render() {\n    const { details, control } = this.props;\n    const stance = this.computeStance();\n    const className = classNames(\n      'transition-details',\n      `transition-details--${stance}`,\n    );\n\n    return (\n      <div className={className}\n           style={{\n             // We initially anchor the component at its arrow's control point,\n             // and then use CSS transforms to move it according to its computed\n             // stance.\n             position: 'absolute',\n             left: control.x,\n             top: control.y,\n           }}>\n        {this.props.isEditable && !this.isTopStance(stance) && this.renderAddDetailButton()}\n        {details.map(detail => (\n          <TransitionDetail key={detail.id}\n                            detail={detail}\n                            isFocused={this.props.focusedDetail === detail.id}\n                            isEditable={this.props.isEditable}\n                            isActive={!this.props.isEditable && this.props.activeDetail === detail.id}\n                            onChange={this.handleDetailChange}\n                            onDelete={this.handleDetailDelete(detail.id, detail.arrow)}\n                            onFocus={this.handleDetailFocus(detail.id)}\n                            onBlur={this.handleDetailBlur(detail.id)} />\n        ))}\n        {this.props.isEditable && this.isTopStance(stance) && this.renderAddDetailButton()}\n      </div>\n    );\n  }\n\n  private handleDetailChange = (detail: TransitionDetailInfo) => {\n    this.props.changeDetail(detail);\n  };\n\n  private handleDetailDelete(id: string, arrow: string) {\n    return () => this.props.deleteDetail(id, arrow);\n  }\n\n  private handleDetailFocus(id: string) {\n    return () => this.props.focusDetail(id);\n  }\n\n  private handleDetailBlur(id: string) {\n    return () => this.props.blurDetail(id);\n  }\n\n  private handleAddDetailButton(arrow: string) {\n    return () => this.props.addDetail(arrow);\n  };\n\n  // As is often the case here, there are two possibilities to consider: (1) the\n  // details are associated with a self-loop, or (2) with a standard arrow.\n  private computeStance() {\n    if (this.props.isSelfLoop) {\n      return this.computeSelfLoopStance();\n    } else {\n      return this.computeStandardStance();\n    }\n  }\n\n  // In the self-loop case, we simply use the angle between the associated node\n  // and the control point.\n  private computeSelfLoopStance() {\n    const { start, control } = this.props;\n    const theta = control.minus(start).angle();\n    return this.computeClassNameFromAngle(theta);\n  }\n\n  // In the case of the standard stance, we use the angle of the line segment\n  // that passes through the control point perpendicular to the line joining the\n  // two nodes associated with the arrow in question. This seems to work quite\n  // well in keeping the details away from their associated arrow.\n  private computeStandardStance() {\n    const { start, end, control } = this.props;\n    const v1 = control.minus(start);\n    const v2 = v1.project(end.minus(start));\n    const angle = v1.minus(v2).angle();\n    return this.computeClassNameFromAngle(angle);\n  }\n\n  // Here we compute a stance from a given angle. The only tricky thing here is\n  // that the Y-axis is flipped (as is customary). Thus, any intuition about\n  // where the top of the box should go needs to be applied to the bottom, and\n  // vice-versa.\n  private computeClassNameFromAngle(angle: number) {\n    // 1st quadrant\n    if (0 < angle && angle <= Math.PI / 2) return 'top-left';\n    // 2nd quadrant\n    else if (Math.PI / 2 < angle && angle <= Math.PI) return 'top-right';\n    // 3rd quadrant\n    else if (-Math.PI / 2 > angle && angle >= -Math.PI) return 'bottom-right';\n    // 4th quadrant\n    else return 'bottom-left';\n  }\n\n  // In order to keep the details as close to their associated control point as\n  // possible, we render the \"add new\" button away from the control point: if\n  // the computed stance puts the details on top of the control point, we place\n  // the button on top of the details, and vice versa (see the \"render\" method).\n  private isTopStance(anchor: string) {\n    return /^top/.test(anchor);\n  }\n\n  private renderAddDetailButton() {\n    return (\n      <button className=\"transition-details__add-button\"\n              onClick={this.handleAddDetailButton(this.props.arrowId)}>\n        add new\n      </button>\n    );\n  }\n}\n\nconst mapStateToProps = (state: State, ownProps: any) => {\n  const arrow = arrowById(state, ownProps.arrowId);\n  const start = nodeById(state, arrow.start);\n  const end = nodeById(state, arrow.end);\n  const control = controlPointForArrow(state, arrow.id);\n  return {\n    start: start.pos,\n    end: end.pos,\n    control: control.pos,\n    isSelfLoop: start.id === end.id,\n    focusedDetail: focusedDetail(state),\n    isEditable: isInEditMode(state),\n    activeDetail: activeTransitionDetail(state),\n  };\n};\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  changeDetail: (detail: TransitionDetailInfo) => dispatch(A.changeTransitionDetail(detail)),\n  deleteDetail: (id: string, arrow: string) => dispatch(A.deleteTransitionDetail(id, arrow)),\n  addDetail: (arrow: string) => dispatch(A.addTransitionDetail(arrow)),\n  focusDetail: (id: string) => dispatch(A.focusTransitionDetail(id)),\n  blurDetail: (id: string) => dispatch(A.blurTransitionDetail(id)),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(TransitionDetails);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport * as A from '../state-mgmt/actions';\nimport { State } from '../state-mgmt/state';\nimport { isAddingNode, mousePos } from '../state-mgmt/UI';\nimport { NODE_RADIUS } from '../Node/Node';\nimport Vector from '../tools/Vector';\nimport './ShadowNode.css';\n\n// When the user is in the process of adding a new node, we render a \"shadow\n// node\" underneath the cursor to indicate the change in state. This node looks\n// much like a real node but lacks all of the functionality.\n\nexport interface ShadowNodeProps {\n  isVisible: boolean;\n  pos: Vector;\n  add: (pos: Vector) => void;\n}\n\nclass ShadowNode extends React.Component<ShadowNodeProps> {\n  render() {\n    const { isVisible, pos } = this.props;\n    return (isVisible &&\n      <div className=\"shadow-node\"\n           onMouseUp={this.handleMouseUp}\n           style={{\n             position: 'absolute',\n             left: pos.x - NODE_RADIUS,\n             top: pos.y - NODE_RADIUS - 2,\n           }}/>\n    );\n  }\n\n  private handleMouseUp = (e: React.MouseEvent) => {\n    this.props.add(this.props.pos);\n  };\n}\n\nconst mapStateToProps = (state: State) => ({\n  isVisible: isAddingNode(state),\n  pos: mousePos(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  add: (pos: Vector) => dispatch(A.addNode(pos)),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(ShadowNode);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport * as A from '../state-mgmt/actions';\nimport { State } from '../state-mgmt/state';\nimport{ Arrow as ArrowDetails, allArrows } from '../state-mgmt/Arrow';\nimport { Node as NodeDetails, allNodes } from '../state-mgmt/Node';\nimport { ControlPoint as ControlPointDetails, allControlPoints } from '../state-mgmt/ControlPoint';\nimport { TransitionDetail, allGroupedTransitionDetails } from '../state-mgmt/TransitionDetail';\nimport Arrow from '../Arrow/Arrow';\nimport Node from '../Node/Node';\nimport ControlPoint from '../ControlPoint/ControlPoint';\nimport TransitionDetails from '../TransitionDetails/TransitionDetails';\nimport ShadowNode from '../ShadowNode/ShadowNode';\nimport Vector from '../tools/Vector';\nimport './Canvas.css';\n\n// The canvas is the editing surface for the machine. It is responsible for\n// rendering all nodes, arrows, control points, and transition details.\n\nexport interface CanvasProps {\n  arrows: ArrowDetails[];\n  nodes: NodeDetails[];\n  controlPoints: ControlPointDetails[];\n  transitionDetails: { [key: string]: TransitionDetail[] };\n  mouseDown: (pos: Vector) => void;\n  mouseUp: () => void;\n  mouseMove: (pos: Vector) => void;\n}\n\nclass Canvas extends React.Component<CanvasProps> {\n  render() {\n    const { arrows, nodes, controlPoints, transitionDetails } = this.props;\n    // This configuration probably warrants an explanation. Some of the machine\n    // components (e.g. arrows, control points) need to be rendered in an SVG\n    // context. However, we cannot render the nodes and transition details\n    // inside of one (strictly speaking, we could use \"foreignObject\" elements,\n    // but this proved to be far more complicated). Therefore, we render an SVG\n    // element inside of a containing div, and render the HTML elements inside\n    // of the latter.\n    return (\n      <div className=\"canvas\"\n             onMouseDown={this.handleMouseDown}\n             onMouseUp={this.handleMouseUp}\n             onMouseMove={this.handleMouseMove}>\n        <svg xmlns=\"http://www.w3.org/2000/svg\"\n             width=\"100%\"\n             height=\"100%\">\n          {arrows.map(details => <Arrow key={details.id} details={details} />)}\n          {controlPoints.map(details => <ControlPoint key={details.id} details={details} />)}\n        </svg>\n        {nodes.map(details => <Node key={details.id} details={details} />)}\n        {Object.keys(transitionDetails).map(arrowId => (\n          <TransitionDetails key={arrowId} arrowId={arrowId} details={transitionDetails[arrowId]} />\n        ))}\n        <ShadowNode />\n      </div>\n    );\n  }\n\n  private handleMouseDown = (e: React.MouseEvent) => {\n    this.props.mouseDown(this.computeMousePos(e));\n  };\n\n  private handleMouseUp = () => {\n    this.props.mouseUp();\n  };\n\n  // We call \"preventDefault\" on the event in order to prevent the annoying text\n  // highlighting behavior that occurs when the user drags entities around on\n  // the screen.\n  private handleMouseMove = (e: React.MouseEvent) => {\n    e.preventDefault();\n    this.props.mouseMove(this.computeMousePos(e));\n  };\n\n  // Here we compute the position of the mouse relative to the canvas itself\n  // (rather than the browser client, or some other frame of reference).\n  private computeMousePos(e: React.MouseEvent) {\n    const { left, top } = e.currentTarget.getBoundingClientRect();\n    const { clientX, clientY } = e;\n    return new Vector(clientX - left, clientY - top);\n  };\n}\n\nconst mapStateToProps = (state: State) => ({\n  arrows: allArrows(state),\n  nodes: allNodes(state),\n  controlPoints: allControlPoints(state),\n  transitionDetails: allGroupedTransitionDetails(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  mouseDown: (pos: Vector) => dispatch(A.mouseDownCanvas(pos)),\n  mouseUp: () => dispatch(A.mouseUpCanvas()),\n  mouseMove: (pos: Vector) => dispatch(A.mouseMoveCanvas(pos)),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(Canvas);\n","import { State } from './state';\nimport { selectedNodes } from './Node';\n\n// Produces a list of all button types which should be displayed given the\n// current state.\nexport const whichButtonTypes = (state: State): EditButtonType[] => {\n  const selectedCount = selectedNodes(state).length;\n  switch (selectedCount) {\n    case 0: return [\n      EditButtonTypes.ADD_STATE,\n    ];\n    case 1: return [\n      EditButtonTypes.ADD_STATE,\n      EditButtonTypes.REMOVE_STATE,\n      EditButtonTypes.ADD_SELF_TRANSITION,\n      EditButtonTypes.MAKE_START,\n      EditButtonTypes.TOGGLE_ACCEPTING,\n    ];\n    case 2: return [\n      EditButtonTypes.ADD_STATE,\n      EditButtonTypes.REMOVE_STATES,\n      EditButtonTypes.ADD_TRANSITION,\n      EditButtonTypes.TOGGLE_ACCEPTING,\n    ];\n    default: return [\n      EditButtonTypes.ADD_STATE,\n      EditButtonTypes.REMOVE_STATES,\n      EditButtonTypes.TOGGLE_ACCEPTING,\n    ];\n  }\n};\n\nexport type EditButtonType = 'ADD_STATE'\n                           | 'REMOVE_STATE'\n                           | 'REMOVE_STATES'\n                           | 'ADD_SELF_TRANSITION'\n                           | 'ADD_TRANSITION'\n                           | 'MAKE_START'\n                           | 'UNMAKE_START'\n                           | 'TOGGLE_ACCEPTING';\n\nexport const EditButtonTypes: { [key: string]: EditButtonType } = {\n  ADD_STATE: 'ADD_STATE',\n  REMOVE_STATE: 'REMOVE_STATE',\n  REMOVE_STATES: 'REMOVE_STATES',\n  ADD_SELF_TRANSITION: 'ADD_SELF_TRANSITION',\n  ADD_TRANSITION: 'ADD_TRANSITION',\n  MAKE_START: 'MAKE_START',\n  UNMAKE_START: 'UNMAKE_START',\n  TOGGLE_ACCEPTING: 'TOGGLE_ACCEPTING',\n};\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport { State } from '../state-mgmt/state';\nimport *  as A from '../state-mgmt/actions';\nimport { whichButtonTypes, EditButtonType, EditButtonTypes } from '../state-mgmt/EditControls';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport './EditControls.css';\n\nexport interface EditControlsProps {\n  inEditMode: boolean;\n  buttonTypes: EditButtonType[];\n  addState: () => void;\n  removeStates: () => void;\n  addTransition: () => void;\n  makeStart: () => void;\n  toggleFinal: () => void;\n}\n\nclass EditControls extends React.Component<EditControlsProps> {\n  render() {\n    return (\n      <div className=\"edit-controls\">\n        {this.props.inEditMode && this.props.buttonTypes.map(type => (\n          <button className={`edit-controls__button edit-controls__button-${type}`}\n                  key={type}\n                  onClick={this.actions[type]} />\n        ))}\n      </div>\n    );\n  }\n\n  private actions: { [key: string]: () => void } = {\n    [EditButtonTypes.ADD_STATE]: () => this.props.addState(),\n    [EditButtonTypes.REMOVE_STATE]: () => this.props.removeStates(),\n    [EditButtonTypes.REMOVE_STATES]: () => this.props.removeStates(),\n    [EditButtonTypes.ADD_SELF_TRANSITION]: () => this.props.addTransition(),\n    [EditButtonTypes.ADD_TRANSITION]: () => this.props.addTransition(),\n    [EditButtonTypes.MAKE_START]: () => this.props.makeStart(),\n    [EditButtonTypes.TOGGLE_ACCEPTING]: () => this.props.toggleFinal(),\n  };\n}\n\nconst mapStateToProps = (state: State) => ({\n  inEditMode: isInEditMode(state),\n  buttonTypes: whichButtonTypes(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  addState: () => dispatch(A.startAddingNode()),\n  removeStates: () => dispatch(A.deleteSelectedNodes()),\n  addTransition: () => dispatch(A.addTransitionBetweenSelected()),\n  makeStart: () => dispatch(A.makeSelectedStartNode()),\n  toggleFinal: () => dispatch(A.toggleSelectedFinalNodes()),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(EditControls);\n","import React from 'react';\nimport './AppControls.css';\n\nexport interface AppControlsProps {}\n\nclass AppControls extends React.Component<AppControlsProps> {\n  render() {\n    return (\n      <div className=\"app-controls\">\n        <button className=\"app-controls__button app-controls__download-button\">\n        </button>\n        <button className=\"app-controls__button app-controls__upload-button\">\n        </button>\n\n        <a className=\"app-controls__link\" href=\"#tutorial\">Tutorial</a>\n        <a className=\"app-controls__link\" href=\"#about\">About</a>\n        <a className=\"app-controls__link app-controls__source-link\"\n           href=\"https://github.com/wjlewis/tm\"\n           target=\"_blank\"\n           rel=\"noopener noreferrer\">\n          &lt;Source&#47;&gt;\n        </a>\n      </div>\n    );\n  }\n}\n\nexport default AppControls;\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport classNames from 'classnames';\nimport { State } from '../state-mgmt/state';\nimport * as A from '../state-mgmt/actions';\nimport { tapeEntries, tapeCenter } from '../state-mgmt/Tape';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport './Tape.css';\n\nexport interface TapeProps {\n  entries: string[];\n  center: number;\n  isEditable: boolean;\n  setCenter: (pos: number) => void;\n  changeCell: (pos: number, value: string) => void;\n}\n\nexport const CELL_WIDTH = 36;\nexport const CELL_COUNT = 16;\n\nclass Tape extends React.Component<TapeProps> {\n  private tapeRef: React.RefObject<HTMLDivElement> = React.createRef();\n\n  render() {\n    const { isEditable } = this.props;\n\n    const cellClassName = classNames('tape__cell', {\n      'tape__cell--editable': isEditable,\n    });\n\n    return (\n      <>\n        <div className={`tape-reader${!isEditable ? ' tape-reader--active' : ''}`}\n             style={{\n               position: 'absolute',\n               left: `calc(50% - ${CELL_WIDTH / 2}px)`,\n             }} />\n        <div className=\"tape\"\n             ref={this.tapeRef}\n             style={{ width: `${CELL_WIDTH * CELL_COUNT}px` }}>\n          <div className=\"tape__cells\">\n            <div className=\"tape__padding-left\" style={{ width: `${CELL_WIDTH / 2}px` }} />\n            {this.props.entries.map((l, i) => (\n              <input key={i}\n                     disabled={!this.props.isEditable}\n                     className={cellClassName}\n                     onFocus={this.handleCellFocus(i)}\n                     value={l}\n                     onChange={this.handleCellChange(i)}\n                     style={{ width: `${CELL_WIDTH}px` }}\n                     type=\"text\"\n                     maxLength={1} />\n            ))}\n            <div className=\"tape__padding-right\" style={{ width: `${CELL_WIDTH / 2}px` }} />\n          </div>\n        </div>\n        <div className=\"tape-feed tape-feed__left\"\n             style={{\n               position: 'absolute',\n               left: `calc(50% - ${CELL_WIDTH * CELL_COUNT / 2 + 4}px)`,\n             }} />\n        <div className=\"tape-feed tape-feed__right\"\n             style={{\n               position: 'absolute',\n               left: `calc(50% + ${CELL_WIDTH * CELL_COUNT / 2 - 4}px)`,\n             }} />\n      </>\n    );\n  }\n\n  componentDidMount() {\n    this.recenter(false);\n  }\n\n  componentDidUpdate(oldProps: TapeProps) {\n    if (this.props.center !== oldProps.center) this.recenter();\n  }\n\n  private handleCellFocus(index: number) {\n    return () => this.props.setCenter(index);\n  }\n\n  private handleCellChange(pos: number) {\n    return (e: React.ChangeEvent<HTMLInputElement>) => {\n      this.props.changeCell(pos, e.target.value);\n    };\n  }\n\n  // Whenever the \"center\" of the tape changes, we scroll the (HTML) tape to\n  // place the new center cell in the center of the (HTML) tape.\n  private recenter(smooth: boolean=true) {\n    const cellGap = CELL_WIDTH * (this.props.center + 1 - CELL_COUNT / 2);\n    if (this.tapeRef.current) {\n      this.tapeRef.current.scrollTo({\n        left: cellGap,\n        top: 0,\n        behavior: smooth ? 'smooth' : undefined,\n      });\n    }\n  }\n}\n\nconst mapStateToProps = (state: State) => ({\n  entries: tapeEntries(state),\n  center: tapeCenter(state),\n  isEditable: isInEditMode(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  setCenter: (pos: number) => dispatch(A.setTapeCenter(pos)),\n  changeCell: (pos: number, value: string) => dispatch(A.changeTapeCell(pos, value)),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(Tape);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport { State } from '../state-mgmt/state';\nimport * as A from '../state-mgmt/actions';\nimport { isInEditMode } from '../state-mgmt/Mode';\nimport './SimControls.css';\n\nexport interface SimControlsProps {\n  reset: () => void;\n  pause: () => void;\n  step: () => void;\n  play: () => void;\n  isInEditMode: boolean;\n}\n\nclass SimControls extends React.Component<SimControlsProps> {\n  render() {\n    const { isInEditMode } = this.props;\n    return (\n      <div className=\"sim-controls\">\n        <button onClick={this.reset}>\n          Reset\n        </button>\n        <button onClick={this.togglePlayPause}>\n          {isInEditMode ? 'Play' : 'Pause'}\n        </button>\n        <button disabled={!isInEditMode}\n                onClick={this.step}>\n          Step\n        </button>\n      </div>\n    );\n  }\n\n  private reset = () => {\n    this.props.reset();\n  };\n\n  private togglePlayPause = () => {\n    if (this.props.isInEditMode) this.props.play();\n    else this.props.pause();\n  };\n\n  private step = () => {\n    this.props.step();\n  };\n}\n\nconst mapStateToProps = (state: State) => ({\n  isInEditMode: isInEditMode(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  reset: () => dispatch(A.resetSim()),\n  pause: () => dispatch(A.pauseSim()),\n  step: () => dispatch(A.stepSim()),\n  play: () => dispatch(A.playSim()),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(SimControls);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport { State } from '../state-mgmt/state';\nimport * as A from '../state-mgmt/actions';\nimport { showMessage, messageTitle, messageContent } from '../state-mgmt/Message';\nimport './Message.css';\n\nexport interface MessageProps {\n  show: boolean;\n  title: null | string;\n  content: null | string | JSX.Element;\n  dismiss: () => void;\n}\n\nclass Message extends React.Component<MessageProps> {\n  render() {\n    return this.props.show && (\n      <div className=\"message__container\" onClick={this.dismiss}>\n        <div className=\"message\" onClick={this.handleMessageClick}>\n          <h1 className=\"message__title\">{this.props.title}</h1>\n          <div className=\"message__content\">{this.props.content}</div>\n          <button className=\"message__dismiss-button\"\n                  onClick={this.dismiss}>\n            Dismiss\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  private handleMessageClick = (e: React.MouseEvent) => {\n    e.stopPropagation();\n  };\n\n  private dismiss = () => {\n    this.props.dismiss();\n  };\n}\n\nconst mapStateToProps = (state: State) => ({\n  show: showMessage(state),\n  title: messageTitle(state),\n  content: messageContent(state),\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  dismiss: () => dispatch(A.dismissMessage()),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(Message);\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'redux';\nimport { keyDown, keyUp } from '../state-mgmt/actions';\nimport Canvas from '../Canvas/Canvas';\nimport EditControls from '../EditControls/EditControls';\nimport AppControls from '../AppControls/AppControls';\nimport Tape from '../Tape/Tape';\nimport SimControls from '../SimControls/SimControls';\nimport Message from '../Message/Message';\nimport './App.css';\n\n// The entire app consists of only a few components: a \"canvas\" for displaying\n// the machine state editing UI, the machine's tape, some buttons that perform\n// various editing tasks, and some buttons for starting, pausing, stepping, and\n// resetting the machine.\n\nexport interface AppProps {\n  keyDown: (key: string, event: React.KeyboardEvent) => void;\n  keyUp: (key: string) => void;\n}\n\nclass App extends React.Component<AppProps> {\n  render() {\n    return (\n      <div className=\"app\">\n        <Canvas />\n        <Tape />\n        <EditControls />\n        <AppControls />\n        <SimControls />\n        <Message />\n      </div>\n    );\n  }\n\n  // We add the keyboard listeners to the document so that the user does not\n  // need to focus any element before keypresses can be recorded.\n  componentDidMount() {\n    document.addEventListener('keydown', this.handleKeyDown as unknown as EventListener);\n    document.addEventListener('keyup', this.handleKeyUp as unknown as EventListener);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('keydown', this.handleKeyDown as unknown as EventListener);\n    document.removeEventListener('keyup', this.handleKeyUp as unknown as EventListener);\n  }\n\n  private handleKeyDown = (e: React.KeyboardEvent) => {\n    this.props.keyDown(e.key, e);\n  };\n\n  private handleKeyUp = (e: React.KeyboardEvent) => {\n    this.props.keyUp(e.key);\n  };\n}\n\nconst mapDispatchToProps = (dispatch: Dispatch) => ({\n  keyDown: (key: string, event: React.KeyboardEvent) => dispatch(keyDown(key, event)),\n  keyUp: (key: string) => dispatch(keyUp(key)),\n});\n\nexport default connect(\n  null,\n  mapDispatchToProps,\n)(App);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport store from './state-mgmt/store';\nimport App from './App/App';\nimport './index.css';\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}